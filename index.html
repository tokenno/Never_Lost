<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spin - Motorcycle GPS Locator</title>
    <!-- Leaflet Map CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
    :root {
      --primary-color: #ff6600;
      --secondary-color: #333;
      --accent-color: #00ccff;
      --text-color: #fff;
      --warning-color: #ffcc00;
      --error-color: #ff3333;
      --success-color: #00cc66;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      color: var(--text-color);
      text-align: center;
      padding: 1em;
      max-width: 1000px;
      margin: 0 auto;
    }
    
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
      position: relative;
    }
    
    .app-title {
      font-size: 2.2em;
      margin: 0;
      color: var(--primary-color);
      text-shadow: 0 0 5px rgba(255, 102, 0, 0.3);
    }
    
    .wheel-container {
      position: relative;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .spinning-wheel {
      width: 50px;
      height: 50px;
      position: relative;
      animation: wheel-spin 3s linear infinite;
    }
    
    .wheel-outer {
      fill: none;
      stroke: var(--primary-color);
      stroke-width: 3;
      stroke-dasharray: 5;
      animation: wheel-dash 1s linear infinite;
    }
    
    .wheel-inner {
      fill: none;
      stroke: var(--accent-color);
      stroke-width: 2;
    }
    
    .wheel-spoke {
      stroke: var(--accent-color);
      stroke-width: 2;
      transform-origin: center;
    }
    
    .spoke-1 { animation: spoke-spin 4s linear infinite; }
    .spoke-2 { animation: spoke-spin 3s linear infinite reverse; }
    .spoke-3 { animation: spoke-spin 5s linear infinite; }
    
    @keyframes wheel-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes wheel-dash {
      to {
        stroke-dashoffset: -10;
      }
    }
    
    @keyframes spoke-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .wheel-pulse {
      fill: var(--primary-color);
      animation: wheel-pulse 2s ease-in-out infinite;
    }
    
    @keyframes wheel-pulse {
      0%, 100% { opacity: 0.7; transform: scale(0.95); }
      50% { opacity: 1; transform: scale(1); }
    }
    
    .dashboard {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .dashboard-item {
      background: rgba(40, 40, 40, 0.7);
      border-radius: 10px;
      padding: 10px;
      border: 1px solid #444;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    .dashboard-value {
      font-size: 1.8em;
      font-weight: bold;
      color: var(--accent-color);
      margin: 5px 0;
    }
    
    .dashboard-label {
      font-size: 0.9em;
      color: #aaa;
    }
    
    .panel {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid #444;
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        position: relative;
  z-index: 2;
  margin: 10px 0;
    }
    
    .control-group {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    
    input, button, select {
      margin: 0.5em;
      padding: 0.7em 1em;
      font-size: 1em;
      background: #333;
      color: var(--text-color);
      border: 1px solid #555;
      border-radius: 6px;
      transition: all 0.3s ease;
    }
    
    button {
      cursor: pointer;
      background: linear-gradient(to bottom, #444, #333);
      font-weight: bold;
    }
    
    button:hover:not(:disabled) {
      background: linear-gradient(to bottom, #555, #444);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .primary-btn {
      background: linear-gradient(to bottom, var(--primary-color), #e55d00);
      color: #fff;
      border: 1px solid #ff8533;
    }
    
    .secondary-btn {
      background: linear-gradient(to bottom, #555, #444);
      color: #fff;
    }
    
    .warning-btn {
      background: linear-gradient(to bottom, var(--warning-color), #e6b800);
      color: #000;
    }
    
    .emergency-btn {
      background: linear-gradient(to bottom, var(--error-color), #cc0000);
      color: #fff;
      animation: pulse-emergency 2s infinite;
    }
    
    @keyframes pulse-emergency {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    #debug {
      text-align: left;
      margin: 20px auto;
      padding: 10px;
      border: 1px dashed #555;
      color: #aaa;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9em;
      background: rgba(20, 20, 20, 0.8);
      border-radius: 5px;
    }
    
    .status {
      margin: 10px 0;
      padding: 8px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .success {
      background: rgba(0, 204, 102, 0.2);
      border: 1px solid var(--success-color);
      color: var(--success-color);
    }
    
    .error {
      background: rgba(255, 51, 51, 0.2);
      border: 1px solid var(--error-color);
      color: var(--error-color);
    }
    
    .warning {
      background: rgba(255, 204, 0, 0.2);
      border: 1px solid var(--warning-color);
      color: var(--warning-color);
    }
    
    .speed-indicator {
      font-size: 1em;
      margin-top: 5px;
      color: var(--accent-color);
      font-weight: bold;
    }
    
    .auto-lock-settings {
      margin-top: 10px;
      padding: 10px;
      border-top: 1px dashed #555;
    }
    
    .slider-label {
      display: inline-flex;
      align-items: center;
      margin-left: 5px;
      color: var(--accent-color);
    }
    
    .direction-container {
      position: relative;
      width: 100px;
      height: 100px;
      margin: 10px auto;
    }
    
    #directionArrow {
      width: 0; 
      height: 0; 
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 40px solid var(--primary-color);
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: 50% 0;
      transform: translate(-50%, -50%) rotate(0deg);
      transition: transform 0.3s ease;
    }
    
    .direction-circle {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 1px dashed var(--accent-color);
      border-radius: 50%;
      top: 0;
      left: 0;
      box-sizing: border-box;
    }
    
    .direction-status {
      font-size: 0.9em;
      margin-top: 5px;
    }
    
 /* Fix map container height */
#map {
  height: 250px !important; /* Limit map height */
  max-height: 250px;
  position: relative !important;
  z-index: 1 !important;
}
    
    .user-marker, .lock-marker {
      font-size: 20px;
      text-shadow: 0 0 3px #000;
    }
    
    .leaflet-control-attribution {
      background: rgba(0, 0, 0, 0.7) !important;
      color: #aaa !important;
      font-family: monospace;
      font-size: 0.8em;
    }
    
    .reached-message {
      color: var(--success-color);
      font-weight: bold;
      animation: pulse 1.5s infinite;
    }
    
    button.muted {
      background: #f00 !important;
      color: #fff !important;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .lean-container {
      position: relative;
      width: 200px;
      height: 100px;
      margin: 10px auto;
      background: rgba(50, 50, 50, 0.7);
      border-radius: 100px 100px 0 0;
      overflow: hidden;
    }
    
    .lean-bike {
      position: absolute;
      width: 40px;
      height: 60px;
      background: var(--primary-color);
      border-radius: 10px 10px 0 0;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      transition: transform 0.1s ease; /* Faster transition for lean angle */
    }
    
    .lean-scale {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: space-around;
    }
    
    .lean-mark {
      width: 1px;
      height: 10px;
      background: #666;
      position: relative;
      top: 10px;
    }
    
    .lean-mark:nth-child(6) {
      height: 20px;
      background: var(--accent-color);
    }
    
    .lean-value {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-weight: bold;
      color: var(--accent-color);
    }
    
    .tabs {
      display: flex;
      margin-bottom: 10px;
      border-bottom: 1px solid #444;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
      margin-right: 5px;
      background: rgba(50, 50, 50, 0.7);
    }
    
    .tab.active {
      background: rgba(30, 30, 30, 0.9);
      border-color: #444;
      border-bottom: 1px solid rgba(30, 30, 30, 0.9);
      margin-bottom: -1px;
    }
    
 
    .maintenance-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin: 5px 0;
      background: rgba(50, 50, 50, 0.5);
      border-radius: 5px;
    }
    
    .maintenance-progress {
      height: 10px;
      background: #333;
      border-radius: 5px;
      flex-grow: 1;
      margin: 0 10px;
      overflow: hidden;
    }
    
    .maintenance-progress-bar {
      height: 100%;
      background: linear-gradient(to right, var(--success-color), var(--warning-color), var(--error-color));
      border-radius: 5px;
    }
    
    .emergency-panel {
      background: rgba(204, 0, 0, 0.2);
      border: 1px solid var(--error-color);
    }
    
    .emergency-contacts {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin: 10px 0;
    }
    
    .contact-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: rgba(50, 50, 50, 0.7);
      border-radius: 5px;
      min-width: 120px;
    }
    
    .collapsible {
      cursor: pointer;
      padding: 10px;
      border: none;
      text-align: center;
      outline: none;
      font-size: 1em;
      color: var(--primary-color);
      background: transparent;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .collapsible:after {
      content: '▼';
      font-size: 0.8em;
      margin-left: 5px;
      transition: transform 0.2s;
    }
    
    .collapsible.active:after {
      transform: rotate(180deg);
    }
    
    .collapsible-content {
      padding: 0 10px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.2s ease-out;
    }
    
    .corner-analysis {
      margin: 10px 0;
      padding: 10px;
      background: rgba(50, 50, 50, 0.5);
      border-radius: 5px;
      text-align: left;
    }
    
 
      
      /* Triple-tap overlay styles */
.triple-tap-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  z-index: 10000;
  display: none;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

.triple-tap-overlay.active {
  display: flex;
}

.enlarged-wheel {
  width: 200px;
  height: 200px;
  position: relative;
  margin-bottom: 30px;
}

.enlarged-wheel .wheel-outer {
  fill: none;
  stroke: var(--primary-color);
  stroke-width: 4;
  stroke-dasharray: 5;
  animation: wheel-dash 1s linear infinite;
}

.enlarged-wheel .wheel-inner {
  fill: none;
  stroke: var(--accent-color);
  stroke-width: 3;
}

.enlarged-wheel .wheel-spoke {
  stroke: var(--accent-color);
  stroke-width: 3;
  transform-origin: center;
}

.enlarged-wheel .wheel-pulse {
  fill: var(--primary-color);
  animation: wheel-pulse 2s ease-in-out infinite;
}

.overlay-stats {
  text-align: center;
  background: rgba(40, 40, 40, 0.8);
  padding: 20px;
  border-radius: 15px;
  border: 2px solid var(--primary-color);
  min-width: 250px;
}

.overlay-stat-item {
  margin: 10px 0;
  font-size: 1.2em;
}

.overlay-stat-value {
  color: var(--accent-color);
  font-weight: bold;
  font-size: 1.4em;
}

.overlay-close-hint {
  position: absolute;
  bottom: 30px;
  color: #aaa;
  font-size: 0.9em;
}
      
      /* Session styles */
.session-info {
  background: rgba(50, 50, 50, 0.7);
  padding: 15px;
  border-radius: 8px;
  margin: 10px 0;
  border-left: 4px solid var(--primary-color);
}

.session-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  font-size: 0.9em;
}

.session-stats div {
  padding: 5px 0;
}

.session-history {
  max-height: 400px;
  overflow-y: auto;
}

.session-item {
  background: rgba(50, 50, 50, 0.5);
  border: 1px solid #444;
  border-radius: 8px;
  padding: 15px;
  margin: 10px 0;
  transition: all 0.3s ease;
}

.session-item:hover {
  background: rgba(60, 60, 60, 0.7);
  border-color: #555;
}

.session-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.session-header strong {
  color: var(--accent-color);
  font-size: 1.1em;
}

.session-date {
  color: #aaa;
  font-size: 0.9em;
}

.session-details {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 0.9em;
  color: #ccc;
}

.session-actions {
  display: flex;
  gap: 5px;
}

.session-actions button {
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  background: #555;
  color: white;
  cursor: pointer;
  transition: background 0.3s;
}

.session-actions button:hover {
  background: #666;
}
      
      .elevation-profile-container {
  margin: 10px 0;
  padding: 10px;
  background: rgba(50, 50, 50, 0.5);
  border-radius: 5px;
}

.elevation-profile {
  height: 120px;
  width: 100%;
  background: #333;
  border-radius: 5px;
  margin: 10px 0;
  position: relative;
  overflow: hidden;
}

.elevation-profile canvas {
  width: 100% !important;
  height: 100% !important;
  display: block;
}

.session-notes {
  margin-top: 10px;
  padding: 10px;
  background: rgba(40, 40, 40, 0.5);
  border-radius: 4px;
  font-size: 0.9em;
  color: #aaa;
  border-left: 3px solid var(--warning-color);
}
    .recording-instructions {
  background: rgba(50, 50, 50, 0.5);
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
  border-left: 3px solid var(--accent-color);
}

.calibration-info {
  background: rgba(40, 40, 40, 0.7);
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
}

.calibration-info div {
  margin: 5px 0;
  font-size: 0.9em;
}

#startRecordingBtn.recording {
  animation: pulse 1s infinite;
  background: linear-gradient(to bottom, #ff3333, #cc0000) !important;
}
      
      .maintenance-item {
  display: flex;
  align-items: center;
  padding: 10px;
  margin: 8px 0;
  background: #2a2a2a;
  border-radius: 5px;
  border-left: 3px solid var(--accent-color);
}

.maintenance-progress {
  flex: 1;
  height: 20px;
  background: #444;
  border-radius: 10px;
  overflow: hidden;
  margin: 0 10px;
}

.maintenance-progress-bar {
  height: 100%;
  transition: width 0.3s ease;
}

input[type="range"] {
  -webkit-appearance: none;
  height: 6px;
  background: #555;
  border-radius: 3px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px;
  height: 18px;
  background: var(--accent-color);
  border-radius: 50%;
  cursor: pointer;
}
      
/* Tab content styling */
.tab-content {
  display: none;
  width: 100%;
  position: relative;
}

.tab-content.active {
  display: block;
}
      
    @media (max-width: 768px) {
      .dashboard {
        grid-template-columns: 1fr;
      }
      
      .app-header {
        flex-direction: column;
      }
      
      .control-group {
        flex-direction: column;
        align-items: center;
      }
      
      .wheel-container {
        margin-top: 10px;
      }
    }
  </style>
  </head>
  <body>
    <!-- Triple Tap Overlay -->
    <div class="triple-tap-overlay" id="tripleTapOverlay">
      <div class="enlarged-wheel">
        <svg viewBox="0 0 100 100">
          <circle class="wheel-outer" cx="50" cy="50" r="40"></circle>
          <circle class="wheel-inner" cx="50" cy="50" r="25"></circle>
          <line class="wheel-spoke spoke-1" x1="50" y1="50" x2="75" y2="50"></line>
          <line class="wheel-spoke spoke-2" x1="50" y1="50" x2="50" y2="25"></line>
          <line class="wheel-spoke spoke-3" x1="50" y1="50" x2="30" y2="70"></line>
          <circle class="wheel-pulse" cx="50" cy="50" r="8"></circle> </svg> </div>
      <div class="overlay-stats">
        <div class="overlay-stat-item"> Average Speed: <span class="overlay-stat-value"
            id="overlayAvgSpeed">--
            km/h</span> </div>
        <div class="overlay-stat-item"> Current Lean: <span class="overlay-stat-value"
            id="overlayLeanAngle">--°</span>
        </div>
        <div class="overlay-stat-item"> Max Lean: <span class="overlay-stat-value"
            id="overlayMaxLean">--°</span>
        </div>
        <div class="overlay-stat-item"> Current Speed: <span class="overlay-stat-value"
            id="overlayCurrentSpeed">--
            km/h</span> </div>
      </div>
      <div class="overlay-close-hint">Tap anywhere to close</div>
    </div>
    <div class="app-header">
      <h1 class="app-title">Spin</h1>
      <div class="wheel-container">
        <svg class="spinning-wheel" viewBox="0 0 100 100">
          <circle class="wheel-outer" cx="50" cy="50" r="40"></circle>
          <circle class="wheel-inner" cx="50" cy="50" r="25"></circle>
          <line class="wheel-spoke spoke-1" x1="50" y1="50" x2="75" y2="50"></line>
          <line class="wheel-spoke spoke-2" x1="50" y1="50" x2="50" y2="25"></line>
          <line class="wheel-spoke spoke-3" x1="50" y1="50" x2="30" y2="70"></line>
          <circle class="wheel-pulse" cx="50" cy="50" r="8"></circle> </svg> </div>
    </div>
    <div class="dashboard">
      <div class="dashboard-item">
        <div class="dashboard-label">Current Speed</div>
        <div class="dashboard-value" id="currentSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Speed</div>
        <div class="dashboard-value" id="maxSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Average Speed</div>
        <div class="dashboard-value" id="avgSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Current Lean Angle</div>
        <div class="dashboard-value" id="leanAngle">--°</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Today's Distance</div>
        <div class="dashboard-value" id="todayDistance">-- km</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Elevation Gain</div>
        <div class="dashboard-value" id="elevationGain">-- m</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Cornering Speed</div>
        <div class="dashboard-value" id="maxCornerSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Corner G</div>
        <div class="dashboard-value" id="maxCornerG">-- g</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">0-100 km/h</div>
        <div class="dashboard-value" id="accelerationTime">-- s</div>
      </div>
    </div>
    <div class="tabs">
      <div class="tab active" data-tab="metrics">Metrics</div>
      <div class="tab" data-tab="navigation">Nav</div>
      <div class="tab" data-tab="emergency">SOS</div>
      <div class="tab" data-tab="maintenance">Upkeep</div>
    </div>
    <div class="tab-content active" id="metrics-tab">
      <div class="panel">
        <h2>Ride Metrics</h2>
        <!-- Session Management -->
        <div class="panel">
          <h3>Ride Session Management</h3>
          <button id="startRideBtn" class="primary-btn">Let's Ride</button>
          <div class="control-group"> <button id="startSessionBtn" class="primary-btn"
              onclick="MotoFindBack.startNewSession()">🏁
              Start New Session</button><button id="saveSessionBtn" class="secondary-btn"
              onclick="MotoFindBack.saveCurrentSession()">💾
              Save Session</button> <button id="calibrateBtn" class="secondary-btn">Calibrate
              Sensors</button> <button onclick="MotoFindBack.toggleEmergency()"
              class="secondary-btn">
              Emergency: <span id="emergencyStatus">ENABLED</span> </button> <button
              id="quickSaveBtn"
              class="secondary-btn"
              onclick="MotoFindBack.quickSaveSession()">⚡
              Quick Save</button> <button id="exportSessionBtn" class="secondary-btn"
              onclick="MotoFindBack.exportSession()">📤
              Export Current</button> </div>
          <div id="sessionInfo" class="session-info" style="display: none;">
            <h4>Current Session</h4>
            <div class="session-stats">
              <div>Name: <span id="sessionName">--</span></div>
              <div>Duration: <span id="sessionDuration">--</span></div>
              <div>Distance: <span id="sessionDistance">--</span></div>
              <div>Max Speed: <span id="sessionMaxSpeed">--</span></div>
              <div>Corners: <span id="sessionCorners">--</span></div>
            </div>
          </div>
        </div>
        <div class="panel">
          <h3>Sensor Calibration Status</h3>
          <div class="calibration-info">
            <div>Lean Offset: <span id="calibrationLeanOffset">0°</span></div>
            <div>Normal Riding Position: <span id="calibrationNormalBeta">--°</span></div>
            <div>Crash Threshold: <span id="calibrationCrashThreshold">--°</span></div>
            <div>Current Deviation: <span id="currentDeviation">--°</span></div>
          </div>
        </div>
        <!-- Session History -->
        <div class="panel">
          <h3>Session History</h3>
          <div id="sessionHistoryList" class="session-history">
            <div style="text-align: center; color: #aaa; padding: 20px;">No
              saved sessions yet</div>
          </div>
        </div>
        <!-- General Statistics -->
        <div class="panel">
          <h3>📊 General Statistics (All Sessions)</h3>
          <div class="dashboard">
            <div class="dashboard-item">
              <div class="dashboard-label">Total Distance</div>
              <div class="dashboard-value" id="statsTotalDistance">0 km</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Speed</div>
              <div class="dashboard-value" id="statsMaxSpeedAll">0 km/h</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Lean Angle</div>
              <div class="dashboard-value" id="statsMaxLeanAll">0°</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Elevation Gain</div>
              <div class="dashboard-value" id="statsMaxElevationAll">0 m</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Corner Speed</div>
              <div class="dashboard-value" id="statsMaxCornerSpeedAll">0 km/h</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Corner G</div>
              <div class="dashboard-value" id="statsMaxCornerGAll">0 g</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Best 0-60 km/h</div>
              <div class="dashboard-value" id="statsBest0to60">-- s</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Best 0-100 km/h</div>
              <div class="dashboard-value" id="statsBest0to100">-- s</div>
            </div>
          </div>
          <div class="control-group" style="margin-top: 15px;"> <button onclick="MotoFindBack.updateGeneralStatistics()"
              class="secondary-btn">Refresh
              Stats</button> <button onclick="MotoFindBack.exportAllStatistics()"
              class="secondary-btn">Export
              All Data</button> <button onclick="MotoFindBack.clearAllStatistics()"
              class="secondary-btn"
              style="background: var(--error-color);">Clear
              All Data</button> </div>
        </div>
        <button id="resetMetricsBtn" class="secondary-btn">Reset Metrics</button>
        <button id="exportMetricsBtn" class="secondary-btn">Export Data</button>
      </div>
      <!-- Acceleration Popup -->
      <div class="setting-item">
        <h4>Acceleration Popup</h4>
        <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
          <label>Target Speed:</label> <input id="accelTarget" min="20" max="200"
            value="100"
            style="flex: 1;"
            type="range">
          <span id="accelTargetValue">100 km/h</span> </div>
        <div style="margin: 10px 0;"> <button onclick="MotoFindBack.testAccelerationPopup()"
            class="secondary-btn">Test
            Popup</button> </div>
      </div>
      <!-- Lean Angle Display -->
      <div class="lean-container">
        <div class="lean-scale">
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
        </div>
        <div class="lean-bike" id="leanBike"></div>
        <div class="lean-value" id="leanValue">0°</div>
      </div>
      <!-- Corner Analysis -->
      <div class="corner-analysis">
        <h3>Cornering Analysis</h3>
        <p>Current Corner G: <span id="currentCornerG">0 g</span></p>
        <p>Max Corner Speed: <span id="currentMaxCornerSpeed">0 km/h</span></p>
        <p>Avg Corner Lean: <span id="avgCornerLean">0°</span></p>
        <div id="cornerList">No corners detected yet.</div>
      </div>
      <!-- Elevation Profile -->
      <div class="elevation-profile-container">
        <h3>Elevation Profile</h3>
        <div class="elevation-profile"> <canvas id="elevationCanvas"></canvas>
        </div>
        <p>Total Elevation Gain: <span id="totalElevationGain">0 m</span></p>
      </div>
      <!-- Statistics -->
      <div class="control-group">
        <div class="control-item">
          <h3>Distance Statistics</h3>
          <div>Today: <span id="statsToday">0 km</span></div>
          <div>This Week: <span id="statsWeek">0 km</span></div>
          <div>This Month: <span id="statsMonth">0 km</span></div>
          <div>Total: <span id="statsTotal">0 km</span></div>
        </div>
        <div class="control-item">
          <h3>Speed Statistics</h3>
          <div>Current: <span id="statsCurrentSpeed">0 km/h</span></div>
          <div>Average: <span id="statsAvgSpeed">0 km/h</span></div>
          <div>Max: <span id="statsMaxSpeed">0 km/h</span></div>
          <div>0-100 km/h: <span id="statsAcceleration">-- s</span></div>
        </div>
      </div>
      <!-- Engine Sound Analysis -->
      <div class="panel">
        <h3>Engine Sound Analysis</h3>
        <div class="control-group"> <button id="startEngineAnalysis" class="primary-btn">Start
            Engine Analysis</button> <button onclick="MotoFindBack.stopEngineAnalysis()"
            class="secondary-btn">Stop
            Analysis</button> <button id="calibrateEngine" class="secondary-btn">Calibrate
            Engine</button> </div>
        <div class="dashboard">
          <div class="dashboard-item">
            <div class="dashboard-label">Engine RPM</div>
            <div class="dashboard-value" id="engineRPM">--</div>
          </div>
          <div class="dashboard-item">
            <div class="dashboard-label">Estimated Gear</div>
            <div class="dashboard-value" id="engineGear">--</div>
          </div>
          <div class="dashboard-item">
            <div class="dashboard-label">Engine Health</div>
            <div class="dashboard-value" id="engineHealth">--</div>
          </div>
          <div class="dashboard-item">
            <div class="dashboard-label">Sound Level</div>
            <div class="dashboard-value" id="engineVolume">-- dB</div>
          </div>
        </div>
        <!-- Calibration Section -->
        <div class="control-item">
          <h4>Impulse Response Calibration</h4>
          <div class="control-group"> <button id="startRecordingBtn" class="primary-btn"
              onclick="MotoFindBack.startRecordingCalibration()">🎤
              Record Engine Sample</button> <button class="secondary-btn" onclick="MotoFindBack.stopRecordingCalibration()">Stop
              Recording</button> </div>
          <!-- Calibration Debug -->
          <div style="border: 1px solid #ff6600; padding: 10px; margin: 10px 0; border-radius: 5px;">
            <h4>🔧 Calibration Debug</h4>
            <button id="calibrationMonitorBtn" onclick="MotoFindBack.startCalibrationMonitor()"
              class="secondary-btn">Start
              Monitor</button> <button onclick="MotoFindBack.manualCalibration()"
              class="secondary-btn">Manual
              Calibration</button> <button onclick="MotoFindBack.resetCalibration()"
              class="secondary-btn"
              style="background: var(--error-color);">Reset
              Calibration</button> </div>
          <div class="recording-instructions">
            <p><strong>How to calibrate:</strong></p>
            <ol style="text-align: left; font-size: 0.9em; color: #ccc;">
              <li>Start engine analysis</li>
              <li>Click "Record Engine Sample"</li>
              <li>Rev engine steadily for 3 seconds</li>
              <li>System will auto-analyze your engine sound</li>
            </ol>
          </div>
          <div class="calibration-info">
            <div>Bike Profile: <span id="bikeProfileName">Uncalibrated</span></div>
            <div>Calibration: <span id="calibrationStatus">Not calibrated</span></div>
            <div>Detected Range: <span id="detectedRange">--</span></div>
            <div>Calibration Factor: <span id="calibrationMultiplier">--</span></div>
          </div>
        </div>
        <!-- Sound Spectrum -->
        <div class="control-item">
          <h4>Sound Spectrum</h4>
          <canvas id="frequencyCanvas" width="100%" height="100" style="background: #222; border-radius: 5px;"></canvas>
        </div>
        <!-- Debug Info -->
        <div class="control-item">
          <h4>Debug Info</h4>
          <div>Microphone Status: <span id="micStatus">Not Started</span></div>
          <div>Dominant Frequency: <span id="debugFreq">0</span> Hz</div>
          <div>Max Volume: <span id="debugVolume">0</span></div>
          <div>Total Energy: <span id="debugEnergy">0</span></div>
        </div>
        <!-- Shift Analysis -->
        <div class="control-group">
          <div class="control-item">
            <h4>Shift Analysis</h4>
            <div>Total Shifts: <span id="totalShifts">0</span></div>
            <div>Last Shift Quality: <span id="lastShiftQuality">--</span></div>
            <div>Avg Shift RPM: <span id="avgShiftRPM">--</span></div>
          </div>
        </div>
      </div>
      <!-- Corner Chart -->
      <div class="panel">
        <h3>Cornering Analysis</h3>
        <canvas id="cornerChart" width="100%" height="200"></canvas>
        <p>Current Corner G: <span id="currentCornerG">0 g</span></p>
        <p>Max Corner Speed: <span id="currentMaxCornerSpeed">0 km/h</span></p>
        <p>Avg Corner Lean: <span id="avgCornerLean">0°</span></p>
        <p>Avg Corner Entry Speed: <span id="avgCornerEntrySpeed">0 km/h</span></p>
        <div id="cornerList">No corners detected yet.</div>
      </div>
      <!-- Ride History -->
      <div class="control-item">
        <h3>Ride History</h3>
        <div id="rideHistory" style="max-height: 200px; overflow-y: auto; text-align: left; padding: 10px; background: rgba(40,40,40,0.7); border-radius: 5px;">
          No ride history yet. </div>
      </div>
    </div>
    <div class="tab-content" id="navigation-tab">
      <div class="panel">
        <h2>GPS Navigation</h2>
        <p class="warning">LOCK POSITION</p>
        <div class="control-group"> <button id="testBtn" class="primary-btn">Lock
            Position</button><button id="autoLockBtn" class="secondary-btn" disabled="disabled">Auto-Lock
            Mode</button> <button id="muteBtn" class="secondary-btn" disabled="disabled">Mute
            Sound</button> <button id="stopBtn" class="secondary-btn" disabled="disabled">Stop</button>
        </div>
        <div id="autoLockSettings" style="display: none;">
          <div class="control-group">
            <div class="control-item"> <label for="stationaryTime">Stationary
                Confirmation Time</label>
              <div> <input id="stationaryTime" value="30" min="5" max="60" type="range">
                <span id="stationaryTimeValue" class="slider-label">30 sec</span>
              </div>
            </div>
            <div class="control-item"> <label for="speedThreshold">Speed
                Threshold (km/h)</label>
              <div> <input id="speedThreshold" value="10" min="5" max="20" type="range">
                <span id="speedThresholdValue" class="slider-label">10 km/h</span>
              </div>
            </div>
          </div>
        </div>
        <div id="lockStatus" class="status">Lock Status: Not locked</div>
        <div id="audioStatus" class="status">Audio: Not initialized</div>
        <div id="gpsStatus" class="status">GPS: Ready</div>
        <div id="reachedMessage" class="reached-message" style="display: none;">You
          have reached GPS locked point!</div>
      </div>
      <div class="panel">
        <h2>Position Map</h2>
        <div id="map"></div>
      </div>
      <div class="panel"> <button class="collapsible">Direction Indicator ▼</button>
        <div class="collapsible-content">
          <div class="direction-container">
            <div id="directionArrow"></div>
            <div class="direction-circle"></div>
          </div>
          <div id="directionStatus" class="direction-status">Direction: --</div>
        </div>
        <button class="collapsible">Sonar Parameters ▼</button>
        <div class="collapsible-content">
          <div class="control-group">
            <div class="control-item"> <label for="freqInput">Bleep Freq (Hz)</label><br>
              <input id="freqInput" value="800" min="20" max="20000" type="number">
            </div>
            <div class="control-item"> <label for="maxDistInput">Max Distance
                (m)</label><br>
              <input id="maxDistInput" value="50" min="1" max="500" type="range">
              <span id="maxDistValue">50</span> m </div>
          </div>
        </div>
        <button class="collapsible">Data Output ▼</button>
        <div class="collapsible-content">
          <div class="control-group">
            <div class="control-item"> <label>Distance</label><br>
              <span id="distance">--</span> m </div>
            <div class="control-item"> <label>Accuracy</label><br>
              <span id="accuracy">--</span> m </div>
            <div class="control-item"> <label>BPM</label><br>
              <span id="bleepRate">--</span> </div>
          </div>
        </div>
      </div>
    </div>
    <div class="tab-content" id="emergency-tab">
      <div class="panel emergency-panel">
        <h2>Emergency Features</h2>
        <div class="control-group"> <button id="emergencyBtn" class="emergency-btn">EMERGENCY
            ALERT</button> </div>
        <div id="crashStatus" class="status">Crash Detection: Inactive</div>
        <div class="control-group">
          <div class="control-item"> <label for="emergencyMessage">Emergency
              Message</label><br>
            <textarea id="emergencyMessage" rows="3" style="width: 100%;">I need help! My current location is: </textarea>
          </div>
        </div>
        <h3>Emergency Contacts</h3>
        <div class="emergency-contacts" id="emergencyContactList">
          <!-- Contacts will appear here --> </div>
        <div class="control-group"> <button id="addContactBtn" class="primary-btn">➕
            Add Contact</button> <button id="testEmergencyBtn" class="warning-btn">Test
            Emergency</button> <button id="callEmergencyBtn" class="emergency-btn"
            onclick="MotoFindBack.callEmergency()">Call
            112/911</button> </div>
        <!-- Add Contact Modal -->
        <div id="addContactModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center;">
          <div style="background: #333; padding: 20px; border-radius: 10px; width: 90%; max-width: 400px;">
            <h3>Add Emergency Contact</h3>
            <input id="newContactName" placeholder="Contact Name" style="width: 100%; margin: 10px 0; padding: 10px; background: #444; color: white; border: 1px solid #555; border-radius: 5px;"
              type="text">
            <input id="newContactNumber" placeholder="Phone Number" style="width: 100%; margin: 10px 0; padding: 10px; background: #444; color: white; border: 1px solid #555; border-radius: 5px;"
              type="text">
            <div style="display: flex; gap: 10px; margin-top: 15px;"> <button onclick="MotoFindBack.saveNewContact()"
                class="primary-btn"
                style="flex: 1;">Save</button>
              <button onclick="MotoFindBack.closeContactModal()" class="secondary-btn"
                style="flex: 1;">Cancel</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="tab-content" id="maintenance-tab">
      <div class="panel">
        <h2>Maintenance Alerts</h2>
        <div class="control-group"> <button id="addMaintenanceBtn" class="primary-btn">Add
            Maintenance Item</button> <button id="resetMaintenanceBtn" class="secondary-btn">Reset
            All</button> </div>
        <div id="maintenanceList">
          <div class="maintenance-item">
            <div>Oil Change</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 30%;"></div>
            </div>
            <div>2000/5000 km</div>
          </div>
          <div class="maintenance-item">
            <div>Tire Pressure</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 70%;"></div>
            </div>
            <div>Check weekly</div>
          </div>
          <div class="maintenance-item">
            <div>Chain Lubrication</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 50%;"></div>
            </div>
            <div>500/1000 km</div>
          </div>
        </div>
        <div class="control-group">
          <!-- Updated Maintenance Form -->
          <div class="setting-item">
            <h4>Add New Maintenance Item</h4>
            <div style="margin: 10px 0;"> <input id="newMaintenanceName" placeholder="Maintenance Item (e.g., Oil Change)"
                style="width: 100%; padding: 8px; margin-bottom: 10px;"
                type="text">
              <div style="margin: 10px 0;"> <label style="display: block; margin-bottom: 5px; color: #ccc;">Track
                  by:</label>
                <div style="display: flex; gap: 15px; margin-bottom: 10px;"> <label
                    style="display: flex; align-items: center; gap: 5px;">
                    <input name="maintenanceUnit" value="km" checked="checked" type="radio">
                    Kilometers </label> <label style="display: flex; align-items: center; gap: 5px;">
                    <input name="maintenanceUnit" value="weeks" type="radio">
                    Weeks </label> </div>
              </div>
              <div id="kmSettings" style="margin: 10px 0;"> <label style="display: block; margin-bottom: 5px; color: #ccc;">Interval
                  (kilometers):</label> <input id="newMaintenanceInterval" min="100"
                  max="10000"
                  step="100"
                  value="5000"
                  style="width: 100%;"
                  type="range">
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                  <span style="font-size: 0.8em; color: #aaa;">100 km</span> <span
                    id="intervalValue"
                    style="font-weight: bold;">5000
                    km</span> <span style="font-size: 0.8em; color: #aaa;">10000
                    km</span> </div>
              </div>
              <div id="weekSettings" style="margin: 10px 0; display: none;"> <label
                  style="display: block; margin-bottom: 5px; color: #ccc;">Interval
                  (weeks):</label> <input id="newMaintenanceWeeks" min="1" max="52"
                  step="1"
                  value="4"
                  style="width: 100%;"
                  type="range">
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                  <span style="font-size: 0.8em; color: #aaa;">1 week</span> <span
                    id="weeksValue"
                    style="font-weight: bold;">4
                    weeks</span> <span style="font-size: 0.8em; color: #aaa;">52
                    weeks</span> </div>
              </div>
            </div>
            <div style="display: flex; gap: 10px;"> <button id="saveMaintenanceBtn"
                class="primary-btn">Add
                Maintenance Item</button> <button id="resetMaintenanceBtn" class="secondary-btn">Reset
                All</button> </div>
          </div>
        </div>
      </div>
      <div class="panel">
        <h2 class="help-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
          Help Guide ▼ </h2>
        <div id="helpContent" style="display: none; text-align: left; padding: 10px;">
          <h1>Spin - Motorcycle Companion</h1>
          <h2>Purpose:</h2>
          Comprehensive motorcycle-focused GPS navigation with advanced ride
          metrics, emergency features, maintenance tracking, and engine sound
          analysis. The spinning wheel in the header rotates to reflect your
          current speed, spinning faster as you ride faster.
          <h2>🚀 Navigation Tab</h2>
          <strong>GPS Navigation:</strong> Lock your position and navigate back
          with audio cues.<br>
          <strong>Calibrate Sensors:</strong> Place phone on bike in riding
          position and tap to set baseline for lean angle and crash detection.<br>
          <strong>Auto-Lock Mode:</strong> Automatically locks position when
          motorcycle is stationary.<br>
          <strong>Direction Indicator:</strong> Visual compass pointing to
          locked position.<br>
          <strong>Sonar Parameters:</strong> Adjust audio feedback frequency and
          range.<br>
          <strong>Triple-Tap Overlay:</strong> Quickly tap screen 3 times to
          show enlarged speed/lean display. <strong>GPS Navigation:</strong>
          Lock your position and navigate back with audio cues (initially muted
          for safety).<br>
          <strong>Mute Sound:</strong> Toggle audio feedback on/off. Starts
          muted to prevent unexpected sounds.<br>
          <h2>📊 Metrics Tab</h2>
          <strong>Ride Metrics:</strong> Track speed, distance, acceleration,
          and lean angles with real-time updates.<br>
          <strong>Cornering Analysis:</strong> Detects corners using GPS
          curvature and lean angle, calculates cornering G and speeds.<br>
          <strong>Elevation Profile:</strong> Tracks altitude changes using GPS
          data with live chart.<br>
          <strong>Lean Angle Indicator:</strong> Visual display of motorcycle
          lean during corners.<br>
          <strong>Distance Statistics:</strong> Daily, weekly, monthly, and
          total distance tracking.<br>
          <strong>Acceleration Timer:</strong> Measures 0-100 km/h
          (customizable) acceleration.<br>
          <h3>🎵 Engine Sound Analysis</h3>
          <strong>Real-time RPM Monitoring:</strong> Uses microphone to detect
          engine RPM from sound.<br>
          <strong>Gear Position Estimation:</strong> Automatically estimates
          current gear based on speed/RPM ratio.<br>
          <strong>Engine Health Monitoring:</strong> Detects engine knock,
          exhaust leaks, and unusual vibrations.<br>
          <strong>Gear Shift Detection:</strong> Tracks shift patterns and
          quality.<br>
          <strong>Impulse Response Calibration:</strong> Record your engine
          sound for precise RPM calibration.<br>
          <strong>Sound Spectrum Visualization:</strong> Real-time frequency
          display.
          <h3>💾 Session Management</h3>
          <strong>Start Session:</strong> Begin recording a new ride with
          auto-save every 30 seconds.<br>
          <strong>Save Session:</strong> Save ride with custom name and notes.<br>
          <strong>Quick Save:</strong> Instant save without prompts.<br>
          <strong>Export Session:</strong> Download ride data as JSON file.<br>
          <strong>Session History:</strong> Browse and manage all past rides.
          <h2>🚨 Emergency Tab</h2>
          <strong>Emergency Alert:</strong> Send your location to emergency
          contacts manually.<br>
          <strong>Crash Detection:</strong> Automatically sends location to
          contacts if bike is detected lying flat for 5 seconds.<br>
          <strong>Quick Contacts:</strong> Pre-set emergency contacts for quick
          access with call/message buttons.<br>
          <strong>Custom Message:</strong> Edit the emergency message with your
          details.<br>
          <strong>Emergency Call:</strong> Direct access to 112/911 emergency
          services.
          <h2>🔧 Maintenance Tab</h2>
          <strong>Maintenance Alerts:</strong> Track service intervals based on
          mileage.<br>
          <strong>Progress Indicators:</strong> Visual progress bars for each
          maintenance item.<br>
          <strong>Custom Items:</strong> Add your own maintenance tasks and
          intervals.<br>
          <strong>Auto Reminders:</strong> Get notified when maintenance is due.
          <h2>🎛️ Advanced Features</h2>
          <strong>Triple-Tap Overlay:</strong> Quick triple-tap anywhere to show
          enlarged stats display.<br>
          <strong>Real-time Wheel Animation:</strong> Header wheel spins
          according to your speed.<br>
          <strong>Comprehensive Data Export:</strong> Export metrics, sessions,
          and maintenance data.<br>
          <strong>Offline Capable:</strong> Works without internet connection
          for basic navigation.<br>
          <strong>Battery Efficient:</strong> Optimized sensors and GPS usage.
          <h2>🚀 Quick Start Guide</h2>
          <ol>
            <li><strong>Initial Setup:</strong>
              <ul>
                <li>Mount phone securely on motorcycle</li>
                <li>Tap "Calibrate Sensors" to set lean angle baseline
                  (Calibration will fail if phone is completely flat).</li>
                <li>Set emergency contacts in Emergency tab</li>
              </ul>
            </li>
            <li><strong>Before Riding:</strong>
              <ul>
                <li>Tap "Test Audio &amp; Lock" to initialize app</li>
                <li>Start Engine Analysis for RPM monitoring</li>
                <li>Record engine sample for accurate RPM calibration</li>
                <li>Start new session to track your ride</li>
              </ul>
            </li>
            <li><strong>During Ride:</strong>
              <ul>
                <li>Use Navigation tab to lock parking position</li>
                <li>Monitor Metrics tab for performance data</li>
                <li>Watch header wheel spin with your speed</li>
                <li>Triple-tap screen for quick stats overlay</li>
              </ul>
            </li>
            <li><strong>After Ride:</strong>
              <ul>
                <li>Save session with notes</li>
                <li>Check maintenance progress</li>
                <li>Export data for analysis</li>
              </ul>
            </li>
          </ol>
          <h2>💡 Pro Tips</h2>
          <strong>For Best Results:</strong>
          <ul>
            <li>Mount phone securely aligned with bike's centerline for accurate
              lean angles</li>
            <li>Calibrate engine sound analysis in a quiet environment</li>
            <li>Set realistic maintenance intervals based on your riding style</li>
            <li>Test emergency features before your first ride</li>
            <li>Use quick save frequently during long rides</li>
            <li>Export session data regularly to backup your rides</li>
          </ul>
          <strong>Safety Features:</strong>
          <ul>
            <li>Crash detection requires proper phone mounting</li>
            <li>Emergency contacts should be set before riding</li>
            <li>Test audio navigation in a safe area first</li>
            <li>Keep phone charged during long rides</li>
          </ul>
          <strong>Performance Tracking:</strong>
          <ul>
            <li>Monitor cornering G-forces to improve technique</li>
            <li>Track acceleration times for performance tuning</li>
            <li>Use elevation data for route planning</li>
            <li>Analyze gear shift patterns for smoother riding</li>
          </ul>
          <h2>🔧 Troubleshooting</h2>
          <strong>Common Issues:</strong>
          <ul>
            <li><em>No GPS signal:</em> Ensure location services are enabled</li>
            <li><em>No engine sound detection:</em> Allow microphone access and
              start engine analysis</li>
            <li><em>Inaccurate lean angles:</em> Recalibrate sensors with phone
              properly mounted</li>
            <li><em>Audio not working:</em> Check phone volume and app
              permissions</li>
            <li><em>Crash detection false positives:</em> Adjust phone mounting
              position</li>
          </ul>
          <strong>Support:</strong>
          <ul>
            <li>Ensure latest browser version for best performance</li>
            <li>Grant all requested permissions for full functionality</li>
            <li>Use in landscape mode for better dashboard visibility</li>
            eleveation
            <li>Keep app updated for new features and bug fixes</li>
          </ul>
          <strong>Created:</strong>
          <ul>
            <li>For ihearcolors.online</li>
            <li>By Dimitris Barnias 2025</li>
            <li>If you like this app, <strong>please support</strong> by buying
              me a cup of coffee (or two..) </li>
            <li>Any donation is welcome: PayPall newtones@icloud.com</li>
            <li><strong>Report</strong> any bugs or possible features at:
              dbarnias@gmail.com</li>
          </ul>
          <div style="background: rgba(255,102,0,0.1); padding: 10px; border-radius: 5px; margin-top: 15px; border-left: 3px solid var(--primary-color);">
            <strong>🎯 Remember:</strong> Spin is designed to enhance your
            riding experience, not replace safe riding practices. Always ride
            responsibly and within your limits. </div>
        </div>
      </div>
      <div id="debug"></div>
      <!-- Leaflet JS -->
      <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
      <script>
const MotoFindBack = {
  maintenanceItems: [], 
  audioCtx: null,
  watchId: null,
  bleepTimer: null,
  lockPosition: null,
  lastUpdateTime: Date.now(),
  lastBleedTime: 0,
  isAudioAllowed: false,
  isActive: false,
  isRideActive: false,
  movementHistory: [],
  currentTempo: 1000,
  emergencyEnabled: true,
  autoLockEnabled: false,
  loadPreviousSessions: true,
  showSessionPrompt: true,
  autoLockDebounce: null,
  currentSpeed: 0,
  reachedPointDisplayed: false,
  isMuted: true, 
  isStationary: false,
  lastStationaryTime: null,
  lastStationaryPosition: null,
  speedThreshold: 10,
  maxSpeed: 0,
  totalDistance: 0,
  todayDistance: 0,
  weekDistance: 0,
  monthDistance: 0,
  elevationGain: 0,
  rideStartTime: null,
  accelerationStartTime: null,
  accelerationStartSpeed: 0,
  accelerationTimes: [],
  maxLeanAngle: 0,
  currentLeanAngle: 0,
  currentCornerG: 0,
  maxCornerG: 0,
  maxCornerSpeed: 0,
  corners: [],
  cornerEntrySpeeds: [],
  cornerExitSpeeds: [],
  emergencyContacts: [],
  rideHistory: [],
  isCalibrating: false,
  calibrationSamples: [],
  leanOffset: 0,
  crashDetected: false,
  crashStartTime: null,
  lastPosition: null,
  prevPosition: null,
  rotationSpeed: 0,
  map: null,
  userMarker: null,
  lockMarker: null,
  line: null,
  accelTarget: 100,
  elevationHistory: [],
  canvas: null,
  cornerChart: null,
  tripleTapCount: 0,
  tripleTapTimeout: null,
  lastTapTime: 0,
  isOverlayVisible: false,
  
  accelerationPopup: {
    visible: false,
    achievedTime: null,
    startTime: null,
    element: null
  },

  // Session data structure
  sessionTemplate: {
    id: null,
    name: '',
    startTime: null,
    endTime: null,
    duration: 0,
    distance: 0,
    maxSpeed: 0,
    avgSpeed: 0,
    elevationGain: 0,
    corners: 0,
    hardBrakingEvents: 0,
    aggressiveCorners: 0,
    routeData: [],
    metrics: {
      accelerationTimes: [],
      leanAngles: [],
      corneringData: [],
      elevationData: []
    },
    weather: '',
    notes: ''
  },
  sessionHistory: [],
  currentSession: null,
  autoSaveInterval: null,

  audioAnalysis: {
    audioContext: null,
    analyser: null,
    microphone: null,
    javascriptNode: null,
    isListening: false,
    engineRPM: 0,
    gearPosition: 0,
    engineHealth: 'Good',
    soundProfile: null,
    lastShiftTime: 0,
    maxDb: 0,
    frequencyData: new Uint8Array(1024),
    
   
    calibration: {
      isCalibrated: false,
      recordedSample: null,
      referenceFrequency: 0,
      referenceRPM: 0,
      frequencyResponse: [],
      volumeThreshold: 20,
      minRPM: 800,
      maxRPM: 16000,
      bikeProfile: {
        name: 'Uncalibrated',
        type: 'unknown',
        redline: 12000,
        idleRPM: 1200
      }
    }, 
    
    recording: {
      isRecording: false,
      recordingBuffer: [],
      recordingStartTime: 0,
      sampleDuration: 3000,
      analysisBuffer: null
    }  
    
  },
 
init: async function() {
  // Setup event listeners FIRST
  this.setupEventListeners();
 this.loadCalibrationFromStorage();
   this.updateCalibrationDisplay();
  // Load data BEFORE any processing
  await this.loadSessionsFromStorage();
  await this.loadUserPreferences();
  
  console.log('After loading - Sessions:', this.sessionHistory.length, 'Show prompt:', this.showSessionPrompt);
  
  // TEMPORARY: Force show prompt (AFTER preferences are loaded)
  console.log('=== TEMPORARY OVERRIDE: Forcing session prompt ===');
  this.showSessionPrompt = true;
  
  console.log('After override - Sessions:', this.sessionHistory.length, 'Show prompt:', this.showSessionPrompt);
  
  // Initialize core components
  this.initMap();
  this.loadContactsFromStorage();
  this.setupTripleTapDetection();
  this.loadCalibrationFromStorage();
  
  // Auto-start session when ride starts
  const originalStartRide = this.startRide;
  this.startRide = function() {
    if (!this.currentSession) {
      this.startNewSession();
    }
    return originalStartRide.apply(this, arguments);
  }.bind(this);
  
  // Auto-update session display
  setInterval(() => {
    this.updateSessionDisplay();
  }, 1000);
  
  // Initialize charts and UI components
  this.canvas = document.getElementById('elevationCanvas');
  if (!this.canvas) {
    this.log("Error: elevationCanvas element not found", true);
    return;
  }
  
  this.cornerChart = new Chart(document.getElementById('cornerChart').getContext('2d'), {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Corner G-Force',
        data: [],
        borderColor: '#00ccff',
        backgroundColor: 'rgba(0, 204, 255, 0.2)',
        fill: true,
        tension: 0.4
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: { beginAtZero: true, title: { display: true, text: 'G-Force (g)' } },
        x: { title: { display: true, text: 'Corner Number' } }
      }
    }
  });
  
  // Setup UI components 
  this.setupTabs();
  this.setupCollapsibles();
  this.loadData();
  this.updateUI();
  
  // Initialize acceleration popup
  this.setupAccelerationPopup();
  
  this.log("MotoFindBack initialized");
  this.initDeviceOrientation();

  // Session prompt check (SINGLE CHECK - removed duplicates)
  if (this.showSessionPrompt && this.sessionHistory.length > 0) {
    console.log('✅ Showing session load prompt');
    setTimeout(() => {
      this.showSessionLoadPrompt();
    }, 2000);
  } else {
    console.log('Not showing session prompt - conditions not met');
  }

  // Service worker registration
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').then(reg => {
      this.log('Service Worker registered');
    }).catch(err => {
      this.log('Service Worker registration failed: ' + err, true);
    });
  }

},  

  
  // Simple lock that doesn't depend on audio
forceLockPosition: function() {
  if (!this.lastPosition) {
    alert("Wait for GPS signal first (blue dot on map)");
    return;
  }
  
  this.lockPosition = { 
    lat: this.lastPosition.lat, 
    lon: this.lastPosition.lon 
  };
  
  // Update UI
  document.getElementById("lockStatus").textContent = 
    `Lock Status: LOCKED at ${this.lockPosition.lat.toFixed(6)}, ${this.lockPosition.lon.toFixed(6)}`;
  document.getElementById("lockStatus").className = "status success";
  
  this.isActive = true;
  
  alert(`✅ Position locked! You will get directional guidance.`);
  
  // Start audio if possible
  this.startBleep();
},
                                                            
loadUserPreferences: function() {
  const prefs = localStorage.getItem('motoFindBack_preferences');
  console.log('User preferences:', prefs);
  
  if (prefs) {
    try {
      const preferences = JSON.parse(prefs);
      this.loadPreviousSessions = preferences.loadPreviousSessions !== undefined ? preferences.loadPreviousSessions : true;
      this.showSessionPrompt = preferences.showSessionPrompt !== undefined ? preferences.showSessionPrompt : true;
      
      console.log('Loaded preferences:', {
        loadPreviousSessions: this.loadPreviousSessions,
        showSessionPrompt: this.showSessionPrompt
      });
    } catch (error) {
      console.error('Error loading preferences:', error);
      // Set defaults
      this.loadPreviousSessions = true;
      this.showSessionPrompt = true;
    }
  } else {
    console.log('No preferences found, using defaults');
    this.loadPreviousSessions = true;
    this.showSessionPrompt = true;
  }
},

saveUserPreferences: function() {
  const preferences = {
    loadPreviousSessions: this.loadPreviousSessions,
    showSessionPrompt: this.showSessionPrompt
  };
  localStorage.setItem('motoFindBack_preferences', JSON.stringify(preferences));
  
},

  showSessionLoadPrompt: function() {
  // Check if modal already exists
  if (document.getElementById('sessionLoadModal')) {
    return;
  }
  
  const modal = document.createElement('div');
  modal.id = 'sessionLoadModal';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
  `;
  
  modal.innerHTML = `
    <div style="background: #333; padding: 20px; border-radius: 10px; width: 90%; max-width: 400px; border: 2px solid var(--primary-color);">
      <h3>Load Previous Sessions?</h3>
      <p style="color: #ccc; margin: 15px 0;">Found ${this.sessionHistory.length} saved ride sessions. Load them now?</p>
 <p style="color: #ccc; margin: 15px 0;">Hint: Triple Click -> Change Simpler UI</p>
      
      
      <div style="margin: 15px 0;">
        <label style="color: #ccc; display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="dontAskAgain">
          Don't ask me again
        </label>
      </div>
      
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="loadSessionsYes" class="primary-btn" style="flex: 1;">Yes, Load</button>
        <button id="loadSessionsNo" class="secondary-btn" style="flex: 1;">No, Start Fresh</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Add event listeners
  document.getElementById('loadSessionsYes').addEventListener('click', () => {
    this.loadSessionsChoice(true);
  });
  
  document.getElementById('loadSessionsNo').addEventListener('click', () => {
    this.loadSessionsChoice(false);
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      this.loadSessionsChoice(false);
    }
  });
},
  
  resetSessionPrompt: function() {
  this.showSessionPrompt = true;
  this.saveUserPreferences();
  this.log('Session prompt preference reset to true');
  this.showAlertNotification('Session prompts have been re-enabled!', 'success');
  
  // Optional: Show the prompt immediately
  setTimeout(() => {
    if (this.sessionHistory.length > 0) {
      this.showSessionLoadPrompt();
    }
  }, 1000);
},
  
loadSessionsChoice: function(loadSessions) {
  console.log('=== loadSessionsChoice called ===', { loadSessions });
  
  this.loadPreviousSessions = loadSessions;
  
  const dontAskAgain = document.getElementById('dontAskAgain');
  console.log('DontAskAgain checkbox:', dontAskAgain, 'Checked:', dontAskAgain?.checked);
  
  if (dontAskAgain && dontAskAgain.checked) {
    this.showSessionPrompt = false;
    console.log('User chose: Don\'t ask again');
  }
  
  this.saveUserPreferences();
  
  if (!loadSessions) {
    this.sessionHistory = [];
    this.saveSessionsToStorage();
    console.log('Cleared session history');
  }
  
  // Remove modal
  const modal = document.getElementById('sessionLoadModal');
  console.log('Modal to remove:', modal);
  
  if (modal) {
    document.body.removeChild(modal);
    console.log('✅ Modal removed successfully');
  } else {
    console.log('❌ Modal not found for removal');
  }
  
  this.updateSessionHistoryDisplay();
  this.updateGeneralStatistics();
  console.log('Session choice completed');
},
              
              // Add this temporary method to test CSS
testButtonClickability: function() {
  setTimeout(() => {
    const yesBtn = document.getElementById('loadSessionsYes');
    const noBtn = document.getElementById('loadSessionsNo');
    
    if (yesBtn) {
      console.log('YES button styles:', {
        display: yesBtn.style.display,
        visibility: yesBtn.style.visibility,
        pointerEvents: yesBtn.style.pointerEvents,
        opacity: yesBtn.style.opacity,
        position: yesBtn.style.position,
        zIndex: yesBtn.style.zIndex
      });
      
      // Temporarily add visible border to see button area
      yesBtn.style.border = '2px solid red';
      noBtn.style.border = '2px solid blue';
    }
  }, 100);
},
              
              // Acceleration popup methods
setupAccelerationPopup: function() {
  // Create the popup element
  this.accelerationPopup.element = document.createElement('div');
  this.accelerationPopup.element.id = 'accelerationPopup';
  this.accelerationPopup.element.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #ff6600, #ff3300);
    color: white;
    padding: 25px 30px;
    border-radius: 15px;
    border: 3px solid #fff;
    box-shadow: 0 8px 25px rgba(255, 102, 0, 0.4);
    z-index: 9999;
    text-align: center;
    font-family: Arial, sans-serif;
    cursor: pointer;
    display: none;
    min-width: 200px;
    backdrop-filter: blur(10px);
  `;
  
  this.accelerationPopup.element.innerHTML = `
    <div style="margin-bottom: 15px;">
      <div style="font-size: 1.8em; font-weight: bold; margin-bottom: 5px;">🎯</div>
      <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 8px;">ACCELERATION ACHIEVED!</div>
    </div>
    <div id="accelerationPopupContent" style="font-size: 1.3em; font-weight: bold;">
      Calculating...
    </div>
    <div style="margin-top: 12px; font-size: 0.8em; opacity: 0.9;">
      Click to clear
    </div>
  `;
  
  // Add click to clear
  this.accelerationPopup.element.addEventListener('click', () => {
    this.hideAccelerationPopup();
  });
  
  document.body.appendChild(this.accelerationPopup.element);
},

showAccelerationPopup: function(time, targetSpeed) {
  if (!this.accelerationPopup.element) {
    this.setupAccelerationPopup();
  }
  
  const content = `
    <div style="margin-bottom: 8px;">0-${targetSpeed} km/h</div>
    <div style="font-size: 1.8em;">${time.toFixed(2)}s</div>
  `;
  
  document.getElementById('accelerationPopupContent').innerHTML = content;
  this.accelerationPopup.element.style.display = 'block';
  this.accelerationPopup.visible = true;
  this.accelerationPopup.achievedTime = Date.now();
  
  // Auto-hide after 10 seconds
  setTimeout(() => {
    if (this.accelerationPopup.visible) {
      this.hideAccelerationPopup();
    }
  }, 10000);
},

hideAccelerationPopup: function() {
  if (this.accelerationPopup.element) {
    this.accelerationPopup.element.style.display = 'none';
    this.accelerationPopup.visible = false;
    this.accelerationPopup.achievedTime = null;
    this.accelerationPopup.startTime = null;
  }
},

checkAccelerationAchievement: function() {
  const currentSpeedKmh = this.currentSpeed * 3.6;
  const targetSpeed = this.accelTarget; // User-defined target
  
  // Start timing if we're below target and not already timing
  if (currentSpeedKmh < targetSpeed && !this.accelerationPopup.startTime && !this.accelerationPopup.achievedTime) {
    this.accelerationPopup.startTime = Date.now();
    this.log(`Starting acceleration timer for 0-${targetSpeed} km/h`);
  }
  
  // Check if we reached the target speed
  if (this.accelerationPopup.startTime && 
      !this.accelerationPopup.achievedTime && 
      currentSpeedKmh >= targetSpeed) {
    
    const accelerationTime = (Date.now() - this.accelerationPopup.startTime) / 1000;
    
    // Only show popup if this is a meaningful acceleration (at least 0.5 seconds)
    if (accelerationTime >= 0.5) {
      this.accelerationTimes.push(accelerationTime);
      this.log(`🎯 Acceleration achieved: 0-${targetSpeed} km/h in ${accelerationTime.toFixed(2)}s`);
      
      // Show the popup
      this.showAccelerationPopup(accelerationTime, targetSpeed);
      
      // Update UI
      this.updateUI();
    }
    
    this.accelerationPopup.achievedTime = Date.now();
  }
  
  // Reset if speed drops significantly below target (like after braking)
  if (this.accelerationPopup.startTime && currentSpeedKmh < (targetSpeed * 0.3)) {
    this.accelerationPopup.startTime = null;
    this.accelerationPopup.achievedTime = null;
  }
},

// Test method
testAccelerationPopup: function() {
  const testTime = 4.27;
  this.showAccelerationPopup(testTime, this.accelTarget);
  this.log('Test acceleration popup shown');
},
              
    
    // Microphone initialization

initMicrophone: function() {
  return new Promise((resolve, reject) => {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      this.log('Microphone access not available');
      reject('Microphone not supported');
      return;
    }

    // Request microphone permission first
    navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        channelCount: 1,
        sampleRate: 44100
      } 
    }).then(stream => {
      this.audioAnalysis.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.audioAnalysis.analyser = this.audioAnalysis.audioContext.createAnalyser();
      this.audioAnalysis.microphone = this.audioAnalysis.audioContext.createMediaStreamSource(stream);
      
      this.audioAnalysis.analyser.fftSize = 2048;
      this.audioAnalysis.analyser.smoothingTimeConstant = 0.6;
      this.audioAnalysis.analyser.minDecibels = -90;
      this.audioAnalysis.analyser.maxDecibels = -10;
      
      this.audioAnalysis.microphone.connect(this.audioAnalysis.analyser);
      
      this.audioAnalysis.javascriptNode = this.audioAnalysis.audioContext.createScriptProcessor(2048, 1, 1);
      this.audioAnalysis.analyser.connect(this.audioAnalysis.javascriptNode);
      this.audioAnalysis.javascriptNode.connect(this.audioAnalysis.audioContext.destination);
      
      this.audioAnalysis.javascriptNode.onaudioprocess = () => {
        if (this.audioAnalysis.isListening) {
          this.analyzeEngineSound();
        }
      };
      
      this.audioAnalysis.isListening = true;
      this.log('Microphone initialized for engine analysis');
      
      // Start visualization
      this.startFrequencyVisualization();
      resolve();
    }).catch(error => {
      this.log('Microphone access denied: ' + error.message, true);
      reject(error);
    });
  });
},

// Engine sound analysis
// Modify analyzeEngineSound to handle recording
analyzeEngineSound: function() {
  if (!this.audioAnalysis.analyser || !this.audioAnalysis.isListening) return;
  
  try {
    this.audioAnalysis.analyser.getByteFrequencyData(this.audioAnalysis.frequencyData);
    
    const hasData = this.audioAnalysis.frequencyData.some(val => val > 0);
    if (!hasData) return;
    
    const dominantFreq = this.findDominantFrequency();
    this.audioAnalysis.engineRPM = this.frequencyToRPM(dominantFreq);
    
    // Store sample if recording
    if (this.audioAnalysis.recording.isRecording) {
      this.audioAnalysis.recording.recordingBuffer.push({
        timestamp: Date.now(),
        dominantFreq: dominantFreq,
        maxDb: this.audioAnalysis.maxDb,
        frequencyData: new Uint8Array(this.audioAnalysis.frequencyData) // Copy array
      });
    }
    
    // Only process if above threshold
 
if (this.audioAnalysis.maxDb > this.audioAnalysis.calibration.volumeThreshold) {
      this.analyzeEngineHealth();
      this.detectGearShifts();
      this.estimateGearPosition();
      this.detectEngineProblems();
      this.updateEngineDisplay();
      this.updateFrequencyVisualization();
    }
    
  } catch (error) {
    console.error("Error in engine sound analysis:", error);
  }
},

// Better frequency detection
findDominantFrequency: function() {
  let maxVolume = 0;
  let dominantFreq = 0;
  let totalEnergy = 0;
  
  // Skip very low frequencies (below 50Hz) which are often noise
  const minBin = Math.floor(50 * this.audioAnalysis.frequencyData.length / (this.audioAnalysis.audioContext.sampleRate / 2));
  
  for (let i = minBin; i < this.audioAnalysis.frequencyData.length; i++) {
    const volume = this.audioAnalysis.frequencyData[i];
    totalEnergy += volume;
    
    if (volume > maxVolume) {
      maxVolume = volume;
      dominantFreq = i * (this.audioAnalysis.audioContext.sampleRate / 2) / this.audioAnalysis.frequencyData.length;
    }
  }
  
  this.audioAnalysis.maxDb = maxVolume;
  this.audioAnalysis.totalEnergy = totalEnergy;
  
  return dominantFreq;
},
  
  // Add frequency visualization to see what's being detected
startFrequencyVisualization: function() {
  this.frequencyCanvas = document.getElementById('frequencyCanvas');
  if (!this.frequencyCanvas) return;
  
  this.frequencyCtx = this.frequencyCanvas.getContext('2d');
  this.frequencyCanvas.width = this.frequencyCanvas.offsetWidth;
  this.frequencyCanvas.height = 100;
},

updateFrequencyVisualization: function() {
  if (!this.frequencyCtx || !this.audioAnalysis.frequencyData) return;
  
  const width = this.frequencyCanvas.width;
  const height = this.frequencyCanvas.height;
  const bufferLength = this.audioAnalysis.frequencyData.length;
  
  // White background
  this.frequencyCtx.fillStyle = 'rgb(255, 255, 255)';
  this.frequencyCtx.fillRect(0, 0, width, height);
  
  // Draw smooth orange waveform
  this.frequencyCtx.lineWidth = 2;
  this.frequencyCtx.strokeStyle = 'rgb(255, 100, 0)';
  this.frequencyCtx.beginPath();
  
  const sliceWidth = width / bufferLength;
  let x = 0;
  
  for (let i = 0; i < bufferLength; i++) {
    const v = this.audioAnalysis.frequencyData[i] / 255;
    const y = height - (v * height);
    
    if (i === 0) {
      this.frequencyCtx.moveTo(x, y);
    } else {
      this.frequencyCtx.lineTo(x, y);
    }
    
    x += sliceWidth;
  }
  
  this.frequencyCtx.stroke();
  
  // Fill under the waveform with orange gradient
  this.frequencyCtx.lineTo(width, height);
  this.frequencyCtx.lineTo(0, height);
  this.frequencyCtx.closePath();
  
  const fillGradient = this.frequencyCtx.createLinearGradient(0, 0, 0, height);
  fillGradient.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
  fillGradient.addColorStop(1, 'rgba(255, 150, 0, 0.2)');
  
  this.frequencyCtx.fillStyle = fillGradient;
  this.frequencyCtx.fill();
},

frequencyToRPM: function(frequency) {
  // This is a simplified conversion - would need calibration for specific bikes
  // Typical motorcycle engines: 1000-12000 RPM
  // 2-stroke: firing every revolution, 4-stroke: every other revolution
  const isFourStroke = true; // Assume 4-stroke for most bikes
  const cylinders = 2; // Assume 2 cylinders for calibration
  
  if (isFourStroke) {
    return (frequency * 60 * 2) / cylinders;
  } else {
    return (frequency * 60) / cylinders;
  }
},
  


// Engine health monitoring
analyzeEngineHealth: function() {
  const frequencies = Array.from(this.audioAnalysis.frequencyData);
  
  // Check for unusual vibrations/patterns
  const unusualHarmonics = this.detectUnusualHarmonics(frequencies);
  const engineKnock = this.detectEngineKnock(frequencies);
  const exhaustLeak = this.detectExhaustLeak(frequencies);
  
  if (engineKnock.detected) {
    this.audioAnalysis.engineHealth = 'Knocking Detected';
    this.log(`🚨 Engine knock detected: ${engineKnock.severity}`);
    this.triggerMaintenanceAlert('Engine knock detected - check oil and fuel quality');
  } else if (exhaustLeak.detected) {
    this.audioAnalysis.engineHealth = 'Possible Exhaust Leak';
    this.log(`⚠️ Possible exhaust leak detected`);
  } else if (unusualHarmonics) {
    this.audioAnalysis.engineHealth = 'Unusual Vibrations';
  } else {
    this.audioAnalysis.engineHealth = 'Normal';
  }
},

detectUnusualHarmonics: function(frequencies) {
  // Look for unexpected harmonic patterns that might indicate issues
  const fundamental = this.findDominantFrequency();
  const expectedHarmonics = [fundamental * 2, fundamental * 3, fundamental * 4];
  
  let unusualCount = 0;
  expectedHarmonics.forEach(harmonic => {
    const bin = Math.floor(harmonic * this.audioAnalysis.frequencyData.length / (this.audioAnalysis.audioContext.sampleRate / 2));
    if (frequencies[bin] > frequencies[Math.floor(fundamental)] * 0.8) {
      unusualCount++;
    }
  });
  
  return unusualCount > 1;
},

detectEngineKnock: function(frequencies) {
  // Engine knock typically appears as high-frequency spikes
  const highFreqStart = Math.floor(this.audioAnalysis.frequencyData.length * 0.7);
  let highFreqEnergy = 0;
  
  for (let i = highFreqStart; i < this.audioAnalysis.frequencyData.length; i++) {
    highFreqEnergy += frequencies[i];
  }
  
  const avgHighFreq = highFreqEnergy / (this.audioAnalysis.frequencyData.length - highFreqStart);
  const fundamentalEnergy = frequencies[this.findDominantFrequency()];
  
  return {
    detected: avgHighFreq > fundamentalEnergy * 0.3,
    severity: avgHighFreq / fundamentalEnergy
  };
},

detectExhaustLeak: function(frequencies) {
  // Exhaust leaks often create broadband noise
  let totalEnergy = 0;
  let peakEnergy = 0;
  
  for (let i = 0; i < frequencies.length; i++) {
    totalEnergy += frequencies[i];
    if (frequencies[i] > peakEnergy) peakEnergy = frequencies[i];
  }
  
  const avgEnergy = totalEnergy / frequencies.length;
  const broadbandRatio = avgEnergy / peakEnergy;
  
  return {
    detected: broadbandRatio > 0.4,
    ratio: broadbandRatio
  };
},

// Gear shift detection
detectGearShifts: function() {
  const currentTime = Date.now();
  const rpm = this.audioAnalysis.engineRPM;
  
  // Detect rapid RPM drop followed by stabilization (gear shift)
  if (this.lastRPM && rpm < this.lastRPM * 0.6 && currentTime - this.audioAnalysis.lastShiftTime > 2000) {
    // Possible gear shift detected
    this.audioAnalysis.lastShiftTime = currentTime;
    this.gearShiftEvents = this.gearShiftEvents || [];
    this.gearShiftEvents.push({
      time: currentTime,
      fromRPM: this.lastRPM,
      toRPM: rpm,
      speed: this.currentSpeed * 3.6
    });
    
    this.log(`⬆️ Gear shift detected at ${this.currentSpeed * 3.6} km/h`);
    this.analyzeShiftQuality(this.lastRPM, rpm);
  }
  
  this.lastRPM = rpm;
},

analyzeShiftQuality: function(fromRPM, toRPM) {
  const rpmDropRatio = toRPM / fromRPM;
  let shiftQuality = 'Good';
  
  if (rpmDropRatio < 0.4) shiftQuality = 'Hard';
  if (rpmDropRatio > 0.7) shiftQuality = 'Soft';
  if (Math.abs(fromRPM - toRPM) < 500) shiftQuality = 'Clutch Slipping';
  
  this.log(`Shift quality: ${shiftQuality} (${fromRPM.toFixed(0)} → ${toRPM.toFixed(0)} RPM)`);
},

estimateGearPosition: function() {
  if (this.currentSpeed === 0 || this.audioAnalysis.engineRPM === 0) {
    this.audioAnalysis.gearPosition = 0; // Neutral or stopped
    return;
  }
  
  // Simplified gear estimation based on speed/RPM ratio
  const ratio = (this.currentSpeed * 3.6) / this.audioAnalysis.engineRPM;
  
  if (ratio < 0.02) this.audioAnalysis.gearPosition = 1;
  else if (ratio < 0.035) this.audioAnalysis.gearPosition = 2;
  else if (ratio < 0.05) this.audioAnalysis.gearPosition = 3;
  else if (ratio < 0.065) this.audioAnalysis.gearPosition = 4;
  else if (ratio < 0.08) this.audioAnalysis.gearPosition = 5;
  else this.audioAnalysis.gearPosition = 6;
},

// Engine problem detection
detectEngineProblems: function() {
  const currentTime = Date.now();
  
  // Misfire detection (irregular engine sound)
  const regularity = this.analyzeEngineRegularity();
  if (regularity < 0.7) {
    this.log('⚠️ Possible engine misfire detected');
  }
  
  // Over-revving protection
  if (this.audioAnalysis.engineRPM > 10000 && this.currentSpeed > 0) {
    this.log('🚨 Engine over-revving detected!');
    this.triggerOverRevAlert();
  }
  
  // Lugging detection (too low RPM for speed)
  if (this.audioAnalysis.engineRPM < 2000 && this.currentSpeed > 30) {
    this.log('⚠️ Engine lugging detected - downshift recommended');
  }
},

analyzeEngineRegularity: function() {
  // Analyze how regular the engine pulses are
  const recentRPMS = this.rpmHistory || [];
  recentRPMS.push(this.audioAnalysis.engineRPM);
  
  if (recentRPMS.length > 50) recentRPMS.shift();
  this.rpmHistory = recentRPMS;
  
  if (recentRPMS.length < 10) return 1.0;
  
  // Calculate coefficient of variation
  const mean = recentRPMS.reduce((a, b) => a + b) / recentRPMS.length;
  const variance = recentRPMS.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recentRPMS.length;
  const stdDev = Math.sqrt(variance);
  const cv = stdDev / mean;
  
  return Math.max(0, 1 - cv);
},
  
  startEngineAnalysis: function() {
  this.initMicrophone().then(() => {
    document.getElementById("startEngineAnalysis").textContent = "Analysis Running";
    document.getElementById("startEngineAnalysis").style.background = "linear-gradient(to bottom, #00cc66, #00aa55)";
    this.log("Engine sound analysis started");
  }).catch(error => {
    this.log("Failed to start engine analysis: " + error, true);
    alert("Please allow microphone access to analyze engine sounds");
  });
},

stopEngineAnalysis: function() {
  if (this.audioAnalysis.javascriptNode) {
    this.audioAnalysis.javascriptNode.disconnect();
    this.audioAnalysis.javascriptNode = null;
  }
  if (this.audioAnalysis.microphone) {
    this.audioAnalysis.microphone.disconnect();
    this.audioAnalysis.microphone = null;
  }
  if (this.audioAnalysis.audioContext) {
    this.audioAnalysis.audioContext.close();
    this.audioAnalysis.audioContext = null;
  }
  
  this.audioAnalysis.isListening = false;
  document.getElementById("startEngineAnalysis").textContent = "Start Engine Analysis";
  document.getElementById("startEngineAnalysis").style.background = "";
  this.log("Engine sound analysis stopped");
},
  

// Enhanced recording with better feedback
startRecordingCalibration: function() {
  if (!this.audioAnalysis.isListening) {
    alert('Please start engine analysis first');
    return;
  }

  this.audioAnalysis.recording.isRecording = true;
  this.audioAnalysis.recording.recordingBuffer = [];
  this.audioAnalysis.recording.recordingStartTime = Date.now();
  
  // Reset volume threshold for calibration
  this.audioAnalysis.calibration.volumeThreshold = 10; // Lower threshold for calibration
  
  document.getElementById('calibrationStatus').textContent = '🎤 Recording... Rev engine steadily (3 seconds)';
  document.getElementById('calibrationStatus').style.color = 'var(--warning-color)';
  document.getElementById('startRecordingBtn').textContent = 'Recording...';
  document.getElementById('startRecordingBtn').style.background = 'linear-gradient(to bottom, #ff3333, #cc0000)';
  
  console.log('=== CALIBRATION RECORDING STARTED ===');
  
  // Show real-time feedback during recording
  let feedbackCount = 0;
  const feedbackInterval = setInterval(() => {
    if (!this.audioAnalysis.recording.isRecording) {
      clearInterval(feedbackInterval);
      return;
    }
    
    const currentFreq = this.findDominantFrequency();
    const currentDb = this.audioAnalysis.maxDb;
    
    document.getElementById('calibrationStatus').textContent = 
      `🎤 Recording... Freq: ${currentFreq.toFixed(1)}Hz, Vol: ${currentDb}dB (${feedbackCount + 1}/3)`;
    
    feedbackCount++;
  }, 1000);

  // Set timeout to stop recording automatically
  setTimeout(() => {
    if (this.audioAnalysis.recording.isRecording) {
      console.log('=== CALIBRATION RECORDING COMPLETED ===');
      console.log('Samples recorded:', this.audioAnalysis.recording.recordingBuffer.length);
      this.stopRecordingCalibration();
    }
    clearInterval(feedbackInterval);
  }, this.audioAnalysis.recording.sampleDuration);
},

stopRecordingCalibration: function() {
  if (!this.audioAnalysis.recording.isRecording) return;
  
  this.audioAnalysis.recording.isRecording = false;
  
  // Process the recorded sample
  this.processRecordedSample();
  
  document.getElementById('startRecordingBtn').textContent = 'Record Engine Sample';
  document.getElementById('startRecordingBtn').style.background = '';
  this.log('Stopped recording calibration sample');
},
  
processRecordedSample: function() {
  if (this.audioAnalysis.recording.recordingBuffer.length === 0) {
    this.log('No recording data to process', true);
    return;
  }
  
  document.getElementById('calibrationStatus').textContent = '🔍 Analyzing recording...';
  
  // Analyze the recorded sample
  const analysis = this.analyzeRecordedSample(this.audioAnalysis.recording.recordingBuffer);
  
  if (analysis.success) {
    this.applyCalibrationProfile(analysis);
    document.getElementById('calibrationStatus').textContent = `✅ Calibrated! ${analysis.estimatedRPM.toFixed(0)} RPM detected`;
    document.getElementById('calibrationStatus').style.color = 'var(--success-color)';
    document.getElementById('detectedRange').textContent = `${analysis.idleRPM.toFixed(0)}-${analysis.redlineRPM.toFixed(0)} RPM`;
    
    this.log(`Calibration successful! Engine profile: ${analysis.engineType}, RPM range: ${analysis.idleRPM}-${analysis.redlineRPM}`);
  } else {
    document.getElementById('calibrationStatus').textContent = '❌ Calibration failed - try again';
    document.getElementById('calibrationStatus').style.color = 'var(--error-color)';
    this.log('Calibration failed: ' + analysis.error, true);
  }
},

// Enhanced analyzeRecordedSample with debugging
analyzeRecordedSample: function(recordingBuffer) {
  console.log('=== CALIBRATION DEBUG START ===');
  console.log('Recording buffer length:', recordingBuffer.length);
  
  try {
    const validSamples = recordingBuffer.filter(sample => 
      sample.maxDb > this.audioAnalysis.calibration.volumeThreshold
    );
    
    if (validSamples.length === 0) {
      return {
        success: false,
        error: 'No engine sound detected - rev engine louder'
      };
    }

    const frequencyStats = this.analyzeFrequencyCharacteristics(recordingBuffer);
    const amplitudeStats = this.analyzeAmplitudeCharacteristics(recordingBuffer);

    // Enhanced validation with motorcycle knowledge
    if (frequencyStats.dominantFreq < 30) { // ~1800 RPM minimum
      return {
        success: false,
        error: 'Engine sound too low - rev higher (above 1800 RPM)'
      };
    }
    
    if (frequencyStats.dominantFreq > 266) { // ~16,000 RPM maximum
      return {
        success: false,
        error: 'Unrealistically high RPM detected - check microphone'
      };
    }

    const engineType = this.classifyEngineType(frequencyStats);
    const rpmEstimate = this.estimateRPMFromFrequency(frequencyStats.dominantFreq, engineType);
    
    // Validate against motorcycle reality
    const validatedRPM = this.validateRPMEstimate(rpmEstimate, engineType);
    
    if (!validatedRPM.valid) {
      return {
        success: false,
        error: validatedRPM.reason
      };
    }

    const frequencyResponse = this.buildFrequencyResponse(recordingBuffer);
    
    console.log('=== CALIBRATION DEBUG END - SUCCESS ===');
    
    return {
      success: true,
      dominantFrequency: frequencyStats.dominantFreq,
      estimatedRPM: validatedRPM.rpm,
      engineType: engineType,
      idleRPM: this.calculateIdleRPM(validatedRPM.rpm, engineType),
      redlineRPM: this.calculateRedlineRPM(validatedRPM.rpm, engineType),
      frequencyResponse: frequencyResponse,
      harmonics: frequencyStats.harmonics,
      volumeRange: amplitudeStats
    };
    
  } catch (error) {
    console.error('Calibration error:', error);
    return {
      success: false,
      error: 'Analysis failed: ' + error.message
    };
  }
},

// Enhanced frequency analysis
analyzeFrequencyCharacteristics: function(recordingBuffer) {
  let dominantFreq = 0;
  let maxAmplitude = 0;
  const harmonics = [];
  const allFrequencies = [];

  // Analyze frequency content across all samples
  recordingBuffer.forEach(sample => {
    if (sample.maxDb > this.audioAnalysis.calibration.volumeThreshold) {
      allFrequencies.push(sample.dominantFreq);
      
      if (sample.maxDb > maxAmplitude) {
        maxAmplitude = sample.maxDb;
        dominantFreq = sample.dominantFreq;
      }
      
      // Collect harmonic information for frequencies above 50Hz
      if (sample.dominantFreq > 50) {
        harmonics.push({
          freq: sample.dominantFreq,
          amplitude: sample.maxDb,
          time: sample.timestamp
        });
      }
    }
  });

  console.log('All detected frequencies:', allFrequencies);
  console.log('Dominant frequency:', dominantFreq, 'Amplitude:', maxAmplitude);

  return {
    dominantFreq: dominantFreq,
    maxAmplitude: maxAmplitude,
    harmonics: harmonics,
    frequencyVariance: this.calculateFrequencyVariance(harmonics),
    validSamples: allFrequencies.length
  };
},

analyzeAmplitudeCharacteristics: function(recordingBuffer) {
  const amplitudes = recordingBuffer.map(sample => sample.maxDb);
  const minAmplitude = Math.min(...amplitudes);
  const maxAmplitude = Math.max(...amplitudes);
  const avgAmplitude = amplitudes.reduce((a, b) => a + b) / amplitudes.length;
  
  return {
    min: minAmplitude,
    max: maxAmplitude,
    average: avgAmplitude,
    dynamicRange: maxAmplitude - minAmplitude
  };
},
  
  // Add this method to fix the calibration error
calculateFrequencyVariance: function(harmonics) {
  if (!harmonics || harmonics.length === 0) return 0;
  
  const frequencies = harmonics.map(h => h.freq);
  const mean = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;
  const variance = frequencies.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / frequencies.length;
  
  return variance;
},

classifyEngineType: function(frequencyStats) {
  const dominantFreq = frequencyStats.dominantFreq;
  
  if (dominantFreq < 80) return 'cruiser';
  if (dominantFreq < 150) return 'standard';
  if (dominantFreq < 250) return 'sport';
  return 'high-rev';
},

// Enhanced RPM estimation with motorcycle knowledge
estimateRPMFromFrequency: function(dominantFreq, engineType) {
  // Base RPM estimation with engine type adjustments
  let baseRPM = dominantFreq * 60; // Basic conversion (Hz to RPM)
  
  // Engine type specific multipliers based on real motorcycle data
  const multipliers = {
    'cruiser': 0.7,    // Lower revving
    'standard': 1.0,   // Average
    'sport': 1.3,      // Higher revving
    'high-rev': 1.6    // Very high revving
  };
  
  const multiplier = multipliers[engineType] || 1.0;
  const estimatedRPM = baseRPM * multiplier;
  
  return this.normalizeRPMToMotorcycleRange(estimatedRPM);
},
  
  // Validate RPM estimate against known motorcycle ranges
validateRPMEstimate: function(rpm, engineType) {
  const engineLimits = {
    'cruiser': { min: 800, max: 7000 },
    'standard': { min: 1000, max: 10000 },
    'sport': { min: 1200, max: 14000 },
    'high-rev': { min: 1500, max: 16000 }
  };
  
  const limits = engineLimits[engineType] || { min: 800, max: 16000 };
  
  if (rpm < limits.min) {
    return {
      valid: false,
      reason: `RPM too low for ${engineType} (${rpm.toFixed(0)} < ${limits.min}) - rev higher`
    };
  }
  
  if (rpm > limits.max) {
    return {
      valid: false,
      reason: `RPM too high for ${engineType} (${rpm.toFixed(0)} > ${limits.max}) - unusual engine`
    };
  }
  
  return { valid: true, rpm: rpm };
},

  // Calculate realistic idle RPM based on engine type
calculateIdleRPM: function(calibrationRPM, engineType) {
  const idleRatios = {
    'cruiser': 0.15,    // 15% of calibration RPM
    'standard': 0.18,   // 18% of calibration RPM  
    'sport': 0.20,      // 20% of calibration RPM
    'high-rev': 0.25    // 25% of calibration RPM
  };
  
  const ratio = idleRatios[engineType] || 0.18;
  const calculatedIdle = calibrationRPM * ratio;
  
  // Ensure idle is within motorcycle ranges
  return Math.max(800, Math.min(2000, calculatedIdle));
},

// Calculate realistic redline RPM based on engine type
calculateRedlineRPM: function(calibrationRPM, engineType) {
  const redlineRatios = {
    'cruiser': 1.4,     // 40% above calibration
    'standard': 1.6,    // 60% above calibration
    'sport': 1.8,       // 80% above calibration
    'high-rev': 2.0     // 100% above calibration
  };
  
  const ratio = redlineRatios[engineType] || 1.6;
  const calculatedRedline = calibrationRPM * ratio;
  
  // Ensure redline is within motorcycle ranges
  return Math.max(6000, Math.min(16000, calculatedRedline));
},

// Enhanced engine type classification
classifyEngineType: function(frequencyStats) {
  const dominantFreq = frequencyStats.dominantFreq;
  const baseRPM = dominantFreq * 60;
  
  // Classify based on both frequency and RPM characteristics
  if (baseRPM < 5000) return 'cruiser';
  if (baseRPM < 8000) return 'standard'; 
  if (baseRPM < 12000) return 'sport';
  return 'high-rev';
},

buildFrequencyResponse: function(recordingBuffer) {
  // Build a frequency response profile for this engine
  const freqBins = new Array(20).fill(0).map((_, i) => i * 100 + 50); // 50-2050 Hz
  const response = {};
  
  freqBins.forEach(freq => {
    const amplitudes = recordingBuffer
      .filter(sample => Math.abs(sample.dominantFreq - freq) < 25) // ±25 Hz window
      .map(sample => sample.maxDb);
    
    response[freq] = amplitudes.length > 0 ? 
      amplitudes.reduce((a, b) => a + b) / amplitudes.length : 0;
  });
  
  return response;
},

  resetCalibration: function() {
  if (confirm('Reset engine calibration? This cannot be undone.')) {
    this.audioAnalysis.calibration = {
      isCalibrated: false,
      recordedSample: null,
      referenceFrequency: 0,
      referenceRPM: 0,
      frequencyResponse: [],
      volumeThreshold: 20,
      minRPM: 1000,
      maxRPM: 12000,
      bikeProfile: {
        name: 'Uncalibrated',
        type: 'unknown',
        redline: 8000,
        idleRPM: 1500
      }
    };
    localStorage.removeItem('engineCalibration');
    this.updateEngineDisplay();
    this.log('Calibration reset');
  }
},
  
applyCalibrationProfile: function(analysis) {
  this.audioAnalysis.calibration.isCalibrated = true;
  this.audioAnalysis.calibration.referenceFrequency = analysis.dominantFrequency;
  this.audioAnalysis.calibration.referenceRPM = analysis.estimatedRPM;
  this.audioAnalysis.calibration.frequencyResponse = analysis.frequencyResponse;
  this.audioAnalysis.calibration.minRPM = analysis.idleRPM;
  this.audioAnalysis.calibration.maxRPM = analysis.redlineRPM;
  this.audioAnalysis.calibration.volumeThreshold = analysis.volumeRange.average * 0.3;
   this.saveCalibrationToStorage();
  
  this.audioAnalysis.calibration.bikeProfile = {
    name: `Calibrated ${analysis.engineType}`,
    type: analysis.engineType,
    redline: analysis.redlineRPM,
    idleRPM: analysis.idleRPM
  };
  
  // Update UI
  document.getElementById('bikeProfileName').textContent = this.audioAnalysis.calibration.bikeProfile.name;
  document.getElementById('calibrationMultiplier').textContent = (analysis.estimatedRPM / (analysis.dominantFrequency * 60)).toFixed(2) + 'x';
},

// Updated frequencyToRPM with impulse response matching
frequencyToRPM: function(frequency) {

  const cal = this.audioAnalysis.calibration;
  
  if (frequency < 20) return 0;
  
  if (cal.isCalibrated) {
    // Use the recorded calibration profile
    return this.calculateRPMFromCalibration(frequency);
  } else {
    // Fallback to basic calculation
    return this.frequencyToRPMBasic(frequency);
  }
},
  
  // Realistic RPM calculation with motorcycle-specific ranges
frequencyToRPMRealistic: function(frequency) {
  // Basic calculation for uncalibrated state
  const baseRPM = frequency * 60;
  
  // Apply motorcycle-specific limits
  return this.normalizeRPMToMotorcycleRange(baseRPM);
},

  // Normalize RPM to realistic motorcycle ranges
normalizeRPMToMotorcycleRange: function(rpm) {
  // Motorcycle-specific limits
  const MIN_MOTORCYCLE_RPM = 800;
  const MAX_MOTORCYCLE_RPM = 16000;
  const MIN_POSSIBLE_RPM = 500;   // Absolute minimum for any engine
  const MAX_POSSIBLE_RPM = 20000; // Absolute maximum for any motorcycle
  
  // If RPM is way outside motorcycle ranges, it's probably noise
  if (rpm < MIN_POSSIBLE_RPM || rpm > MAX_POSSIBLE_RPM) {
    return 0;
  }
  
  // Clamp to motorcycle ranges
  return Math.max(MIN_MOTORCYCLE_RPM, Math.min(MAX_MOTORCYCLE_RPM, rpm));
},


calculateRPMFromCalibration: function(currentFrequency) {
  const cal = this.audioAnalysis.calibration;
  
  // Base calculation using recorded reference
  let baseRPM = (currentFrequency / cal.referenceFrequency) * cal.referenceRPM;
  
  // Apply frequency response correction
  const responseCorrection = this.getFrequencyResponseCorrection(currentFrequency);
  baseRPM *= responseCorrection;
  
  // Apply limits
  baseRPM = Math.max(cal.minRPM, Math.min(cal.maxRPM, baseRPM));
  
  return Math.round(baseRPM);
},

getFrequencyResponseCorrection: function(frequency) {
  const response = this.audioAnalysis.calibration.frequencyResponse;
  if (!response || Object.keys(response).length === 0) return 1.0;
  
  // Find closest frequency bin
  const frequencies = Object.keys(response).map(f => parseInt(f));
  const closestFreq = frequencies.reduce((prev, curr) => {
    return (Math.abs(curr - frequency) < Math.abs(prev - frequency) ? curr : prev);
  });
  
  const expectedAmplitude = response[closestFreq];
  if (expectedAmplitude === 0) return 1.0;
  
  // Calculate correction based on expected vs current response
  const currentAmplitude = this.audioAnalysis.maxDb;
  const correction = expectedAmplitude / (currentAmplitude || 1);
  
  // Limit correction to reasonable range
  return Math.max(0.5, Math.min(2.0, correction));
},

frequencyToRPMBasic: function(frequency) {
  // Basic fallback calculation
  const baseRPM = frequency * 60;
  return Math.max(1000, Math.min(12000, baseRPM));
},
  
  // Manual calibration functions
updateReferenceRPM: function(rpm) {
  document.getElementById('referenceRpmValue').textContent = rpm;
  this.manualReferenceRPM = parseInt(rpm);
},
  
  // Manual calibration as fallback
manualCalibration: function() {
  const manualRPM = prompt('Enter the RPM your engine was at during recording (e.g., 5000):');
  if (!manualRPM || isNaN(manualRPM)) {
    alert('Please enter a valid RPM number');
    return;
  }

  const rpm = parseInt(manualRPM);
  if (rpm < 1000 || rpm > 15000) {
    alert('Please enter a realistic RPM (1000-15000)');
    return;
  }

  // Use current frequency reading
  const currentFreq = this.findDominantFrequency();
  if (currentFreq < 20) {
    alert('No engine sound detected. Please start engine analysis and rev engine.');
    return;
  }

  this.audioAnalysis.calibration.isCalibrated = true;
  this.audioAnalysis.calibration.referenceFrequency = currentFreq;
  this.audioAnalysis.calibration.referenceRPM = rpm;
  this.audioAnalysis.calibration.minRPM = Math.max(800, rpm * 0.15);
  this.audioAnalysis.calibration.maxRPM = rpm * 1.8;
    this.saveCalibrationToStorage();


  document.getElementById('calibrationStatus').textContent = `✅ Manual Calibration: ${rpm} RPM`;
  document.getElementById('calibrationStatus').style.color = 'var(--success-color)';
  document.getElementById('detectedRange').textContent = `${this.audioAnalysis.calibration.minRPM.toFixed(0)}-${this.audioAnalysis.calibration.maxRPM.toFixed(0)} RPM`;

  this.log(`Manual calibration applied: ${currentFreq.toFixed(1)} Hz = ${rpm} RPM`);
},
  
  // Real-time monitoring for debugging
startCalibrationMonitor: function() {
  if (!this.audioAnalysis.isListening) {
    alert('Start engine analysis first');
    return;
  }

  console.log('=== STARTING CALIBRATION MONITOR ===');
  let monitorCount = 0;
  const monitorInterval = setInterval(() => {
    const dominantFreq = this.findDominantFrequency();
    const maxDb = this.audioAnalysis.maxDb;
    
    console.log(`Monitor [${monitorCount++}]: Freq: ${dominantFreq.toFixed(1)}Hz, Volume: ${maxDb}dB`);
    
    // Visual feedback
    document.getElementById('calibrationStatus').textContent = 
      `Monitoring... Freq: ${dominantFreq.toFixed(1)}Hz, Vol: ${maxDb}dB`;
    
    if (monitorCount > 20) { // Stop after 20 readings
      clearInterval(monitorInterval);
      console.log('=== CALIBRATION MONITOR ENDED ===');
      document.getElementById('calibrationStatus').textContent = 'Monitor completed - check console';
    }
  }, 500);
},

// Add to your MotoFindBack object
saveCalibrationToStorage: function() {
  if (this.audioAnalysis.calibration.isCalibrated) {
    localStorage.setItem('engineCalibration', JSON.stringify(this.audioAnalysis.calibration));
    this.log('Calibration saved to storage');
  }
},

loadCalibrationFromStorage: function() {
  const saved = localStorage.getItem('engineCalibration');
  if (saved) {
    try {
      const calibration = JSON.parse(saved);
      this.audioAnalysis.calibration = { ...this.audioAnalysis.calibration, ...calibration };
      
      // Update UI
      document.getElementById('bikeProfileName').textContent = this.audioAnalysis.calibration.bikeProfile.name;
      document.getElementById('calibrationStatus').textContent = 'Calibrated (loaded)';
      document.getElementById('calibrationStatus').style.color = 'var(--success-color)';
      document.getElementById('detectedRange').textContent = 
        `${this.audioAnalysis.calibration.minRPM.toFixed(0)}-${this.audioAnalysis.calibration.maxRPM.toFixed(0)} RPM`;
      
      this.log('Calibration loaded from storage');
    } catch (error) {
      this.log('Error loading calibration: ' + error.message, true);
    }
  }
}, 

applyManualCalibration: function() {
  if (!this.audioAnalysis.isListening) {
    alert('Start engine analysis first');
    return;
  }
  
  if (!this.manualReferenceRPM) {
    alert('Set reference RPM first');
    return;
  }
  
  // Use current frequency reading as reference
  const currentFreq = this.findDominantFrequency();
  if (currentFreq < 20) {
    alert('No engine sound detected');
    return;
  }
  
  this.audioAnalysis.calibration.isCalibrated = true;
  this.audioAnalysis.calibration.referenceFrequency = currentFreq;
  this.audioAnalysis.calibration.referenceRPM = this.manualReferenceRPM;
  this.saveCalibrationToStorage();
  
  document.getElementById('calibrationStatus').textContent = `Manual: ${this.manualReferenceRPM} RPM`;
  document.getElementById('calibrationStatus').style.color = 'var(--success-color)';
  
  this.log(`Manual calibration applied: ${currentFreq.toFixed(1)} Hz = ${this.manualReferenceRPM} RPM`);
},
  
  // Simple emergency toggle
toggleEmergency: function() {
  this.emergencyEnabled = !this.emergencyEnabled;
  const status = document.getElementById('emergencyStatus');
  
  if (this.emergencyEnabled) {
    status.textContent = "ENABLED";
    status.style.color = "var(--success-color)";
    document.getElementById('emergencyBtn').disabled = false;
  } else {
    status.textContent = "DISABLED"; 
    status.style.color = "var(--error-color)";
    document.getElementById('emergencyBtn').disabled = true;
  }
},
  
  updateGeneralStatistics: function() {
  if (this.sessionHistory.length === 0) {
    this.resetStatisticsDisplay();
    return;
  }
  
  const stats = this.calculateGeneralStatistics();
  
  document.getElementById('statsTotalDistance').textContent = stats.totalDistance.toFixed(1) + ' km';
  document.getElementById('statsMaxSpeedAll').textContent = stats.maxSpeed.toFixed(1) + ' km/h';
  document.getElementById('statsMaxLeanAll').textContent = stats.maxLeanAngle.toFixed(1) + '°';
  document.getElementById('statsMaxElevationAll').textContent = stats.maxElevationGain.toFixed(0) + ' m';
  document.getElementById('statsMaxCornerSpeedAll').textContent = stats.maxCornerSpeed.toFixed(1) + ' km/h';
  document.getElementById('statsMaxCornerGAll').textContent = stats.maxCornerG.toFixed(2) + ' g';
  document.getElementById('statsBest0to60').textContent = stats.best0to60 > 0 ? stats.best0to60.toFixed(2) + ' s' : '--';
  document.getElementById('statsBest0to100').textContent = stats.best0to100 > 0 ? stats.best0to100.toFixed(2) + ' s' : '--';
},

calculateGeneralStatistics: function() {
  let totalDistance = 0;
  let maxSpeed = 0;
  let maxLeanAngle = 0;
  let maxElevationGain = 0;
  let maxCornerSpeed = 0;
  let maxCornerG = 0;
  let best0to60 = Infinity;
  let best0to100 = Infinity;
  
  this.sessionHistory.forEach(session => {
    totalDistance += session.distance || 0;
    maxSpeed = Math.max(maxSpeed, session.maxSpeed || 0);
    maxElevationGain = Math.max(maxElevationGain, session.elevationGain || 0);
    
    // Get max values from metrics
    if (session.metrics) {
      if (session.metrics.leanAngles && session.metrics.leanAngles.length > 0) {
        const sessionMaxLean = Math.max(...session.metrics.leanAngles.map(l => l.angle || 0));
        maxLeanAngle = Math.max(maxLeanAngle, sessionMaxLean);
      }
      
      if (session.metrics.corneringData && session.metrics.corneringData.length > 0) {
        const sessionMaxCornerSpeed = Math.max(...session.metrics.corneringData.map(c => c.speed || 0));
        const sessionMaxCornerG = Math.max(...session.metrics.corneringData.map(c => c.g || 0));
        maxCornerSpeed = Math.max(maxCornerSpeed, sessionMaxCornerSpeed);
        maxCornerG = Math.max(maxCornerG, sessionMaxCornerG);
      }
      
      if (session.metrics.accelerationTimes && session.metrics.accelerationTimes.length > 0) {
        // For simplicity, using the best acceleration time from the session
        const sessionBestAccel = Math.min(...session.metrics.accelerationTimes.filter(t => t > 0));
        if (sessionBestAccel < best0to100) {
          best0to100 = sessionBestAccel;
        }
        // For 0-60, we'd need separate tracking, but using same for demo
        best0to60 = Math.min(best0to60, sessionBestAccel * 0.6); // Rough estimate
      }
    }
  });
  
  return {
    totalDistance,
    maxSpeed,
    maxLeanAngle,
    maxElevationGain,
    maxCornerSpeed,
    maxCornerG,
    best0to60: best0to60 !== Infinity ? best0to60 : 0,
    best0to100: best0to100 !== Infinity ? best0to100 : 0
  };
},

resetStatisticsDisplay: function() {
  document.getElementById('statsTotalDistance').textContent = '0 km';
  document.getElementById('statsMaxSpeedAll').textContent = '0 km/h';
  document.getElementById('statsMaxLeanAll').textContent = '0°';
  document.getElementById('statsMaxElevationAll').textContent = '0 m';
  document.getElementById('statsMaxCornerSpeedAll').textContent = '0 km/h';
  document.getElementById('statsMaxCornerGAll').textContent = '0 g';
  document.getElementById('statsBest0to60').textContent = '--';
  document.getElementById('statsBest0to100').textContent = '--';
},

exportAllStatistics: function() {
  const stats = this.calculateGeneralStatistics();
  const data = {
    generalStatistics: stats,
    totalSessions: this.sessionHistory.length,
    sessions: this.sessionHistory,
    exportedAt: new Date().toISOString()
  };
  
  const dataStr = JSON.stringify(data, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `motorcycle_stats_${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  this.log("All statistics exported");
},

clearAllStatistics: function() {
  if (confirm('Are you sure you want to clear ALL statistics and session data? This cannot be undone!')) {
    this.sessionHistory = [];
    this.saveSessionsToStorage();
    this.updateGeneralStatistics();
    this.updateSessionHistoryDisplay();
    this.log("All statistics cleared");
  }
},
  
  // Add this debug method
debugLockPosition: function() {
  console.log('=== LOCK POSITION DEBUG ===');
  console.log('1. Button element:', document.getElementById("testBtn"));
  console.log('2. Last position:', this.lastPosition);
  console.log('3. Audio context:', this.audioCtx);
  console.log('4. Audio allowed:', this.isAudioAllowed);
  console.log('5. Is active:', this.isActive);
  
  // Test if click handler is attached
  const btn = document.getElementById("testBtn");
  if (btn) {
    console.log('6. Button onclick:', btn.onclick);
    console.log('7. Button event listeners:', 
      btn._eventListeners ? btn._eventListeners : 'No internal tracking');
  }
  
  // Manually test lock position
  this.lockCurrentPosition();
},
  
  // Session management functions
startNewSession: function() {
  const sessionId = 'session_' + Date.now();
  
  this.currentSession = {
    ...this.sessionTemplate,
    id: sessionId,
    name: `Ride ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,
    startTime: Date.now(),
    routeData: [],
    metrics: {
      accelerationTimes: [],
      leanAngles: [],
      corneringData: [],
      elevationData: []
    }
  };
  
  // Start auto-save every 30 seconds
  this.autoSaveInterval = setInterval(() => {
    this.autoSaveSession();
  }, 30000);
  
  this.log(`New session started: ${sessionId}`);
  this.updateSessionDisplay();
},

autoSaveSession: function() {
  if (!this.currentSession) return;
  
  this.updateCurrentSessionData();
  this.saveSessionsToStorage();
  this.log('Session auto-saved');
},

updateCurrentSessionData: function() {
  if (!this.currentSession) return;
  
  // Update basic metrics
  this.currentSession.distance = this.todayDistance;
  this.currentSession.maxSpeed = this.maxSpeed;
  this.currentSession.avgSpeed = this.calculateAverageSpeed();
  this.currentSession.elevationGain = this.elevationGain;
  this.currentSession.corners = this.corners.length;
  this.currentSession.duration = Date.now() - this.currentSession.startTime;
  
  // Count safety events
  this.currentSession.hardBrakingEvents = this.hardBrakingEvents ? this.hardBrakingEvents.length : 0;
  this.currentSession.aggressiveCorners = this.aggressiveCorneringEvents ? this.aggressiveCorneringEvents.length : 0;
  
  // Add current position to route
  if (this.lastPosition) {
    this.currentSession.routeData.push({
      lat: this.lastPosition.lat,
      lon: this.lastPosition.lon,
      alt: this.lastPosition.alt,
      speed: this.currentSpeed,
      timestamp: Date.now(),
      leanAngle: this.currentLeanAngle
    });
    
    // Keep only last 1000 points to prevent memory issues
    if (this.currentSession.routeData.length > 1000) {
      this.currentSession.routeData = this.currentSession.routeData.slice(-1000);
    }
  }
  
  // Update detailed metrics
  this.currentSession.metrics.accelerationTimes = [...this.accelerationTimes];
  this.currentSession.metrics.leanAngles.push({
    angle: this.currentLeanAngle,
    timestamp: Date.now()
  });
  this.currentSession.metrics.corneringData = [...this.corners];
  this.currentSession.metrics.elevationData = [...this.elevationHistory];
},

saveCurrentSession: function() {
  if (!this.currentSession) {
    alert('No active session to save');
    return;
  }
  
  this.updateCurrentSessionData();
  
  // Add end time
  this.currentSession.endTime = Date.now();
  this.currentSession.duration = this.currentSession.endTime - this.currentSession.startTime;
  
  // Prompt for session name and notes
  const sessionName = prompt('Enter a name for this ride session:', this.currentSession.name);
  if (sessionName !== null) {
    this.currentSession.name = sessionName;
    
    const sessionNotes = prompt('Add any notes about this ride (optional):', '');
    if (sessionNotes !== null) {
      this.currentSession.notes = sessionNotes;
    }
    
    // Add to session history
    this.sessionHistory.unshift({...this.currentSession});
    
    // Save to storage
    this.saveSessionsToStorage();
    
    this.log(`Session saved: ${this.currentSession.name}`);
    this.showSessionSavedNotification();
    
    // Clear current session
    this.currentSession = null;
    clearInterval(this.autoSaveInterval);
    
    this.updateSessionHistoryDisplay();
  }
},

quickSaveSession: function() {
  if (!this.currentSession) {
    this.startNewSession();
  }
  
  this.updateCurrentSessionData();
  this.saveSessionsToStorage();
  this.showQuickSaveNotification();
  this.log('Session quick-saved');
},

exportSession: function(sessionId = null) {
  const session = sessionId ? 
    this.sessionHistory.find(s => s.id === sessionId) : 
    this.currentSession;
  
  if (!session) {
    alert('No session to export');
    return;
  }
  
  const dataStr = JSON.stringify(session, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `ride_session_${session.name.replace(/[^a-z0-9]/gi, '_')}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  this.log(`Session exported: ${session.name}`);
},

loadSession: function(sessionId) {
  const session = this.sessionHistory.find(s => s.id === sessionId);
  if (!session) return;
  
  // Create a visual replay of the session
  this.replaySession(session);
},

replaySession: function(session) {
  // Basic session info display
  alert(`Session: ${session.name}\nDistance: ${session.distance.toFixed(1)} km\nDuration: ${this.formatDuration(session.duration)}\nMax Speed: ${session.maxSpeed.toFixed(1)} km/h`);
  
  // You could implement a full replay on the map here
  this.log(`Loaded session: ${session.name}`);
},

deleteSession: function(sessionId) {
  if (confirm('Are you sure you want to delete this session?')) {
    this.sessionHistory = this.sessionHistory.filter(s => s.id !== sessionId);
    this.saveSessionsToStorage();
    this.updateSessionHistoryDisplay();
    this.log('Session deleted');
  }
},

// Storage functions
saveSessionsToStorage: function() {
  const data = {
    sessions: this.sessionHistory,
    lastUpdated: Date.now()
  };
  localStorage.setItem('rideSessions', JSON.stringify(data));
},

loadSessionsFromStorage: function() {
  const saved = localStorage.getItem('rideSessions');
  console.log('Loading sessions from storage:', saved ? 'Data found' : 'No data');
  
  if (saved) {
    try {
      const data = JSON.parse(saved);
      this.sessionHistory = data.sessions || [];
      console.log('Successfully loaded sessions:', this.sessionHistory.length);
      this.updateSessionHistoryDisplay();
    } catch (error) {
      console.error('Error loading saved sessions:', error);
      this.sessionHistory = [];
    }
  } else {
    this.sessionHistory = [];
    console.log('No saved sessions found in storage');
  }
},

// Utility functions
formatDuration: function(milliseconds) {
  const seconds = Math.floor(milliseconds / 1000);
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  
  if (hours > 0) {
    return `${hours}h ${minutes}m ${secs}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${secs}s`;
  } else {
    return `${secs}s`;
  }
},

formatDistance: function(km) {
  if (km < 1) {
    return `${(km * 1000).toFixed(0)} m`;
  }
  return `${km.toFixed(1)} km`;
},

updateCalibrationDisplay: function() {
  // Update lean offset
  document.getElementById('calibrationLeanOffset').textContent = 
    this.leanOffset !== undefined ? this.leanOffset.toFixed(1) + '°' : '0°';
  
  // Update normal beta
  document.getElementById('calibrationNormalBeta').textContent = 
    this.normalBeta !== undefined ? this.normalBeta.toFixed(1) + '°' : '--°';
  
  // Update crash threshold
  document.getElementById('calibrationCrashThreshold').textContent = 
    this.crashThreshold !== undefined ? this.crashThreshold.toFixed(1) + '°' : '--°';
  
  // Update current deviation (initialize as --)
  if (!document.getElementById('currentDeviation').textContent.includes('--')) {
    document.getElementById('currentDeviation').textContent = '--°';
  }
},

// Session display functions
updateSessionDisplay: function() {
  const sessionInfo = document.getElementById('sessionInfo');
  if (!this.currentSession) {
    sessionInfo.style.display = 'none';
    return;
  }
  
  sessionInfo.style.display = 'block';
  document.getElementById('sessionName').textContent = this.currentSession.name;
  document.getElementById('sessionDuration').textContent = this.formatDuration(Date.now() - this.currentSession.startTime);
  document.getElementById('sessionDistance').textContent = this.formatDistance(this.currentSession.distance);
  document.getElementById('sessionMaxSpeed').textContent = this.currentSession.maxSpeed.toFixed(1) + ' km/h';
  document.getElementById('sessionCorners').textContent = this.currentSession.corners;
},

updateSessionHistoryDisplay: function() {
  const historyList = document.getElementById('sessionHistoryList');
  
  if (this.sessionHistory.length === 0) {
    historyList.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">No saved sessions yet</div>';
    return;
  }
  
  historyList.innerHTML = this.sessionHistory.map(session => `
    <div class="session-item" data-session-id="${session.id}">
      <div class="session-header">
        <strong>${session.name}</strong>
        <span class="session-date">${new Date(session.startTime).toLocaleDateString()}</span>
      </div>
      <div class="session-details">
        <span>${this.formatDistance(session.distance)}</span>
        <span>${this.formatDuration(session.duration)}</span>
        <span>${session.maxSpeed.toFixed(1)} km/h</span>
        <span>${session.corners} corners</span>
      </div>
      <div class="session-actions">
        <button onclick="MotoFindBack.exportSession('${session.id}')" title="Export">📤</button>
        <button onclick="MotoFindBack.loadSession('${session.id}')" title="View">👁️</button>
        <button onclick="MotoFindBack.deleteSession('${session.id}')" title="Delete" style="background: #ff3333;">🗑️</button>
      </div>
      ${session.notes ? `<div class="session-notes">${session.notes}</div>` : ''}
    </div>
  `).join('');
},

// UI Notification functions
showSessionSavedNotification: function() {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(to bottom, #00cc66, #00aa55);
    color: white;
    padding: 15px 20px;
    border-radius: 8px;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  notification.textContent = '✅ Ride Session Saved!';
  document.body.appendChild(notification);
  
  setTimeout(() => {
    document.body.removeChild(notification);
  }, 3000);
},

showQuickSaveNotification: function() {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(to bottom, var(--accent-color), #0099cc);
    color: white;
    padding: 10px 15px;
    border-radius: 6px;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    font-size: 0.9em;
  `;
  notification.textContent = '💾 Session Quick-Saved';
  document.body.appendChild(notification);
  
  setTimeout(() => {
    document.body.removeChild(notification);
  }, 2000);
},

// UI Updates
updateEngineDisplay: function() {
  if (!document.getElementById('engineRPM')) return;
  
  document.getElementById('engineRPM').textContent = Math.round(this.audioAnalysis.engineRPM) + ' RPM';
  document.getElementById('engineGear').textContent = this.audioAnalysis.gearPosition;
  document.getElementById('engineHealth').textContent = this.audioAnalysis.engineHealth;
  document.getElementById('engineVolume').textContent = this.audioAnalysis.maxDb + ' dB';
  
  // Debug info
  document.getElementById('micStatus').textContent = this.audioAnalysis.isListening ? 'Listening' : 'Stopped';
  const dominantFreq = this.findDominantFrequency();
  document.getElementById('debugFreq').textContent = Math.round(dominantFreq);
  document.getElementById('debugVolume').textContent = this.audioAnalysis.maxDb;
  document.getElementById('debugEnergy').textContent = this.audioAnalysis.totalEnergy || 0;
},
    
// Triple-tap detection setup
setupTripleTapDetection: function() {
  document.addEventListener('click', (e) => {
    this.handleTripleTap(e);
  });
  
  // Also close overlay when clicking on it
  document.getElementById('tripleTapOverlay').addEventListener('click', (e) => {
    this.hideOverlay();
  });
},

handleTripleTap: function(e) {
  const currentTime = Date.now();
  const timeSinceLastTap = currentTime - this.lastTapTime;
  
  // Reset if too much time passed between taps (500ms max between taps)
  if (timeSinceLastTap > 500) {
    this.tripleTapCount = 1;
  } else {
    this.tripleTapCount++;
  }
  
  this.lastTapTime = currentTime;
  
  // Clear existing timeout
  if (this.tripleTapTimeout) {
    clearTimeout(this.tripleTapTimeout);
  }
  
  // Check for triple tap
  if (this.tripleTapCount >= 3) {
    this.tripleTapCount = 0;
    this.showOverlay();
    return;
  }
  
  // Reset counter after timeout
  this.tripleTapTimeout = setTimeout(() => {
    this.tripleTapCount = 0;
  }, 500);
},

showOverlay: function() {
  if (this.isOverlayVisible) return;
  
  this.isOverlayVisible = true;
  const overlay = document.getElementById('tripleTapOverlay');
  overlay.classList.add('active');
  
  // Update stats
  this.updateOverlayStats();
  
  // Start animation for enlarged wheel
  this.updateEnlargedWheelAnimation();
  
  this.log("Triple-tap overlay shown");
},

hideOverlay: function() {
  if (!this.isOverlayVisible) return;
  
  this.isOverlayVisible = false;
  const overlay = document.getElementById('tripleTapOverlay');
  overlay.classList.remove('active');
  
  this.log("Triple-tap overlay hidden");
},

updateOverlayStats: function() {
  document.getElementById('overlayAvgSpeed').textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
  document.getElementById('overlayLeanAngle').textContent = this.currentLeanAngle + "°";
  document.getElementById('overlayMaxLean').textContent = this.maxLeanAngle + "°";
  document.getElementById('overlayCurrentSpeed').textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
},

updateEnlargedWheelAnimation: function() {
  const enlargedWheel = document.querySelector('.enlarged-wheel');
  const enlargedSpokes = document.querySelectorAll('.enlarged-wheel .wheel-spoke');
  
  if (this.currentSpeed <= 0.1) {
    enlargedWheel.style.animation = 'none';
    enlargedSpokes.forEach(spoke => spoke.style.animation = 'none');
  } else {
    const speedKmh = this.currentSpeed * 3.6;
    const rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
    enlargedWheel.style.animation = `wheel-spin ${rotationSpeed}s linear infinite`;
    enlargedSpokes.forEach((spoke, index) => {
      const spokeSpeed = rotationSpeed * (1 + index * 0.5);
      spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
    });
  }
},

// Update your existing updateWheelAnimation function to also update the enlarged wheel:
updateWheelAnimation: function() {
  const wheel = document.querySelector('.spinning-wheel');
  const spokes = document.querySelectorAll('.wheel-spoke');
  
  if (this.currentSpeed <= 0.1) {
    wheel.style.animation = 'none';
    spokes.forEach(spoke => spoke.style.animation = 'none');
  } else {
    const speedKmh = this.currentSpeed * 3.6;
    this.rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
    wheel.style.animation = `wheel-spin ${this.rotationSpeed}s linear infinite`;
    spokes.forEach((spoke, index) => {
      const spokeSpeed = this.rotationSpeed * (1 + index * 0.5);
      spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
    });
  }
  
  // Also update enlarged wheel if visible
  if (this.isOverlayVisible) {
    this.updateEnlargedWheelAnimation();
  }
},

 updateElevationProfile: function() {
  if (!this.canvas) {
    this.log("Error: elevationCanvas element not found", true);
    return;
  }
  
  const ctx = this.canvas.getContext('2d');
  if (!ctx) {
    this.log("Error: Unable to get 2D context for elevationCanvas", true);
    return;
  }
  
  // Get the container dimensions
  const container = this.canvas.parentElement;
  this.canvas.width = container.clientWidth;
  this.canvas.height = container.clientHeight;
  
  const w = this.canvas.width;
  const h = this.canvas.height;
  
  // Clear canvas with dark background
  ctx.fillStyle = '#222';
  ctx.fillRect(0, 0, w, h);
  
  if (this.elevationHistory.length < 2) {
    // Draw placeholder message
    ctx.fillStyle = '#666';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Not enough elevation data', w / 2, h / 2);
    this.log("Not enough elevation data to plot");
    return;
  }

  // Smooth the elevation data
  const smoothedElevations = [];
  for (let i = 0; i < this.elevationHistory.length; i++) {
    const start = Math.max(0, i - 1);
    const end = Math.min(this.elevationHistory.length - 1, i + 1);
    const avgElev = this.elevationHistory.slice(start, end + 1)
      .reduce((sum, p) => sum + p.elev, 0) / (end - start + 1);
    smoothedElevations.push(avgElev);
  }

  const minElev = Math.min(...smoothedElevations);
  const maxElev = Math.max(...smoothedElevations);
  const range = maxElev - minElev || 1;

  // Draw the elevation line
  ctx.beginPath();
  ctx.moveTo(0, h - 10); // Leave some padding at bottom
  
  smoothedElevations.forEach((elev, i) => {
    const x = (i / (smoothedElevations.length - 1)) * w;
    const y = h - 10 - ((elev - minElev) / range * (h - 20)); // Padding top and bottom
    ctx.lineTo(x, y);
  });
  
  ctx.strokeStyle = 'var(--accent-color)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Add gradient fill under the line
  ctx.lineTo(w, h - 10);
  ctx.lineTo(0, h - 10);
  ctx.closePath();
  
  const gradient = ctx.createLinearGradient(0, 0, 0, h);
  gradient.addColorStop(0, 'rgba(0, 204, 255, 0.3)');
  gradient.addColorStop(1, 'rgba(0, 204, 255, 0.1)');
  ctx.fillStyle = gradient;
  ctx.fill();

  // Add scale markers
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h - 10);
  ctx.lineTo(w, h - 10);
  ctx.stroke();

  // Update elevation stats
  document.getElementById('totalElevationGain').textContent = this.elevationGain.toFixed(0) + ' m';
  document.getElementById('elevationGain').textContent = this.elevationGain.toFixed(0) + ' m';
    document.getElementById('maxElevation').textContent = maxElev.toFixed(0) + ' m';
    document.getElementById('minElevation').textContent = minElev.toFixed(0) + ' m';
  },

  // Remaining methods (unchanged from previous response)
  initMap: function() {
    this.map = L.map('map').setView([51.505, -0.09], 15);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(this.map);

    const userIcon = L.divIcon({ className: 'user-marker', html: '📍', iconSize: [24, 24] });
    const lockIcon = L.divIcon({ className: 'lock-marker', html: '🔒', iconSize: [24, 24] });
    this.userMarker = L.marker([0, 0], { icon: userIcon }).addTo(this.map);
    this.lockMarker = L.marker([0, 0], { icon: lockIcon }).addTo(this.map);
    this.line = L.polyline([], { color: '#ff6600', weight: 2 }).addTo(this.map);
  },

  setupTabs: function() {
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
      });
    });
  },

  setupCollapsibles: function() {
    const coll = document.getElementsByClassName("collapsible");
    for (let i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        const content = this.nextElementSibling;
        content.style.maxHeight = content.style.maxHeight ? null : content.scrollHeight + "px";
      });
    }
  },

initDeviceOrientation: function() {
  // Initialize crash detection variables
  this.crashDetected = false;
  this.crashStartTime = null;
  this.lastBeta = 0;
  
  if (window.DeviceOrientationEvent) {
    // Request permission for device orientation on iOS
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            window.addEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));
            this.log("Device orientation permission granted");
          } else {
            this.log("Device orientation permission denied", true);
          }
        })
        .catch(console.error);
    } else {
      // Non-iOS devices
      window.addEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));
    }
    
    document.getElementById('crashStatus').textContent = 'Crash Detection: Active';
    document.getElementById('crashStatus').className = 'status success';
    this.log("Crash detection initialized and active");
  } else {
    this.log("Device orientation not supported", true);
    document.getElementById('crashStatus').textContent = 'Crash Detection: Not supported';
    document.getElementById('crashStatus').className = 'status error';
  }
},

// Add this new method to handle device orientation
handleDeviceOrientation: function(event) {
  if (this.isCalibrating) {
    this.calibrationSamples.push(event.gamma || 0);
    return;
  }

  // Handle lean angle (gamma)
  if (event.gamma !== null) {
    this.currentLeanAngle = Math.round(Math.abs(event.gamma - this.leanOffset));
    this.updateLeanAngleDisplay();
    if (this.currentLeanAngle > this.maxLeanAngle) this.maxLeanAngle = this.currentLeanAngle;
    const speedMs = this.currentSpeed;
    this.currentCornerG = this.calculateCornerG(speedMs, this.currentLeanAngle);
    this.detectCorner(this.lastPosition?.lat, this.lastPosition?.lon, speedMs * 3.6, this.currentLeanAngle, this.currentCornerG);
  }
  
  // CRASH DETECTION - Handle beta (front-to-back tilt)
  if (event.beta !== null && this.normalBeta !== null) {
    const currentBeta = event.beta;
    
    // Calculate how far we are from the normal riding position
    const deviationFromNormal = Math.abs(currentBeta - this.normalBeta);
    
    // Update deviation display (moved from separate block)
    document.getElementById('currentDeviation').textContent = deviationFromNormal.toFixed(1) + '°';
    
    // Color code based on severity
    const deviationElement = document.getElementById('currentDeviation');
    if (deviationFromNormal > this.crashThreshold) {
        deviationElement.style.color = 'var(--error-color)';
    } else if (deviationFromNormal > this.betaTolerance) {
        deviationElement.style.color = 'var(--warning-color)';
    } else {
        deviationElement.style.color = 'var(--success-color)';
    }
    
    // Crash condition: significant deviation from normal position AND we're moving
    const isCrashed = deviationFromNormal > this.crashThreshold;
    const isMoving = this.currentSpeed > 2; // More than 2 m/s (~7 km/h)
    
    if (isCrashed && isMoving && !this.crashDetected) {
        if (!this.crashStartTime) {
            this.crashStartTime = Date.now();
            document.getElementById('crashStatus').textContent = 
                `Crash detected! ${deviationFromNormal.toFixed(1)}° from normal position`;
            document.getElementById('crashStatus').className = 'status warning';
            this.log(`Crash detected: ${deviationFromNormal.toFixed(1)}° deviation from normal position`);
        }
        
        // Confirm crash after 3 seconds of sustained abnormal position
        if (Date.now() - this.crashStartTime > 3000) {
            this.crashDetected = true;
            this.triggerCrashAlert(deviationFromNormal);
        }
    } else {
        // Reset if we're back to normal position
        if (this.crashStartTime && deviationFromNormal < this.betaTolerance) {
            this.crashStartTime = null;
            document.getElementById('crashStatus').textContent = 'Crash Detection: Active (Normal)';
            document.getElementById('crashStatus').className = 'status success';
            this.log('Back to normal position - crash condition cleared');
        }
    }
    
    // Update debug info
    document.getElementById('debug').innerHTML += 
        `<div style="color: #ccc">Beta: ${currentBeta.toFixed(1)}° | Deviation: ${deviationFromNormal.toFixed(1)}° | Normal: ${this.normalBeta.toFixed(1)}°</div>`;
  }
},

setupEventListeners: function() {
  console.log('=== SETUP EVENT LISTENERS STARTED ===');
   // TAB SWITCHING
// Tab switching - SIMPLIFIED VERSION
const tabs = document.querySelectorAll('.tab');
tabs.forEach(tab => {
  tab.addEventListener('click', () => {
    console.log('Tab clicked:', tab.dataset.tab);
    
    // Remove active from all tabs and hide all contents
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.remove('active');
    });
    
    // Activate selected tab and content
    tab.classList.add('active');
    const tabContent = document.getElementById(tab.dataset.tab + '-tab');
    if (tabContent) {
      tabContent.classList.add('active');
    }
  });
});

  // All button event listeners
  document.getElementById("testBtn").addEventListener("click", () => {
    this.initAudio();
    this.playTestSound();
    if (this.isAudioAllowed) this.lockCurrentPosition();
  });
  document.getElementById("calibrateBtn").addEventListener("click", () => this.calibrateSensors());
  document.getElementById("autoLockBtn").addEventListener("click", () => this.toggleAutoLock());
  document.getElementById("muteBtn").addEventListener("click", () => this.toggleMute());
  document.getElementById("stopBtn").addEventListener("click", () => this.stop());
  document.getElementById("startRideBtn").addEventListener("click", () => this.startRide());
  document.getElementById("resetMetricsBtn").addEventListener("click", () => this.resetMetrics());
  document.getElementById("exportMetricsBtn").addEventListener("click", () => this.exportMetrics());
  document.getElementById("emergencyBtn").addEventListener("click", () => this.sendEmergencyAlert());
  document.getElementById("testEmergencyBtn").addEventListener("click", () => this.testEmergency());
  document.getElementById("addContactBtn").addEventListener("click", () => this.addEmergencyContact());
  document.getElementById("addMaintenanceBtn").addEventListener("click", () => this.showMaintenanceForm());
  document.getElementById("resetMaintenanceBtn").addEventListener("click", () => this.resetMaintenance());
  document.getElementById("saveMaintenanceBtn").addEventListener("click", () => this.saveMaintenanceItem());
  document.getElementById("startEngineAnalysis").addEventListener("click", () => this.startEngineAnalysis());
  document.getElementById("calibrateEngine").addEventListener("click", () => this.calibrateEngine());
  document.getElementById("startSessionBtn").addEventListener("click", () => this.startNewSession());
  document.getElementById("saveSessionBtn").addEventListener("click", () => this.saveCurrentSession());
  document.getElementById("quickSaveBtn").addEventListener("click", () => this.quickSaveSession());
  document.getElementById("exportSessionBtn").addEventListener("click", () => this.exportSession());
  document.getElementById("startRecordingBtn").addEventListener("click", () => this.startRecordingCalibration());

document.getElementById("calibrationMonitorBtn").addEventListener("click", () => this.startCalibrationMonitor());

  document.querySelectorAll('input[name="maintenanceUnit"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      this.toggleMaintenanceUnit(e.target.value);
    });
  });

  // Maintenance slider updates
  document.getElementById("newMaintenanceInterval").addEventListener("input", (e) => {
    document.getElementById("intervalValue").textContent = e.target.value + ' km';
  });

  document.getElementById("newMaintenanceWeeks").addEventListener("input", (e) => {
    document.getElementById("weeksValue").textContent = e.target.value + ' weeks';
  });

  // Input event listeners
  document.getElementById("maxDistInput").addEventListener("input", (e) => {
    document.getElementById("maxDistValue").textContent = e.target.value;
  });

  document.getElementById("stationaryTime").addEventListener("input", (e) => {
    document.getElementById("stationaryTimeValue").textContent = e.target.value + ' sec';
  });

  document.getElementById("speedThreshold").addEventListener("input", (e) => {
    this.speedThreshold = parseFloat(e.target.value);
    document.getElementById("speedThresholdValue").textContent = e.target.value + ' km/h';
  });

  document.getElementById("accelTarget").addEventListener("input", (e) => {
    this.accelTarget = parseFloat(e.target.value) || 100;
    const label = document.querySelector('#accelerationTime').previousElementSibling;
    if (label) label.textContent = `0-${this.accelTarget} km/h`;
    const statsLabel = document.querySelector('#statsAcceleration').previousElementSibling;
    if (statsLabel) statsLabel.textContent = `0-${this.accelTarget} km/h`;
    document.getElementById('accelTargetValue').textContent = this.accelTarget + ' km/h';
    this.accelerationPopup.startTime = null;
    this.accelerationPopup.achievedTime = null;
  });

  console.log('=== SETUP EVENT LISTENERS COMPLETED ===');
},



calibrateSensors: function() {
    this.isCalibrating = true;
    this.calibrationSamples = [];
    this.betaSamples = []; // Add beta samples for crash detection calibration
    
    document.getElementById('calibrateStatus').textContent = 'Calibrating... Keep phone in NORMAL RIDING POSITION for 5 seconds.';
    document.getElementById('calibrateStatus').className = 'status warning';
    
    this.log('Starting sensor calibration - ensure phone is mounted in riding position');
    
    // Create a more informative calibration dialog
    if (confirm('IMPORTANT: Place your phone in its normal riding position on the motorcycle.\n\nClick OK to start 5-second calibration.')) {
        let calibrationCount = 5;
        const countdownInterval = setInterval(() => {
            document.getElementById('calibrateStatus').textContent = 
                `Calibrating... Keep steady (${calibrationCount}s) - Riding Position`;
            calibrationCount--;
            
            if (calibrationCount < 0) {
                clearInterval(countdownInterval);
                this.finalizeCalibration();
            }
        }, 1000);

        // Collect samples for both lean and crash detection
        const calibrationListener = (event) => {
            if (event.gamma !== null) {
                this.calibrationSamples.push(event.gamma);
            }
            if (event.beta !== null) {
                this.betaSamples.push(event.beta);
            }
        };

        window.addEventListener('deviceorientation', calibrationListener);

        // Stop calibration after 5 seconds
        setTimeout(() => {
            window.removeEventListener('deviceorientation', calibrationListener);
            if (this.isCalibrating) {
                this.finalizeCalibration();
            }
        }, 5000);
    } else {
        this.isCalibrating = false;
        document.getElementById('calibrateStatus').textContent = 'Calibration cancelled';
        document.getElementById('calibrateStatus').className = 'status';
    }
},

finalizeCalibration: function() {
  this.isCalibrating = false;
  
  if (this.calibrationSamples.length > 0 && this.betaSamples.length > 0) {
    // Calculate offsets
    const avgGamma = this.calibrationSamples.reduce((a, b) => a + b, 0) / this.calibrationSamples.length;
    const avgBeta = this.betaSamples.reduce((a, b) => a + b, 0) / this.betaSamples.length;
    
    this.leanOffset = avgGamma;
    this.normalBeta = avgBeta;
    this.crashThreshold = 45;
    this.betaTolerance = 15;
    
    // Save calibration to storage
    this.saveCalibrationToStorage();
    
    // UPDATE THE DISPLAY
    this.updateCalibrationDisplay();
    
    document.getElementById('calibrateStatus').textContent = 
      `Calibrated! Lean offset: ${this.leanOffset.toFixed(1)}° | Riding position: ${this.normalBeta.toFixed(1)}°`;
    document.getElementById('calibrateStatus').className = 'status success';
    
    this.log(`Calibration complete - Lean offset: ${this.leanOffset.toFixed(1)}°, Normal beta: ${this.normalBeta.toFixed(1)}°`);
    
  } else {
    document.getElementById('calibrateStatus').textContent = 'Calibration failed - no sensor data';
    document.getElementById('calibrateStatus').className = 'status error';
  }
},


  updateLeanAngleDisplay: function() {
    const leanBike = document.getElementById('leanBike');
    const leanValue = document.getElementById('leanValue');
    const dashboardLean = document.getElementById('leanAngle');
    const displayAngle = Math.min(45, this.currentLeanAngle);
    leanBike.style.transform = `translateX(-50%) rotate(${displayAngle}deg)`;
    leanValue.textContent = `${this.currentLeanAngle}°`;
    dashboardLean.textContent = `${this.currentLeanAngle}°`;
    this.log(`Lean angle updated: ${this.currentLeanAngle}°`);
   if (this.isOverlayVisible) {
    document.getElementById('overlayLeanAngle').textContent = this.currentLeanAngle + "°";
    if (this.currentLeanAngle > this.maxLeanAngle) {
      document.getElementById('overlayMaxLean').textContent = this.maxLeanAngle + "°";
    }
  }
},

  calculateCornerG: function(speedMs, leanAngle) {
    return Math.tan(leanAngle * Math.PI / 180);
  },

  detectCorner: function(lat, lon, speedKmh, leanAngle, cornerG) {
    if (!lat || !lon || this.movementHistory.length < 3 || leanAngle < 5) return;
    const recent = this.movementHistory.slice(-3);
    const avgBearingChange = recent.reduce((sum, item, idx) => {
      if (idx === 0) return sum;
      const dLon = recent[idx].lon - recent[idx - 1].lon;
      const dLat = recent[idx].lat - recent[idx - 1].lat;
      return sum + Math.atan2(dLon, dLat) * 180 / Math.PI;
    }, 0) / 2;
    if (Math.abs(avgBearingChange) > 2 && cornerG > 0.2) {
      const cornerType = leanAngle > 30 ? 'Tight' : leanAngle > 15 ? 'Medium' : 'Sweeping';
      const corner = {
        startLat: recent[0].lat,
        startLon: recent[0].lon,
        speed: parseFloat(speedKmh),
        entrySpeed: parseFloat(recent[0].speed * 3.6),
        exitSpeed: parseFloat(speedKmh),
        g: cornerG,
        lean: leanAngle,
        type: cornerType,
        time: Date.now()
      };
      this.corners.push(corner);
      this.cornerEntrySpeeds.push(corner.entrySpeed);
      this.cornerExitSpeeds.push(corner.exitSpeed);
      if (speedKmh > this.maxCornerSpeed) this.maxCornerSpeed = parseFloat(speedKmh);
      if (cornerG > this.maxCornerG) this.maxCornerG = cornerG;
      this.updateCornerDisplay();
    }
  },

  updateCornerDisplay: function() {
    document.getElementById('currentCornerG').textContent = this.currentCornerG.toFixed(2) + ' g';
    document.getElementById('maxCornerSpeed').textContent = this.maxCornerSpeed.toFixed(1) + ' km/h';
    document.getElementById('maxCornerG').textContent = this.maxCornerG.toFixed(2) + ' g';
    const avgLean = this.corners.reduce((sum, c) => sum + c.lean, 0) / Math.max(1, this.corners.length);
    document.getElementById('avgCornerLean').textContent = avgLean.toFixed(1) + '°';
    const avgEntrySpeed = this.cornerEntrySpeeds.reduce((sum, s) => sum + s, 0) / Math.max(1, this.cornerEntrySpeeds.length);
    document.getElementById('avgCornerEntrySpeed').textContent = avgEntrySpeed.toFixed(1) + ' km/h';
    const cornerList = document.getElementById('cornerList');
    cornerList.innerHTML = this.corners.slice(-5).map(c =>
      `<p>${c.type} Corner: ${c.speed.toFixed(1)} km/h, Entry: ${c.entrySpeed.toFixed(1)} km/h, Exit: ${c.exitSpeed.toFixed(1)} km/h, ${c.g.toFixed(2)}g, ${c.lean}°</p>`
    ).join('') || 'No corners detected yet.';
    this.cornerChart.data.labels = this.corners.slice(-5).map((_, i) => `Corner ${i + 1}`);
    this.cornerChart.data.datasets[0].data = this.corners.slice(-5).map(c => c.g.toFixed(2));
    this.cornerChart.update();
  },

  updateWheelAnimation: function() {
    const wheel = document.querySelector('.spinning-wheel');
    const spokes = document.querySelectorAll('.wheel-spoke');
    if (this.currentSpeed <= 0.1) {
      wheel.style.animation = 'none';
      spokes.forEach(spoke => spoke.style.animation = 'none');
      this.log('Wheel animation stopped (speed <= 0.1 m/s)');
    } else {
      const speedKmh = this.currentSpeed * 3.6;
      this.rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
      wheel.style.animation = `wheel-spin ${this.rotationSpeed}s linear infinite`;
      spokes.forEach((spoke, index) => {
        const spokeSpeed = this.rotationSpeed * (1 + index * 0.5);
        spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
      });
      this.log(`Wheel animation updated: ${this.rotationSpeed.toFixed(2)}s per rotation at ${speedKmh.toFixed(1)} km/h`);
    }
  },

toggleMute: function() {
  this.isMuted = !this.isMuted;
  const muteBtn = document.getElementById("muteBtn");
  const audioStatus = document.getElementById("audioStatus");
  
  if (this.isMuted) {
    muteBtn.textContent = "Sound Muted";
    muteBtn.classList.add("muted");
    audioStatus.textContent = "Audio: Muted";
    audioStatus.className = "status warning";
    clearTimeout(this.bleepTimer);
    this.log("Audio muted");
  } else {
    muteBtn.textContent = "Mute Sound";
    muteBtn.classList.remove("muted");
    audioStatus.textContent = "Audio: Active";
    audioStatus.className = "status success";
    // Restart bleep if active
    if (this.isActive) {
      this.startBleep();
    }
    this.log("Audio unmuted");
  }
},

  toggleAutoLock: function() {
    this.autoLockEnabled = !this.autoLockEnabled;
    if (this.autoLockEnabled) {
      document.getElementById("autoLockBtn").textContent = "Auto-Lock: ON";
      document.getElementById("autoLockBtn").style.backgroundColor = "#ff6600";
      document.getElementById("autoLockBtn").style.color = "#000";
      document.getElementById("autoLockSettings").style.display = "block";
      this.log("Auto-lock enabled - will lock when stopped for specified time");
      this.updateGpsStatus("Auto-lock enabled - will lock when stopped");
    } else {
      document.getElementById("autoLockBtn").textContent = "Auto-Lock Mode";
      document.getElementById("autoLockBtn").style.backgroundColor = "";
      document.getElementById("autoLockBtn").style.color = "";
      document.getElementById("autoLockSettings").style.display = "none";
      clearTimeout(this.autoLockDebounce);
      this.autoLockDebounce = null;
      this.isStationary = false;
      this.lastStationaryTime = null;
      this.lastStationaryPosition = null;
      this.speedThreshold = 10;
      document.getElementById("speedThreshold").value = 10;
      document.getElementById("speedThresholdValue").textContent = "10 km/h";
      this.log("Auto-lock disabled");
      this.updateGpsStatus("Auto-lock disabled");
    }
    this.updateUI();
  },

initAudio: function() {
  if (this.audioCtx) {
    if (this.audioCtx.state === 'suspended') {
      this.audioCtx.resume().then(() => {
        console.log("Audio context resumed");
        this.isAudioAllowed = true;
      });
    }
    return;
  }
  
  try {
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Modern browsers require user interaction to enable audio
    if (this.audioCtx.state === 'suspended') {
      console.log('Audio context created but suspended - needs user interaction');
      // Don't set isAudioAllowed to true yet - it will be set after user interaction
    } else {
      this.isAudioAllowed = true;
      console.log('Audio context created and ready');
    }
    
    document.getElementById("audioStatus").textContent = "Audio: Initialized";
    document.getElementById("audioStatus").className = "status success";
    document.getElementById("autoLockBtn").disabled = false;
    document.getElementById("muteBtn").disabled = false;
    
    this.log("Audio system initialized");
    
  } catch (e) {
    document.getElementById("audioStatus").textContent = `Audio: ${e.message}`;
    document.getElementById("audioStatus").className = "status error";
    this.log(`Audio init error: ${e.message}`, true);
  }
},

  playTestSound: function() {
    if (!this.audioCtx || this.isMuted) {
      this.log("Audio context not ready or muted", true);
      return;
    }
    try {
      const now = this.audioCtx.currentTime;
      const osc = this.audioCtx.createOscillator();
      const gain = this.audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      osc.connect(gain);
      gain.connect(this.audioCtx.destination);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 0.1);
      gain.gain.linearRampToValueAtTime(0, now + 0.5);
      osc.start(now);
      osc.stop(now + 0.5);
      this.log("Test sound played");
    } catch (e) {
      this.log(`Test sound error: ${e.message}`, true);
    }
  },

lockCurrentPosition: function() {
  console.log('lockCurrentPosition called, lastPosition:', this.lastPosition);
  
  if (!this.lastPosition) {
    this.log("No position available to lock", true);
    
    // Show helpful message based on whether GPS is active
    if (this.isRideActive) {
      alert("⌛ GPS is active but no position yet. Wait a few seconds for GPS to acquire your location.");
    } else {
      alert("📍 Start a ride first or wait for GPS signal. The map should show your location as a blue dot.");
    }
    return;
  }
  
  this.lockPosition = { 
    lat: this.lastPosition.lat, 
    lon: this.lastPosition.lon 
  };
  
  console.log('✅ Position locked at:', this.lockPosition);
  
  // Update lock marker on map
  if (this.lockMarker) {
    this.lockMarker.setLatLng([this.lockPosition.lat, this.lockPosition.lon]);
    console.log('✅ Lock marker updated on map');
  }
  
  // Update UI
  document.getElementById("lockStatus").textContent = 
    `Lock Status: LOCKED at ${this.lockPosition.lat.toFixed(6)}, ${this.lockPosition.lon.toFixed(6)}`;
  document.getElementById("lockStatus").className = "status success";
  
  this.isActive = true;
  document.getElementById("stopBtn").disabled = false;
  document.getElementById("muteBtn").disabled = false;
  
  this.updateGpsStatus("Position locked - audio guidance active");
  this.log(`🎯 Position locked! Audio guidance started`);
  
  // Start audio guidance
  this.startBleep();
  
  // Show visual confirmation
  this.showAlertNotification('📍 Position Locked! Audio guidance active', 'success');
},
  
  // Check if GPS is ready for locking
isGPSReadyForLock: function() {
  if (!this.lastPosition) {
    return { ready: false, reason: "No GPS position available" };
  }
  
  if (this.lastPosition.lat === 0 && this.lastPosition.lon === 0) {
    return { ready: false, reason: "GPS position not yet acquired" };
  }
  
  return { ready: true, reason: "GPS ready" };
},

// Enhanced lock method with GPS check
smartLockPosition: function() {
  const gpsStatus = this.isGPSReadyForLock();
  console.log('GPS status for locking:', gpsStatus);
  
  if (!gpsStatus.ready) {
    alert(`📡 GPS Not Ready:\n${gpsStatus.reason}\n\nWait for the blue dot on the map to appear.`);
    return false;
  }
  
  return this.lockCurrentPosition();
},

  startBleep: function() {
    if (!this.isActive || this.isMuted || !this.audioCtx) return;
    clearTimeout(this.bleepTimer);
    const distance = this.calculateDistance(this.lastPosition, this.lockPosition);
    const maxDist = parseFloat(document.getElementById("maxDistInput").value);
    const freq = parseFloat(document.getElementById("freqInput").value);
    let tempo = 1000;
    if (distance < maxDist) {
      tempo = Math.max(100, 1000 * (distance / maxDist));
      const now = this.audioCtx.currentTime;
      const osc = this.audioCtx.createOscillator();
      const gain = this.audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, now);
      osc.connect(gain);
      gain.connect(this.audioCtx.destination);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 0.05);
      gain.gain.linearRampToValueAtTime(0, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
    }
    document.getElementById("bleepRate").textContent = (60000 / tempo).toFixed(0);
    this.currentTempo = tempo;
    this.bleepTimer = setTimeout(() => this.startBleep(), tempo);
  },

  calculateDistance: function(pos1, pos2) {
    if (!pos1 || !pos2) return Infinity;
    const R = 6371e3;
    const φ1 = pos1.lat * Math.PI / 180;
    const φ2 = pos2.lat * Math.PI / 180;
    const Δφ = (pos2.lat - pos1.lat) * Math.PI / 180;
    const Δλ = (pos2.lon - pos1.lon) * Math.PI / 180;
    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
              Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  },

  updateGpsStatus: function(message) {
    document.getElementById("gpsStatus").textContent = `GPS: ${message}`;
    document.getElementById("gpsStatus").className = message.includes("error") ? "status error" : "status success";
  },

  updateUI: function() {
    document.getElementById("currentSpeed").textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
    document.getElementById("maxSpeed").textContent = this.maxSpeed.toFixed(1) + " km/h";
    document.getElementById("avgSpeed").textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
    document.getElementById("todayDistance").textContent = this.todayDistance.toFixed(1) + " km";
    document.getElementById("statsToday").textContent = this.todayDistance.toFixed(1) + " km";
    document.getElementById("statsWeek").textContent = this.weekDistance.toFixed(1) + " km";
    document.getElementById("statsMonth").textContent = this.monthDistance.toFixed(1) + " km";
    document.getElementById("statsTotal").textContent = this.totalDistance.toFixed(1) + " km";
    document.getElementById("statsCurrentSpeed").textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
    document.getElementById("statsMaxSpeed").textContent = this.maxSpeed.toFixed(1) + " km/h";
    document.getElementById("statsAvgSpeed").textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
    document.getElementById("statsAcceleration").textContent = this.calculateAccelerationTime().toFixed(2) + " s";
    document.getElementById("accelerationTime").textContent = this.calculateAccelerationTime().toFixed(2) + " s";
    this.updateCornerDisplay();
    this.updateElevationProfile();
    this.updateMaintenanceList();
    this.updateEmergencyContacts();
    this.updateRideHistory();
    this.updateGeneralStatistics();
     if (this.isOverlayVisible) {
    this.updateOverlayStats();
    this.updateEnlargedWheelAnimation();
  }
  },

  calculateAverageSpeed: function() {
    if (this.movementHistory.length < 2) return 0;
    const totalSpeed = this.movementHistory.reduce((sum, pos) => sum + pos.speed * 3.6, 0);
    return totalSpeed / this.movementHistory.length;
  },

  calculateAccelerationTime: function() {
    if (!this.accelerationTimes.length) return 0;
    return this.accelerationTimes.reduce((sum, time) => sum + time, 0) / this.accelerationTimes.length;
  },

startRide: function() {
  if (this.isRideActive) {
    // If ride is active, stop it and save session
    this.stop();
    if (this.currentSession) {
      this.saveCurrentSession();
    }
    return;
  }
  
  // Start new ride
  this.isRideActive = true;
  this.rideStartTime = Date.now();
  this.movementHistory = [];
  this.corners = [];
  this.cornerEntrySpeeds = [];
  this.cornerExitSpeeds = [];
  this.elevationHistory = [];
  this.elevationGain = 0;
  this.maxSpeed = 0;
  this.maxLeanAngle = 0;
  this.maxCornerG = 0;
  this.maxCornerSpeed = 0;
  this.accelerationTimes = [];
  
  document.getElementById("startRideBtn").textContent = "Stop & Save Ride";
  document.getElementById("startRideBtn").style.background = "linear-gradient(to bottom, #ff3333, #cc0000)";
  document.getElementById("startRideBtn").disabled = false;
  
  this.watchId = navigator.geolocation.watchPosition(
    pos => this.updatePosition(pos),
    err => this.handleGpsError(err),
    { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
  );
  
  // Auto-start session
  if (!this.currentSession) {
    this.startNewSession();
  }
  
  this.log("Ride started");
},

  updatePosition: function(pos) {
    this.prevPosition = this.lastPosition;
    this.checkAccelerationAchievement();
    this.lastPosition = { lat: pos.coords.latitude, lon: pos.coords.longitude, alt: pos.coords.altitude || 0 };
    this.currentSpeed = pos.coords.speed || 0;
    if (this.currentSpeed > this.maxSpeed) this.maxSpeed = this.currentSpeed * 3.6;
    this.movementHistory.push({ lat: this.lastPosition.lat, lon: this.lastPosition.lon, speed: this.currentSpeed, alt: this.lastPosition.alt, time: Date.now() });

    if (this.prevPosition) {
      const distance = this.calculateDistance(this.prevPosition, this.lastPosition) / 1000;
      this.totalDistance += distance;
      this.todayDistance += distance;
      this.weekDistance += distance;
      this.monthDistance += distance;

      if (this.prevPosition.alt && this.lastPosition.alt && this.lastPosition.alt > this.prevPosition.alt) {
        this.elevationGain += this.lastPosition.alt - this.prevPosition.alt;
      }
      this.elevationHistory.push({ elev: this.lastPosition.alt, time: Date.now() });
    }

    if (this.isRideActive && this.currentSpeed * 3.6 >= this.accelTarget && this.accelerationStartTime && !this.accelerationTimes.some(t => t)) {
      const accelTime = (Date.now() - this.accelerationStartTime) / 1000;
      this.accelerationTimes.push(accelTime);
      this.accelerationStartTime = null;
    } else if (this.currentSpeed * 3.6 < this.accelTarget && !this.accelerationStartTime) {
      this.accelerationStartTime = Date.now();
    }

    this.userMarker.setLatLng([this.lastPosition.lat, this.lastPosition.lon]);
    this.line.addLatLng([this.lastPosition.lat, this.lastPosition.lon]);
    this.map.panTo([this.lastPosition.lat, this.lastPosition.lon]);

    if (this.lockPosition) {
      const distance = this.calculateDistance(this.lastPosition, this.lockPosition);
      document.getElementById("distance").textContent = distance.toFixed(0);
      document.getElementById("accuracy").textContent = pos.coords.accuracy.toFixed(1);
      if (distance < 5 && !this.reachedPointDisplayed) {
        document.getElementById("reachedMessage").style.display = "block";
        this.reachedPointDisplayed = true;
        setTimeout(() => {
          document.getElementById("reachedMessage").style.display = "none";
          this.reachedPointDisplayed = false;
        }, 5000);
        this.stop();
      }
      this.updateDirection();
    }

    if (this.autoLockEnabled) {
      if (this.currentSpeed * 3.6 < this.speedThreshold) {
        if (!this.lastStationaryTime) {
          this.lastStationaryTime = Date.now();
          this.lastStationaryPosition = this.lastPosition;
        } else if (Date.now() - this.lastStationaryTime > parseInt(document.getElementById("stationaryTime").value) * 1000) {
          this.lockCurrentPosition();
          this.toggleAutoLock();
        }
      } else {
        this.lastStationaryTime = null;
        this.lastStationaryPosition = null;
      }
    }

    this.updateWheelAnimation();
    this.updateUI();
    this.startBleep();
  },

  handleGpsError: function(err) {
    this.log(`GPS error: ${err.message}`, true);
    this.updateGpsStatus(`Error: ${err.message}`);
  },

  updateDirection: function() {
    if (!this.lastPosition || !this.lockPosition) return;
    const dLon = this.lockPosition.lon - this.lastPosition.lon;
    const dLat = this.lockPosition.lat - this.lastPosition.lat;
    const angle = Math.atan2(dLon, dLat) * 180 / Math.PI;
    document.getElementById("directionArrow").style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
    document.getElementById("directionStatus").textContent = `Direction: ${angle.toFixed(0)}°`;
  },

  stop: function() {
    if (this.watchId) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
    clearTimeout(this.bleepTimer);
    this.isActive = false;
    this.isRideActive = false;
    document.getElementById("startRideBtn").textContent = "Start Ride";
    document.getElementById("startRideBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
    document.getElementById("muteBtn").disabled = true;
    document.getElementById("lockStatus").textContent = "Lock Status: Not locked";
    document.getElementById("lockStatus").className = "status";
    this.lockPosition = null;
    this.updateWheelAnimation();
    this.log("Tracking stopped");
    if (this.rideStartTime) {
      this.rideHistory.push({
        startTime: this.rideStartTime,
        distance: this.todayDistance,
        maxSpeed: this.maxSpeed,
        avgSpeed: this.calculateAverageSpeed(),
        acceleration: this.calculateAccelerationTime(),
        corners: this.corners.length,
        elevationGain: this.elevationGain
      });
      this.rideStartTime = null;
    }
    this.updateRideHistory();
  },

  resetMetrics: function() {
    this.maxSpeed = 0;
    this.totalDistance = 0;
    this.todayDistance = 0;
    this.weekDistance = 0;
    this.monthDistance = 0;
    this.elevationGain = 0;
    this.corners = [];
    this.cornerEntrySpeeds = [];
    this.cornerExitSpeeds = [];
    this.maxCornerG = 0;
    this.maxCornerSpeed = 0;
    this.accelerationTimes = [];
    this.elevationHistory = [];
    this.updateUI();
    this.log("Metrics reset");
  },

  exportMetrics: function() {
    const data = {
      totalDistance: this.totalDistance,
      todayDistance: this.todayDistance,
      weekDistance: this.weekDistance,
      monthDistance: this.monthDistance,
      maxSpeed: this.maxSpeed,
      avgSpeed: this.calculateAverageSpeed(),
      acceleration: this.calculateAccelerationTime(),
      corners: this.corners,
      elevationGain: this.elevationGain,
      elevationHistory: this.elevationHistory,
      rideHistory: this.rideHistory
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ride_metrics.json';
    a.click();
    URL.revokeObjectURL(url);
    this.log("Metrics exported");
  },

sendEmergencyAlert: function(message = null) {

  if (!this.emergencyEnabled) {
    alert("Emergency features are disabled");
    return;
  }
  const msg = message || `${document.getElementById('emergencyMessage').value} Lat: ${this.lastPosition?.lat.toFixed(6)}, Lon: ${this.lastPosition?.lon.toFixed(6)}`;
  
  this.emergencyContacts.forEach(contact => {
    // Method 1: Open SMS app (works on mobile)
    const smsUrl = `sms:${contact}?body=${encodeURIComponent(msg)}`;
    window.open(smsUrl, '_blank');
    
    // Method 2: For web fallback - use Share API if available
    if (navigator.share) {
      navigator.share({
        title: 'EMERGENCY ALERT',
        text: msg,
        url: window.location.href
      }).catch(err => {
        console.log('Share API failed, using SMS fallback');
        window.open(smsUrl, '_blank');
      });
    }
    
    this.log(`Sending emergency alert to ${contact}: ${msg}`);
  });
  
  // Visual feedback
  document.getElementById('emergencyBtn').textContent = 'ALERT SENT!';
  document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, #00cc66, #00aa55)';
  setTimeout(() => {
    document.getElementById('emergencyBtn').textContent = 'EMERGENCY ALERT';
    document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, var(--error-color), #cc0000)';
  }, 3000);
  
  this.log("Emergency alerts sent to all contacts");
},

testEmergency: function() {
  this.log("Testing emergency alert");
  // For test, just show what would be sent without actually sending
  const testMsg = "TEST ALERT: This is a test emergency message. Lat: " + 
                 (this.lastPosition?.lat.toFixed(6) || 'unknown') + 
                 ", Lon: " + (this.lastPosition?.lon.toFixed(6) || 'unknown');
  
  if (confirm(`Test Emergency Alert:\n\n${testMsg}\n\nOpen SMS app to test?`)) {
    this.sendEmergencyAlert("TEST ALERT: This is a test emergency message.");
  }
},

// Emergency contacts functions:
showContactModal: function() {
  document.getElementById('addContactModal').style.display = 'flex';
  document.getElementById('newContactName').value = '';
  document.getElementById('newContactNumber').value = '';
  document.getElementById('newContactName').focus();
},

closeContactModal: function() {
  document.getElementById('addContactModal').style.display = 'none';
},

addEmergencyContact: function() {
  console.log('Add Emergency Contact clicked');
  this.showContactModal();
},

saveNewContact: function() {
  const name = document.getElementById('newContactName').value.trim();
  const number = document.getElementById('newContactNumber').value.trim();
  
  if (!name) {
    alert('Please enter a contact name');
    return;
  }
  
  if (!number) {
    alert('Please enter a phone number');
    return;
  }

  // Validate phone number (basic validation)
  const cleanNumber = number.replace(/[^\d+]/g, '');
  if (cleanNumber.length < 10) {
    alert('Please enter a valid phone number');
    return;
  }

  // Add contact to array
  this.emergencyContacts.push({
    id: Date.now(), // Unique ID
    name: name,
    number: cleanNumber
  });

  // Save to localStorage
  this.saveContactsToStorage();
  
  // Update UI
  this.updateEmergencyContacts();
  this.closeContactModal();
  
  this.log(`Contact added: ${name} - ${cleanNumber}`);
},

updateEmergencyContacts: function() {
  const list = document.getElementById("emergencyContactList");
  
  if (this.emergencyContacts.length === 0) {
    list.innerHTML = `
      <div style="text-align: center; padding: 20px; color: #aaa;">
        No emergency contacts added yet.<br>
        Click "Add Contact" to add your first contact.
      </div>
    `;
    return;
  }

  list.innerHTML = this.emergencyContacts.map(contact => `
    <div class="contact-item" data-contact-id="${contact.id}">
      <div class="contact-info">
        <strong>${contact.name}</strong><br>
        <span style="font-size: 0.9em; color: #ccc;">${contact.number}</span>
      </div>
      <div class="contact-actions">
        <button onclick="MotoFindBack.callContact('${contact.number}')" title="Call">📞</button>
        <button onclick="MotoFindBack.messageContact('${contact.number}')" title="Message">💬</button>
        <button onclick="MotoFindBack.removeContact(${contact.id})" title="Remove" style="background: #ff3333;">🗑️</button>
      </div>
    </div>
  `).join('');
},

removeContact: function(contactId) {
  if (confirm('Remove this contact?')) {
    this.emergencyContacts = this.emergencyContacts.filter(contact => contact.id !== contactId);
    this.saveContactsToStorage();
    this.updateEmergencyContacts();
    this.log('Contact removed');
  }
},

// Updated sendEmergencyAlert to work with contact objects
sendEmergencyAlert: function(message = null) {
  if (this.emergencyContacts.length === 0) {
    alert('No emergency contacts added! Please add contacts first.');
    this.showContactModal();
    return;
  }

  const msg = message || `${document.getElementById('emergencyMessage').value} Lat: ${this.lastPosition?.lat.toFixed(6)}, Lon: ${this.lastPosition?.lon.toFixed(6)}`;
  
  this.emergencyContacts.forEach(contact => {
    const smsUrl = `sms:${contact.number}?body=${encodeURIComponent(msg)}`;
    window.open(smsUrl, '_blank');
    this.log(`Sending emergency alert to ${contact.name}: ${contact.number}`);
  });

  // Visual feedback
  document.getElementById('emergencyBtn').textContent = 'ALERT SENT!';
  document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, #00cc66, #00aa55)';
  setTimeout(() => {
    document.getElementById('emergencyBtn').textContent = 'EMERGENCY ALERT';
    document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, var(--error-color), #cc0000)';
  }, 3000);
},

// Updated contact functions to work with numbers
callContact: function(phoneNumber) {
  const telUrl = `tel:${phoneNumber}`;
  window.open(telUrl, '_blank');
  this.log(`Calling ${phoneNumber}`);
},

messageContact: function(phoneNumber) {
  const msg = document.getElementById('emergencyMessage').value + 
              ` Lat: ${this.lastPosition?.lat.toFixed(6) || 'unknown'}, Lon: ${this.lastPosition?.lon.toFixed(6) || 'unknown'}`;
  const smsUrl = `sms:${phoneNumber}?body=${encodeURIComponent(msg)}`;
  window.open(smsUrl, '_blank');
  this.log(`Messaging ${phoneNumber}`);
},

// Storage functions
saveContactsToStorage: function() {
  localStorage.setItem('emergencyContacts', JSON.stringify(this.emergencyContacts));
},

loadContactsFromStorage: function() {
  const saved = localStorage.getItem('emergencyContacts');
  if (saved) {
    this.emergencyContacts = JSON.parse(saved);
    this.updateEmergencyContacts();
  }
},

// Background communication with service worker
backgroundComm: {
  async postMessage(type, payload) {
    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      return new Promise((resolve) => {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          resolve(event.data);
        };
        navigator.serviceWorker.controller.postMessage(
          { type, payload },
          [messageChannel.port2]
        );
      });
    }
    return { success: false };
  }
},

// Store data in background
async storeInBackground(data) {
  const result = await this.backgroundComm.postMessage('STORE_BACKGROUND_DATA', data);
  if (result.success) {
    this.log('Data stored for background processing');
  }
},

// Queue emergency alert for background sending
async queueEmergencyForBackground(alertData) {
  const result = await this.backgroundComm.postMessage('QUEUE_EMERGENCY_ALERT', alertData);
  if (result.success) {
    this.log('Emergency alert queued for background sending');
  }
},


// Enhanced crash detection with actual alert sending
triggerCrashAlert: function(deviation = 0) {
    if (!this.emergencyEnabled) return;
    
    document.getElementById('crashStatus').textContent = `CRASH CONFIRMED! Sending alerts...`;
    document.getElementById('crashStatus').className = 'status error';
    
    this.log(`Crash confirmed! ${deviation.toFixed(1)}° deviation from normal position`);
    
    if (this.lastPosition) {
        const message = `🚨 MOTORCYCLE CRASH DETECTED! 

Position deviation: ${deviation.toFixed(1)}° from normal
Location: https://maps.google.com/?q=${this.lastPosition.lat},${this.lastPosition.lon}
Coordinates: ${this.lastPosition.lat.toFixed(6)}, ${this.lastPosition.lon.toFixed(6)}
Speed at detection: ${(this.currentSpeed * 3.6).toFixed(1)} km/h
Time: ${new Date().toLocaleString()}

${document.getElementById('emergencyMessage').value}`;
        
        // Send emergency alerts
        this.sendEmergencyAlert(message);
        
        // Make emergency call after short delay
        setTimeout(() => {
            if (confirm(`CRASH DETECTED! \n\nCall emergency services?`)) {
                window.open('tel:112', '_blank');
            }
        }, 2000);
        
    } else {
        this.log('Crash detected but no GPS position available', true);
        document.getElementById('crashStatus').textContent = 'Crash detected - No GPS position';
    }
},

callEmergency: function() {
  // Determine local emergency number based on region or let user choose
  const emergencyNumbers = ['112', '911', '999'];
  const number = emergencyNumbers[0]; // Use first one, or implement region detection
  
  if (confirm(`Call emergency services (${number})?`)) {
    window.open(`tel:${number}`, '_blank');
  }
},

saveCalibrationToStorage: function() {
    const calibrationData = {
        leanOffset: this.leanOffset,
        normalBeta: this.normalBeta,
        crashThreshold: this.crashThreshold,
        betaTolerance: this.betaTolerance,
        calibratedAt: Date.now()
    };
    localStorage.setItem('sensorCalibration', JSON.stringify(calibrationData));
    this.log('Sensor calibration saved to storage');
},

loadCalibrationFromStorage: function() {
  const saved = localStorage.getItem('sensorCalibration');
  if (saved) {
    try {
      const calibration = JSON.parse(saved);
      this.leanOffset = calibration.leanOffset || 0;
      this.normalBeta = calibration.normalBeta;
      this.crashThreshold = calibration.crashThreshold || 45;
      this.betaTolerance = calibration.betaTolerance || 15;
      
      // UPDATE THE DISPLAY
      this.updateCalibrationDisplay();
      
      document.getElementById('calibrateStatus').textContent = 
        `Calibration loaded | Normal position: ${this.normalBeta.toFixed(1)}°`;
      document.getElementById('calibrateStatus').className = 'status success';
      
      this.log('Sensor calibration loaded from storage');
    } catch (error) {
      this.log('Error loading calibration: ' + error.message, true);
    }
  } else {
    // Initialize with defaults if no saved calibration
    this.leanOffset = 0;
    this.crashThreshold = 45;
    this.betaTolerance = 15;
    this.updateCalibrationDisplay();
  }
},

// Maintenance unit toggle
toggleMaintenanceUnit: function(unit) {
  const kmSettings = document.getElementById('kmSettings');
  const weekSettings = document.getElementById('weekSettings');
  
  if (unit === 'km') {
    kmSettings.style.display = 'block';
    weekSettings.style.display = 'none';
  } else {
    kmSettings.style.display = 'none';
    weekSettings.style.display = 'block';
  }
},

// Updated save maintenance item
saveMaintenanceItem: function() {
  const name = document.getElementById("newMaintenanceName").value.trim();
  const unit = document.querySelector('input[name="maintenanceUnit"]:checked').value;
  
  let interval, progress, unitLabel;
  
  if (unit === 'km') {
    interval = parseInt(document.getElementById("newMaintenanceInterval").value);
    progress = 0; // Start at 0 km
    unitLabel = 'km';
  } else {
    interval = parseInt(document.getElementById("newMaintenanceWeeks").value);
    progress = 0; // Start at 0 weeks passed
    unitLabel = 'weeks';
  }
  
  if (!name) {
    alert('Please enter a maintenance item name');
    return;
  }
  
  if (!interval || interval <= 0) {
    alert('Please set a valid interval');
    return;
  }

  this.maintenanceItems.push({ 
    name, 
    interval, 
    progress, 
    unit: unitLabel,
    createdAt: Date.now(),
    lastReset: Date.now()
  });
  
  this.updateMaintenanceList();
  
  // Clear form
  document.getElementById("newMaintenanceName").value = "";
  document.getElementById("newMaintenanceInterval").value = "5000";
  document.getElementById("newMaintenanceWeeks").value = "4";
  document.getElementById("intervalValue").textContent = "5000 km";
  document.getElementById("weeksValue").textContent = "4 weeks";
  
  this.log(`Maintenance item added: ${name} - every ${interval} ${unitLabel}`);
},

// Enhanced maintenance list display
updateMaintenanceList: function() {
  const list = document.getElementById("maintenanceList");
  
  if (this.maintenanceItems.length === 0) {
    list.innerHTML = `
      <div style="text-align: center; padding: 20px; color: #aaa;">
        No maintenance items added yet.<br>
        Add your first maintenance item above.
      </div>
    `;
    return;
  }

  list.innerHTML = this.maintenanceItems.map((item, index) => {
    const progressPercent = (item.progress / item.interval) * 100;
    const progressColor = progressPercent < 70 ? 'var(--success-color)' : 
                         progressPercent < 90 ? 'var(--warning-color)' : 'var(--error-color)';
    
    let timeInfo = '';
    if (item.unit === 'weeks') {
      const weeksPassed = Math.floor((Date.now() - item.lastReset) / (7 * 24 * 60 * 60 * 1000));
      timeInfo = `<div style="font-size: 0.8em; color: #aaa;">${weeksPassed} weeks passed</div>`;
    } else {
      timeInfo = `<div style="font-size: 0.8em; color: #aaa;">${item.progress}/${item.interval} km</div>`;
    }
    
    return `
      <div class="maintenance-item" data-index="${index}">
        <div style="flex: 1;">
          <div style="font-weight: bold; margin-bottom: 5px;">${item.name}</div>
          <div style="font-size: 0.9em; color: #ccc;">Every ${item.interval} ${item.unit}</div>
          ${timeInfo}
        </div>
        <div class="maintenance-progress">
          <div class="maintenance-progress-bar" style="width: ${progressPercent}%; background: ${progressColor};"></div>
        </div>
        <div style="margin-left: 10px;">
          <button onclick="MotoFindBack.resetMaintenanceItem(${index})" title="Reset" style="background: var(--accent-color);">🔄</button>
          <button onclick="MotoFindBack.removeMaintenanceItem(${index})" title="Remove" style="background: #ff3333;">🗑️</button>
        </div>
      </div>
    `;
  }).join('');
},

// Reset individual maintenance item
resetMaintenanceItem: function(index) {
  if (index >= 0 && index < this.maintenanceItems.length) {
    this.maintenanceItems[index].progress = 0;
    this.maintenanceItems[index].lastReset = Date.now();
    this.updateMaintenanceList();
    this.log(`Reset maintenance item: ${this.maintenanceItems[index].name}`);
  }
},

// Remove individual maintenance item
removeMaintenanceItem: function(index) {
  if (index >= 0 && index < this.maintenanceItems.length && confirm('Remove this maintenance item?')) {
    const itemName = this.maintenanceItems[index].name;
    this.maintenanceItems.splice(index, 1);
    this.updateMaintenanceList();
    this.log(`Removed maintenance item: ${itemName}`);
  }
},

// Update maintenance progress based on distance or time
updateMaintenanceProgress: function() {
  const now = Date.now();
  
  this.maintenanceItems.forEach(item => {
    if (item.unit === 'km') {
      // Update based on distance (you'll need to track distance since last reset)
      // This would need to be integrated with your distance tracking
    } else {
      // Update based on time (weeks)
      const weeksPassed = Math.floor((now - item.lastReset) / (7 * 24 * 60 * 60 * 1000));
      item.progress = weeksPassed;
    }
  });
  
  this.updateMaintenanceList();
},


  saveMaintenanceItem: function() {
    const name = document.getElementById("newMaintenanceName").value;
    const interval = parseInt(document.getElementById("newMaintenanceInterval").value);
    if (name && interval) {
      this.maintenanceItems.push({ name, interval, progress: 0 });
      this.updateMaintenanceList();
      document.getElementById("newMaintenanceName").value = "";
      document.getElementById("newMaintenanceInterval").value = "";
      this.log(`Maintenance item added: ${name}`);
    }
  },

  resetMaintenance: function() {
    this.maintenanceItems = [];
    this.updateMaintenanceList();
    this.log("Maintenance items reset");
  },

  updateMaintenanceList: function() {
    const list = document.getElementById("maintenanceList");
    list.innerHTML = this.maintenanceItems.map(item => `
      <div class="maintenance-item">
        <div>${item.name}</div>
        <div class="maintenance-progress">
          <div class="maintenance-progress-bar" style="width: ${(item.progress / item.interval) * 100}%"></div>
        </div>
        <div>${item.progress}/${item.interval} km</div>
      </div>
    `).join('') || `
      <div class="maintenance-item">
        <div>Oil Change</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 30%"></div></div>
        <div>2000/5000 km</div>
      </div>
      <div class="maintenance-item">
        <div>Tire Pressure</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 70%"></div></div>
        <div>Check weekly</div>
      </div>
      <div class="maintenance-item">
        <div>Chain Lubrication</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 50%"></div></div>
        <div>500/1000 km</div>
      </div>
    `;
  },

  updateRideHistory: function() {
    const history = document.getElementById("rideHistory");
    history.innerHTML = this.rideHistory.map(ride => `
      <div>Ride on ${new Date(ride.startTime).toLocaleString()}: ${ride.distance.toFixed(1)} km, Max Speed: ${ride.maxSpeed.toFixed(1)} km/h, Avg Speed: ${ride.avgSpeed.toFixed(1)} km/h, 0-${this.accelTarget} km/h: ${ride.acceleration.toFixed(2)} s, Corners: ${ride.corners}, Elevation Gain: ${ride.elevationGain.toFixed(0)} m</div>
    `).join('') || "No ride history yet.";
  },

  loadData: function() {
    this.log("Loading saved data (placeholder)");
  },

  log: function(message, isError = false) {
    const debug = document.getElementById("debug");
    debug.innerHTML += `<div style="color: ${isError ? '#ff3333' : '#aaa'}">${new Date().toLocaleTimeString()}: ${message}</div>`;
    debug.scrollTop = debug.scrollHeight;
  }
};
      
MotoFindBack.init();
</script> </div>
  </body>
</html>
