<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spin - Motorcycle GPS Locator</title>
    <!-- Leaflet Map CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
    :root {
      --primary-color: #ff6600;
      --secondary-color: #333;
      --accent-color: #00ccff;
      --text-color: #fff;
      --warning-color: #ffcc00;
      --error-color: #ff3333;
      --success-color: #00cc66;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      color: var(--text-color);
      text-align: center;
      padding: 1em;
      max-width: 1000px;
      margin: 0 auto;
    }
    
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
      position: relative;
    }
    
    .app-title {
      font-size: 2.2em;
      margin: 0;
      color: var(--primary-color);
      text-shadow: 0 0 5px rgba(255, 102, 0, 0.3);
    }
    
    .wheel-container {
      position: relative;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .spinning-wheel {
      width: 50px;
      height: 50px;
      position: relative;
      animation: wheel-spin 3s linear infinite;
    }
    
    .wheel-outer {
      fill: none;
      stroke: var(--primary-color);
      stroke-width: 3;
      stroke-dasharray: 5;
      animation: wheel-dash 1s linear infinite;
    }
    
    .wheel-inner {
      fill: none;
      stroke: var(--accent-color);
      stroke-width: 2;
    }
    
    .wheel-spoke {
      stroke: var(--accent-color);
      stroke-width: 2;
      transform-origin: center;
    }
    
    .spoke-1 { animation: spoke-spin 4s linear infinite; }
    .spoke-2 { animation: spoke-spin 3s linear infinite reverse; }
    .spoke-3 { animation: spoke-spin 5s linear infinite; }
    
    @keyframes wheel-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes wheel-dash {
      to {
        stroke-dashoffset: -10;
      }
    }
    
    @keyframes spoke-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .wheel-pulse {
      fill: var(--primary-color);
      animation: wheel-pulse 2s ease-in-out infinite;
    }
    
    @keyframes wheel-pulse {
      0%, 100% { opacity: 0.7; transform: scale(0.95); }
      50% { opacity: 1; transform: scale(1); }
    }
    
    .dashboard {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .dashboard-item {
      background: rgba(40, 40, 40, 0.7);
      border-radius: 10px;
      padding: 10px;
      border: 1px solid #444;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    .dashboard-value {
      font-size: 1.8em;
      font-weight: bold;
      color: var(--accent-color);
      margin: 5px 0;
    }
    
    .dashboard-label {
      font-size: 0.9em;
      color: #aaa;
    }
    
    .panel {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid #444;
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .control-group {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    
    input, button, select {
      margin: 0.5em;
      padding: 0.7em 1em;
      font-size: 1em;
      background: #333;
      color: var(--text-color);
      border: 1px solid #555;
      border-radius: 6px;
      transition: all 0.3s ease;
    }
    
    button {
      cursor: pointer;
      background: linear-gradient(to bottom, #444, #333);
      font-weight: bold;
    }
    
    button:hover:not(:disabled) {
      background: linear-gradient(to bottom, #555, #444);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .primary-btn {
      background: linear-gradient(to bottom, var(--primary-color), #e55d00);
      color: #fff;
      border: 1px solid #ff8533;
    }
    
    .secondary-btn {
      background: linear-gradient(to bottom, #555, #444);
      color: #fff;
    }
    
    .warning-btn {
      background: linear-gradient(to bottom, var(--warning-color), #e6b800);
      color: #000;
    }
    
    .emergency-btn {
      background: linear-gradient(to bottom, var(--error-color), #cc0000);
      color: #fff;
      animation: pulse-emergency 2s infinite;
    }
    
    @keyframes pulse-emergency {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    #debug {
      text-align: left;
      margin: 20px auto;
      padding: 10px;
      border: 1px dashed #555;
      color: #aaa;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9em;
      background: rgba(20, 20, 20, 0.8);
      border-radius: 5px;
    }
    
    .status {
      margin: 10px 0;
      padding: 8px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .success {
      background: rgba(0, 204, 102, 0.2);
      border: 1px solid var(--success-color);
      color: var(--success-color);
    }
    
    .error {
      background: rgba(255, 51, 51, 0.2);
      border: 1px solid var(--error-color);
      color: var(--error-color);
    }
    
    .warning {
      background: rgba(255, 204, 0, 0.2);
      border: 1px solid var(--warning-color);
      color: var(--warning-color);
    }
    
    .speed-indicator {
      font-size: 1em;
      margin-top: 5px;
      color: var(--accent-color);
      font-weight: bold;
    }
    
    .auto-lock-settings {
      margin-top: 10px;
      padding: 10px;
      border-top: 1px dashed #555;
    }
    
    .slider-label {
      display: inline-flex;
      align-items: center;
      margin-left: 5px;
      color: var(--accent-color);
    }
    
    .direction-container {
      position: relative;
      width: 100px;
      height: 100px;
      margin: 10px auto;
    }
    
    #directionArrow {
      width: 0; 
      height: 0; 
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 40px solid var(--primary-color);
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: 50% 0;
      transform: translate(-50%, -50%) rotate(0deg);
      transition: transform 0.3s ease;
    }
    
    .direction-circle {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 1px dashed var(--accent-color);
      border-radius: 50%;
      top: 0;
      left: 0;
      box-sizing: border-box;
    }
    
    .direction-status {
      font-size: 0.9em;
      margin-top: 5px;
    }
    
    #map {
      height: 250px;
      width: 100%;
      background: #222;
      border: 1px solid #555;
      border-radius: 8px;
      margin-top: 10px;
    }
    
    .user-marker, .lock-marker {
      font-size: 20px;
      text-shadow: 0 0 3px #000;
    }
    
    .leaflet-control-attribution {
      background: rgba(0, 0, 0, 0.7) !important;
      color: #aaa !important;
      font-family: monospace;
      font-size: 0.8em;
    }
    
    .reached-message {
      color: var(--success-color);
      font-weight: bold;
      animation: pulse 1.5s infinite;
    }
    
    button.muted {
      background: #f00 !important;
      color: #fff !important;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .lean-container {
      position: relative;
      width: 200px;
      height: 100px;
      margin: 10px auto;
      background: rgba(50, 50, 50, 0.7);
      border-radius: 100px 100px 0 0;
      overflow: hidden;
    }
    
    .lean-bike {
      position: absolute;
      width: 40px;
      height: 60px;
      background: var(--primary-color);
      border-radius: 10px 10px 0 0;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      transition: transform 0.1s ease; /* Faster transition for lean angle */
    }
    
    .lean-scale {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: space-around;
    }
    
    .lean-mark {
      width: 1px;
      height: 10px;
      background: #666;
      position: relative;
      top: 10px;
    }
    
    .lean-mark:nth-child(6) {
      height: 20px;
      background: var(--accent-color);
    }
    
    .lean-value {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-weight: bold;
      color: var(--accent-color);
    }
    
    .tabs {
      display: flex;
      margin-bottom: 10px;
      border-bottom: 1px solid #444;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
      margin-right: 5px;
      background: rgba(50, 50, 50, 0.7);
    }
    
    .tab.active {
      background: rgba(30, 30, 30, 0.9);
      border-color: #444;
      border-bottom: 1px solid rgba(30, 30, 30, 0.9);
      margin-bottom: -1px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .maintenance-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin: 5px 0;
      background: rgba(50, 50, 50, 0.5);
      border-radius: 5px;
    }
    
    .maintenance-progress {
      height: 10px;
      background: #333;
      border-radius: 5px;
      flex-grow: 1;
      margin: 0 10px;
      overflow: hidden;
    }
    
    .maintenance-progress-bar {
      height: 100%;
      background: linear-gradient(to right, var(--success-color), var(--warning-color), var(--error-color));
      border-radius: 5px;
    }
    
    .emergency-panel {
      background: rgba(204, 0, 0, 0.2);
      border: 1px solid var(--error-color);
    }
    
    .emergency-contacts {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin: 10px 0;
    }
    
    .contact-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: rgba(50, 50, 50, 0.7);
      border-radius: 5px;
      min-width: 120px;
    }
    
    .collapsible {
      cursor: pointer;
      padding: 10px;
      border: none;
      text-align: center;
      outline: none;
      font-size: 1em;
      color: var(--primary-color);
      background: transparent;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .collapsible:after {
      content: '▼';
      font-size: 0.8em;
      margin-left: 5px;
      transition: transform 0.2s;
    }
    
    .collapsible.active:after {
      transform: rotate(180deg);
    }
    
    .collapsible-content {
      padding: 0 10px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.2s ease-out;
    }
    
    .corner-analysis {
      margin: 10px 0;
      padding: 10px;
      background: rgba(50, 50, 50, 0.5);
      border-radius: 5px;
      text-align: left;
    }
    
 
      
      /* Triple-tap overlay styles */
.triple-tap-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  z-index: 10000;
  display: none;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

.triple-tap-overlay.active {
  display: flex;
}

.enlarged-wheel {
  width: 200px;
  height: 200px;
  position: relative;
  margin-bottom: 30px;
}

.enlarged-wheel .wheel-outer {
  fill: none;
  stroke: var(--primary-color);
  stroke-width: 4;
  stroke-dasharray: 5;
  animation: wheel-dash 1s linear infinite;
}

.enlarged-wheel .wheel-inner {
  fill: none;
  stroke: var(--accent-color);
  stroke-width: 3;
}

.enlarged-wheel .wheel-spoke {
  stroke: var(--accent-color);
  stroke-width: 3;
  transform-origin: center;
}

.enlarged-wheel .wheel-pulse {
  fill: var(--primary-color);
  animation: wheel-pulse 2s ease-in-out infinite;
}

.overlay-stats {
  text-align: center;
  background: rgba(40, 40, 40, 0.8);
  padding: 20px;
  border-radius: 15px;
  border: 2px solid var(--primary-color);
  min-width: 250px;
}

.overlay-stat-item {
  margin: 10px 0;
  font-size: 1.2em;
}

.overlay-stat-value {
  color: var(--accent-color);
  font-weight: bold;
  font-size: 1.4em;
}

.overlay-close-hint {
  position: absolute;
  bottom: 30px;
  color: #aaa;
  font-size: 0.9em;
}
      
      /* Session styles */
.session-info {
  background: rgba(50, 50, 50, 0.7);
  padding: 15px;
  border-radius: 8px;
  margin: 10px 0;
  border-left: 4px solid var(--primary-color);
}

.session-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  font-size: 0.9em;
}

.session-stats div {
  padding: 5px 0;
}

.session-history {
  max-height: 400px;
  overflow-y: auto;
}

.session-item {
  background: rgba(50, 50, 50, 0.5);
  border: 1px solid #444;
  border-radius: 8px;
  padding: 15px;
  margin: 10px 0;
  transition: all 0.3s ease;
}

.session-item:hover {
  background: rgba(60, 60, 60, 0.7);
  border-color: #555;
}

.session-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.session-header strong {
  color: var(--accent-color);
  font-size: 1.1em;
}

.session-date {
  color: #aaa;
  font-size: 0.9em;
}

.session-details {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 0.9em;
  color: #ccc;
}

.session-actions {
  display: flex;
  gap: 5px;
}

.session-actions button {
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  background: #555;
  color: white;
  cursor: pointer;
  transition: background 0.3s;
}

.session-actions button:hover {
  background: #666;
}
      
      .elevation-profile-container {
  margin: 10px 0;
  padding: 10px;
  background: rgba(50, 50, 50, 0.5);
  border-radius: 5px;
}

.elevation-profile {
  height: 120px;
  width: 100%;
  background: #333;
  border-radius: 5px;
  margin: 10px 0;
  position: relative;
  overflow: hidden;
}

.elevation-profile canvas {
  width: 100% !important;
  height: 100% !important;
  display: block;
}

.session-notes {
  margin-top: 10px;
  padding: 10px;
  background: rgba(40, 40, 40, 0.5);
  border-radius: 4px;
  font-size: 0.9em;
  color: #aaa;
  border-left: 3px solid var(--warning-color);
}
    .recording-instructions {
  background: rgba(50, 50, 50, 0.5);
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
  border-left: 3px solid var(--accent-color);
}

.calibration-info {
  background: rgba(40, 40, 40, 0.7);
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
}

.calibration-info div {
  margin: 5px 0;
  font-size: 0.9em;
}

#startRecordingBtn.recording {
  animation: pulse 1s infinite;
  background: linear-gradient(to bottom, #ff3333, #cc0000) !important;
}
      
    @media (max-width: 768px) {
      .dashboard {
        grid-template-columns: 1fr;
      }
      
      .app-header {
        flex-direction: column;
      }
      
      .control-group {
        flex-direction: column;
        align-items: center;
      }
      
      .wheel-container {
        margin-top: 10px;
      }
    }
  </style>
  </head>
  <body> <!-- Triple Tap Overlay -->
    <div class="triple-tap-overlay" id="tripleTapOverlay">
      <div class="enlarged-wheel">
        <svg viewBox="0 0 100 100">
          <circle class="wheel-outer" cx="50" cy="50" r="40"></circle>
          <circle class="wheel-inner" cx="50" cy="50" r="25"></circle>
          <line class="wheel-spoke spoke-1" x1="50" y1="50" x2="75" y2="50"></line>
          <line class="wheel-spoke spoke-2" x1="50" y1="50" x2="50" y2="25"></line>
          <line class="wheel-spoke spoke-3" x1="50" y1="50" x2="30" y2="70"></line>
          <circle class="wheel-pulse" cx="50" cy="50" r="8"></circle> </svg> </div>
      <div class="overlay-stats">
        <div class="overlay-stat-item"> Average Speed: <span class="overlay-stat-value"
            id="overlayAvgSpeed">--
            km/h</span> </div>
        <div class="overlay-stat-item"> Current Lean: <span class="overlay-stat-value"
            id="overlayLeanAngle">--°</span>
        </div>
        <div class="overlay-stat-item"> Max Lean: <span class="overlay-stat-value"
            id="overlayMaxLean">--°</span>
        </div>
        <div class="overlay-stat-item"> Current Speed: <span class="overlay-stat-value"
            id="overlayCurrentSpeed">--
            km/h</span> </div>
      </div>
      <div class="overlay-close-hint">Tap anywhere to close</div>
    </div>
    <div class="app-header">
      <h1 class="app-title">Spin</h1>
      <div class="wheel-container">
        <svg class="spinning-wheel" viewBox="0 0 100 100">
          <circle class="wheel-outer" cx="50" cy="50" r="40"></circle>
          <circle class="wheel-inner" cx="50" cy="50" r="25"></circle>
          <line class="wheel-spoke spoke-1" x1="50" y1="50" x2="75" y2="50"></line>
          <line class="wheel-spoke spoke-2" x1="50" y1="50" x2="50" y2="25"></line>
          <line class="wheel-spoke spoke-3" x1="50" y1="50" x2="30" y2="70"></line>
          <circle class="wheel-pulse" cx="50" cy="50" r="8"></circle> </svg> </div>
    </div>
    <div class="dashboard">
      <div class="dashboard-item">
        <div class="dashboard-label">Current Speed</div>
        <div class="dashboard-value" id="currentSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Speed</div>
        <div class="dashboard-value" id="maxSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Average Speed</div>
        <div class="dashboard-value" id="avgSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Current Lean Angle</div>
        <div class="dashboard-value" id="leanAngle">--°</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Today's Distance</div>
        <div class="dashboard-value" id="todayDistance">-- km</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Elevation Gain</div>
        <div class="dashboard-value" id="elevationGain">-- m</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Cornering Speed</div>
        <div class="dashboard-value" id="maxCornerSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Corner G</div>
        <div class="dashboard-value" id="maxCornerG">-- g</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">0-100 km/h</div>
        <div class="dashboard-value" id="accelerationTime">-- s</div>
      </div>
    </div>
    <div class="tabs">
      <div class="tab active" data-tab="metrics">Metrics</div>
      <div class="tab" data-tab="navigation">Nav</div>
      <div class="tab" data-tab="emergency">SOS</div>
      <div class="tab" data-tab="maintenance">Upkeep</div>
    </div>
    <div class="tab-content active" id="metrics-tab">
      <div class="panel">
        <h2>Ride Metrics</h2>
        <!-- Add to Metrics tab, near the top -->
        <div class="panel">
          <h3>Ride Session Management</h3>
          <div class="control-group"> <button id="startSessionBtn" class="primary-btn"
              onclick="MotoFindBack.startNewSession()">
              🏁 Start New Session </button> <button id="startRideBtn" class="primary-btn">Start
              Ride</button> <button id="saveSessionBtn" class="secondary-btn" onclick="MotoFindBack.saveCurrentSession()">
              💾 Save Session </button> <button id="quickSaveBtn" class="secondary-btn"
              onclick="MotoFindBack.quickSaveSession()">
              ⚡ Quick Save </button> <button id="exportSessionBtn" class="secondary-btn"
              onclick="MotoFindBack.exportSession()">
              📤 Export Current </button> </div>
          <div id="sessionInfo" class="session-info" style="display: none;">
            <h4>Current Session</h4>
            <div class="session-stats">
              <div>Name: <span id="sessionName">--</span></div>
              <div>Duration: <span id="sessionDuration">--</span></div>
              <div>Distance: <span id="sessionDistance">--</span></div>
              <div>Max Speed: <span id="sessionMaxSpeed">--</span></div>
              <div>Corners: <span id="sessionCorners">--</span></div>
            </div>
          </div>
        </div>
        <!-- Session History Panel -->
        <div class="panel">
          <h3>Session History</h3>
          <div id="sessionHistoryList" class="session-history">
            <div style="text-align: center; color: #aaa; padding: 20px;"> No
              saved sessions yet </div>
          </div>
        </div>
        <!-- Add this after the Session Management panel -->
        <div class="panel">
          <h3>📊 General Statistics (All Sessions)</h3>
          <div class="dashboard">
            <div class="dashboard-item">
              <div class="dashboard-label">Total Distance</div>
              <div class="dashboard-value" id="statsTotalDistance">0 km</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Speed</div>
              <div class="dashboard-value" id="statsMaxSpeedAll">0 km/h</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Lean Angle</div>
              <div class="dashboard-value" id="statsMaxLeanAll">0°</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Elevation Gain</div>
              <div class="dashboard-value" id="statsMaxElevationAll">0 m</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Corner Speed</div>
              <div class="dashboard-value" id="statsMaxCornerSpeedAll">0 km/h</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Max Corner G</div>
              <div class="dashboard-value" id="statsMaxCornerGAll">0 g</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Best 0-60 km/h</div>
              <div class="dashboard-value" id="statsBest0to60">-- s</div>
            </div>
            <div class="dashboard-item">
              <div class="dashboard-label">Best 0-100 km/h</div>
              <div class="dashboard-value" id="statsBest0to100">-- s</div>
            </div>
          </div>
          <div class="control-group" style="margin-top: 15px;"> <button onclick="MotoFindBack.updateGeneralStatistics()"
              class="secondary-btn">Refresh
              Stats</button> <button onclick="MotoFindBack.exportAllStatistics()"
              class="secondary-btn">Export
              All Data</button> <button onclick="MotoFindBack.clearAllStatistics()"
              class="secondary-btn"
              style="background: var(--error-color);">Clear
              All Data</button> </div>
        </div>
        <button id="resetMetricsBtn" class="secondary-btn">Reset Metrics</button>
        <button id="exportMetricsBtn" class="secondary-btn">Export Data</button>
      </div>
    <div class="setting-item">
  <h4>Acceleration Popup</h4>
  <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
    <label>Target Speed:</label>
    <input type="range" id="accelTarget" min="20" max="200" value="100" style="flex: 1;">
    <span id="accelTargetValue">100 km/h</span>
  </div>
  <div style="margin: 10px 0;">
    <button onclick="MotoFindBack.testAccelerationPopup()" class="secondary-btn">Test Popup</button>
    <button onclick="MotoFindBack.hideAccelerationPopup()" class="secondary-btn">Clear Popup</button>
  </div>
</div>
      <div class="lean-container">
        <div class="lean-scale">
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
          <div class="lean-mark"></div>
        </div>
        <div class="lean-bike" id="leanBike"></div>
        <div class="lean-value" id="leanValue">0°</div>
      </div>
      <div class="corner-analysis">
        <h3>Cornering Analysis</h3>
        <p>Current Corner G: <span id="currentCornerG">0 g</span></p>
        <p>Max Corner Speed: <span id="currentMaxCornerSpeed">0 km/h</span></p>
        <p>Avg Corner Lean: <span id="avgCornerLean">0°</span></p>
        <div id="cornerList">No corners detected yet.</div>
      </div>
      <div class="elevation-profile-container">
        <h3>Elevation Profile</h3>
        <div class="elevation-profile"> <canvas id="elevationCanvas"></canvas>
        </div>
        <p>Total Elevation Gain: <span id="totalElevationGain">0 m</span></p>
      </div>
      <div class="control-group">
        <div class="control-item">
          <h3>Distance Statistics</h3>
          <div>Today: <span id="statsToday">0 km</span></div>
          <div>This Week: <span id="statsWeek">0 km</span></div>
          <div>This Month: <span id="statsMonth">0 km</span></div>
          <div>Total: <span id="statsTotal">0 km</span></div>
        </div>
        <div class="control-item">
          <h3>Speed Statistics</h3>
          <div>Current: <span id="statsCurrentSpeed">0 km/h</span></div>
          <div>Average: <span id="statsAvgSpeed">0 km/h</span></div>
          <div>Max: <span id="statsMaxSpeed">0 km/h</span></div>
          <div>0-100 km/h: <span id="statsAcceleration">-- s</span></div>
        </div>
      </div>
      <!-- Add to Metrics tab -->
      <div class="panel">
        <h3>Engine Sound Analysis</h3>
        <div class="control-group"> <button id="startEngineAnalysis" class="primary-btn">Start
            Engine Analysis</button> <button id="calibrateEngine" class="secondary-btn">Calibrate
            Engine</button> </div>
        <div class="dashboard">
          <div class="dashboard-item">
            <div class="dashboard-label">Engine RPM</div>
            <div class="dashboard-value" id="engineRPM">--</div>
          </div>
          <div class="dashboard-item">
            <div class="dashboard-label">Estimated Gear</div>
            <div class="dashboard-value" id="engineGear">--</div>
          </div>
          <div class="dashboard-item">
            <div class="dashboard-label">Engine Health</div>
            <div class="dashboard-value" id="engineHealth">--</div>
          </div>
          <div class="dashboard-item">
            <div class="dashboard-label">Sound Level</div>
            <div class="dashboard-value" id="engineVolume">-- dB</div>
          </div>
        </div>
        <div class="control-group">
          <div class="control-item">
            <h4>Shift Analysis</h4>
            <div>Total Shifts: <span id="totalShifts">0</span></div>
            <div>Last Shift Quality: <span id="lastShiftQuality">--</span></div>
            <div>Avg Shift RPM: <span id="avgShiftRPM">--</span></div>
          </div>
        </div>
        <!-- Replace the calibration section with this -->
        <div class="control-item">
          <h4>Impulse Response Calibration</h4>
          <div class="control-group"> <button id="startRecordingBtn" class="primary-btn"
              onclick="MotoFindBack.startRecordingCalibration()">
              🎤 Record Engine Sample </button> <button class="secondary-btn"
              onclick="MotoFindBack.stopRecordingCalibration()">
              Stop Recording </button> </div>
          <div class="recording-instructions">
            <p><strong>How to calibrate:</strong></p>
            <ol style="text-align: left; font-size: 0.9em; color: #ccc;">
              <li>Start engine analysis</li>
              <li>Click "Record Engine Sample"</li>
              <li>Rev engine steadily for 3 seconds</li>
              <li>System will auto-analyze your engine sound</li>
            </ol>
          </div>
          <div class="calibration-info">
            <div>Bike Profile: <span id="bikeProfileName">Uncalibrated</span></div>
            <div>Calibration: <span id="calibrationStatus">Not calibrated</span></div>
            <div>Detected Range: <span id="detectedRange">--</span></div>
            <div>Calibration Factor: <span id="calibrationMultiplier">--</span></div>
          </div>
        </div>
        <!-- Add manual override section -->
        <div class="control-item">
          <h4>Manual Calibration Override</h4>
          <label>Reference RPM: <span id="referenceRpmValue">0</span></label> <input
            id="referenceRpm"
            min="1000"
            max="12000"
            step="100"
            value="5000"
            oninput="MotoFindBack.updateReferenceRPM(this.value)"
            type="range">
          <label>Volume Threshold: <span id="volumeThresholdValue">20</span> dB</label>
          <input id="volumeThreshold" min="1" max="50" step="1" value="20" oninput="MotoFindBack.updateVolumeThreshold(this.value)"
            type="range">
          <button onclick="MotoFindBack.applyManualCalibration()" class="secondary-btn">
            Apply Manual Calibration </button>
        </div>
        <div class="control-item">
          <h4>Debug Info</h4>
          <div>Microphone Status: <span id="micStatus">Not Started</span></div>
          <div>Dominant Frequency: <span id="debugFreq">0</span> Hz</div>
          <div>Max Volume: <span id="debugVolume">0</span></div>
          <div>Total Energy: <span id="debugEnergy">0</span></div>
          <button onclick="MotoFindBack.stopEngineAnalysis()" class="secondary-btn">Stop
            Analysis</button>
        </div>
        <!-- Real-time frequency visualization -->
        <div class="control-item">
          <h4>Sound Spectrum</h4>
          <canvas id="frequencyCanvas" width="100%" height="100" style="background: #222; border-radius: 5px;"></canvas>
        </div>
      </div>
      <div class="panel">
        <h3>Cornering Analysis</h3>
        <!-- Add this canvas for the corner chart --> <canvas id="cornerChart"
          width="100%"
          height="200"></canvas>
        <!-- Your existing corner analysis content -->
        <p>Current Corner G: <span id="currentCornerG">0 g</span></p>
        <p>Max Corner Speed: <span id="currentMaxCornerSpeed">0 km/h</span></p>
        <p>Avg Corner Lean: <span id="avgCornerLean">0°</span></p>
        <p>Avg Corner Entry Speed: <span id="avgCornerEntrySpeed">0 km/h</span></p>
        <div id="cornerList">No corners detected yet.</div>
      </div>
      <div class="control-item">
        <h3>Ride History</h3>
        <div id="rideHistory" style="max-height: 200px; overflow-y: auto; text-align: left; padding: 10px; background: rgba(40,40,40,0.7); border-radius: 5px;">
          No ride history yet. </div>
      </div>
    </div>
    <div class="tab-content" id="navigation-tab">
      <div class="panel">
        <h2>GPS Navigation</h2>
        <p class="warning">LOCK POSITION</p>
        <div class="control-group"> <button id="testBtn" class="primary-btn">Lock
            Position</button> <button id="calibrateBtn" class="secondary-btn">Calibrate
            Sensors</button> <button id="autoLockBtn" class="secondary-btn" disabled="disabled">Auto-Lock
            Mode</button> <button id="muteBtn" class="secondary-btn" disabled="disabled">Mute
            Sound</button> <button id="stopBtn" class="secondary-btn" disabled="disabled">Stop</button>
        </div>
        <div id="autoLockSettings" style="display: none;">
          <div class="control-group">
            <div class="control-item"> <label for="stationaryTime">Stationary
                Confirmation Time</label>
              <div> <input id="stationaryTime" value="30" min="5" max="60" type="range">
                <span id="stationaryTimeValue" class="slider-label">30 sec</span>
              </div>
            </div>
            <div class="control-item"> <label for="speedThreshold">Speed
                Threshold (km/h)</label>
              <div> <input id="speedThreshold" value="10" min="5" max="20" type="range">
                <span id="speedThresholdValue" class="slider-label">10 km/h</span>
              </div>
            </div>
          </div>
        </div>
        <div id="calibrateStatus" class="status">Sensors not calibrated</div>
        <div id="lockStatus" class="status">Lock Status: Not locked</div>
        <div id="audioStatus" class="status">Audio: Not initialized</div>
        <div id="gpsStatus" class="status">GPS: Ready</div>
        <div id="reachedMessage" class="reached-message" style="display: none;">You
          have reached GPS locked point!</div>
      </div>
      <div class="panel">
        <h2>Position Map</h2>
        <div id="map"></div>
      </div>
      <div class="panel"> <button class="collapsible">Direction Indicator ▼</button>
        <div class="collapsible-content">
          <div class="direction-container">
            <div id="directionArrow"></div>
            <div class="direction-circle"></div>
          </div>
          <div id="directionStatus" class="direction-status">Direction: --</div>
        </div>
        <button class="collapsible">Sonar Parameters ▼</button>
        <div class="collapsible-content">
          <div class="control-group">
            <div class="control-item"> <label for="freqInput">Bleep Freq (Hz)</label><br>
              <input id="freqInput" value="800" min="20" max="20000" type="number">
            </div>
            <div class="control-item"> <label for="maxDistInput">Max Distance
                (m)</label><br>
              <input id="maxDistInput" value="50" min="1" max="500" type="range">
              <span id="maxDistValue">50</span> m </div>
          </div>
        </div>
        <button class="collapsible">Data Output ▼</button>
        <div class="collapsible-content">
          <div class="control-group">
            <div class="control-item"> <label>Distance</label><br>
              <span id="distance">--</span> m </div>
            <div class="control-item"> <label>Accuracy</label><br>
              <span id="accuracy">--</span> m </div>
            <div class="control-item"> <label>BPM</label><br>
              <span id="bleepRate">--</span> </div>
          </div>
        </div>
      </div>
    </div>
    <div class="tab-content" id="emergency-tab">
      <div class="panel emergency-panel">
        <h2>Emergency Features</h2>
        <div class="control-group"> <button id="emergencyBtn" class="emergency-btn">EMERGENCY
            ALERT</button> </div>
        <div class="control-group"> <button onclick="MotoFindBack.toggleEmergency()"
            class="secondary-btn">
            Emergency: <span id="emergencyStatus">ENABLED</span> </button>
        </div>
        <div id="crashStatus" class="status">Crash Detection: Inactive</div>
        <div class="control-group">
          <div class="control-item"> <label for="emergencyMessage">Emergency
              Message</label><br>
            <textarea id="emergencyMessage" rows="3" style="width: 100%;">I need help! My current location is: </textarea>
          </div>
        </div>
        <h3>Emergency Contacts</h3>
        <div class="emergency-contacts" id="emergencyContactList">
          <!-- Contacts will appear here --> </div>
        <div class="control-group"> <button id="addContactBtn" class="primary-btn">➕
            Add Contact</button> <button id="testEmergencyBtn" class="warning-btn">Test
            Emergency</button> <button id="callEmergencyBtn" class="emergency-btn"
            onclick="MotoFindBack.callEmergency()">Call
            112/911</button> </div>
        <!-- Add Contact Modal -->
        <div id="addContactModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center;">
          <div style="background: #333; padding: 20px; border-radius: 10px; width: 90%; max-width: 400px;">
            <h3>Add Emergency Contact</h3>
            <input id="newContactName" placeholder="Contact Name" style="width: 100%; margin: 10px 0; padding: 10px; background: #444; color: white; border: 1px solid #555; border-radius: 5px;"
              type="text">
            <input id="newContactNumber" placeholder="Phone Number" style="width: 100%; margin: 10px 0; padding: 10px; background: #444; color: white; border: 1px solid #555; border-radius: 5px;"
              type="text">
            <div style="display: flex; gap: 10px; margin-top: 15px;"> <button onclick="MotoFindBack.saveNewContact()"
                class="primary-btn"
                style="flex: 1;">Save</button>
              <button onclick="MotoFindBack.closeContactModal()" class="secondary-btn"
                style="flex: 1;">Cancel</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="tab-content" id="maintenance-tab">
      <div class="panel">
        <h2>Maintenance Alerts</h2>
        <div class="control-group"> <button id="addMaintenanceBtn" class="primary-btn">Add
            Maintenance Item</button> <button id="resetMaintenanceBtn" class="secondary-btn">Reset
            All</button> </div>
        <div id="maintenanceList">
          <div class="maintenance-item">
            <div>Oil Change</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 30%;"></div>
            </div>
            <div>2000/5000 km</div>
          </div>
          <div class="maintenance-item">
            <div>Tire Pressure</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 70%;"></div>
            </div>
            <div>Check weekly</div>
          </div>
          <div class="maintenance-item">
            <div>Chain Lubrication</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 50%;"></div>
            </div>
            <div>500/1000 km</div>
          </div>
        </div>
        <div class="control-group">
          <div class="control-item">
            <h3>Add New Maintenance Item</h3>
            <input id="newMaintenanceName" placeholder="Item name" type="text">
            <input id="newMaintenanceInterval" placeholder="Interval (km)" type="number">
            <button id="saveMaintenanceBtn" class="secondary-btn">Save</button>
          </div>
        </div>
      </div>
    </div>
    <div class="panel">
      <h2 class="help-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
        Help Guide ▼ </h2>
      <div id="helpContent" style="display: none; text-align: left; padding: 10px;">
        <h1>Spin - Motorcycle Companion</h1>
        <h2>Purpose:</h2>
        Comprehensive motorcycle-focused GPS navigation with advanced ride
        metrics, emergency features, maintenance tracking, and engine sound
        analysis. The spinning wheel in the header rotates to reflect your
        current speed, spinning faster as you ride faster.
        <h2>🚀 Navigation Tab</h2>
        <strong>GPS Navigation:</strong> Lock your position and navigate back
        with audio cues.<br>
        <strong>Calibrate Sensors:</strong> Place phone on bike in riding
        position and tap to set baseline for lean angle and crash detection.<br>
        <strong>Auto-Lock Mode:</strong> Automatically locks position when
        motorcycle is stationary.<br>
        <strong>Direction Indicator:</strong> Visual compass pointing to locked
        position.<br>
        <strong>Sonar Parameters:</strong> Adjust audio feedback frequency and
        range.<br>
        <strong>Triple-Tap Overlay:</strong> Quickly tap screen 3 times to show
        enlarged speed/lean display. <strong>GPS Navigation:</strong> Lock your
        position and navigate back with audio cues (initially muted for safety).<br>
        <strong>Mute Sound:</strong> Toggle audio feedback on/off. Starts muted
        to prevent unexpected sounds.<br>
        <h2>📊 Metrics Tab</h2>
        <strong>Ride Metrics:</strong> Track speed, distance, acceleration, and
        lean angles with real-time updates.<br>
        <strong>Cornering Analysis:</strong> Detects corners using GPS curvature
        and lean angle, calculates cornering G and speeds.<br>
        <strong>Elevation Profile:</strong> Tracks altitude changes using GPS
        data with live chart.<br>
        <strong>Lean Angle Indicator:</strong> Visual display of motorcycle lean
        during corners.<br>
        <strong>Distance Statistics:</strong> Daily, weekly, monthly, and total
        distance tracking.<br>
        <strong>Acceleration Timer:</strong> Measures 0-100 km/h (customizable)
        acceleration.<br>
        <h3>🎵 Engine Sound Analysis</h3>
        <strong>Real-time RPM Monitoring:</strong> Uses microphone to detect
        engine RPM from sound.<br>
        <strong>Gear Position Estimation:</strong> Automatically estimates
        current gear based on speed/RPM ratio.<br>
        <strong>Engine Health Monitoring:</strong> Detects engine knock, exhaust
        leaks, and unusual vibrations.<br>
        <strong>Gear Shift Detection:</strong> Tracks shift patterns and
        quality.<br>
        <strong>Impulse Response Calibration:</strong> Record your engine sound
        for precise RPM calibration.<br>
        <strong>Sound Spectrum Visualization:</strong> Real-time frequency
        display.
        <h3>💾 Session Management</h3>
        <strong>Start Session:</strong> Begin recording a new ride with
        auto-save every 30 seconds.<br>
        <strong>Save Session:</strong> Save ride with custom name and notes.<br>
        <strong>Quick Save:</strong> Instant save without prompts.<br>
        <strong>Export Session:</strong> Download ride data as JSON file.<br>
        <strong>Session History:</strong> Browse and manage all past rides.
        <h2>🚨 Emergency Tab</h2>
        <strong>Emergency Alert:</strong> Send your location to emergency
        contacts manually.<br>
        <strong>Crash Detection:</strong> Automatically sends location to
        contacts if bike is detected lying flat for 5 seconds.<br>
        <strong>Quick Contacts:</strong> Pre-set emergency contacts for quick
        access with call/message buttons.<br>
        <strong>Custom Message:</strong> Edit the emergency message with your
        details.<br>
        <strong>Emergency Call:</strong> Direct access to 112/911 emergency
        services.
        <h2>🔧 Maintenance Tab</h2>
        <strong>Maintenance Alerts:</strong> Track service intervals based on
        mileage.<br>
        <strong>Progress Indicators:</strong> Visual progress bars for each
        maintenance item.<br>
        <strong>Custom Items:</strong> Add your own maintenance tasks and
        intervals.<br>
        <strong>Auto Reminders:</strong> Get notified when maintenance is due.
        <h2>🎛️ Advanced Features</h2>
        <strong>Triple-Tap Overlay:</strong> Quick triple-tap anywhere to show
        enlarged stats display.<br>
        <strong>Real-time Wheel Animation:</strong> Header wheel spins according
        to your speed.<br>
        <strong>Comprehensive Data Export:</strong> Export metrics, sessions,
        and maintenance data.<br>
        <strong>Offline Capable:</strong> Works without internet connection for
        basic navigation.<br>
        <strong>Battery Efficient:</strong> Optimized sensors and GPS usage.
        <h2>🚀 Quick Start Guide</h2>
        <ol>
          <li><strong>Initial Setup:</strong>
            <ul>
              <li>Mount phone securely on motorcycle</li>
              <li>Tap "Calibrate Sensors" to set lean angle baseline (Calibration will fail if phone is completely flat).</li>
              <li>Set emergency contacts in Emergency tab</li>
            </ul>
          </li>
          <li><strong>Before Riding:</strong>
            <ul>
              <li>Tap "Test Audio &amp; Lock" to initialize app</li>
              <li>Start Engine Analysis for RPM monitoring</li>
              <li>Record engine sample for accurate RPM calibration</li>
              <li>Start new session to track your ride</li>
            </ul>
          </li>
          <li><strong>During Ride:</strong>
            <ul>
              <li>Use Navigation tab to lock parking position</li>
              <li>Monitor Metrics tab for performance data</li>
              <li>Watch header wheel spin with your speed</li>
              <li>Triple-tap screen for quick stats overlay</li>
            </ul>
          </li>
          <li><strong>After Ride:</strong>
            <ul>
              <li>Save session with notes</li>
              <li>Check maintenance progress</li>
              <li>Export data for analysis</li>
            </ul>
          </li>
        </ol>
        <h2>💡 Pro Tips</h2>
        <strong>For Best Results:</strong>
        <ul>
          <li>Mount phone securely aligned with bike's centerline for accurate
            lean angles</li>
          <li>Calibrate engine sound analysis in a quiet environment</li>
          <li>Set realistic maintenance intervals based on your riding style</li>
          <li>Test emergency features before your first ride</li>
          <li>Use quick save frequently during long rides</li>
          <li>Export session data regularly to backup your rides</li>
        </ul>
        <strong>Safety Features:</strong>
        <ul>
          <li>Crash detection requires proper phone mounting</li>
          <li>Emergency contacts should be set before riding</li>
          <li>Test audio navigation in a safe area first</li>
          <li>Keep phone charged during long rides</li>
        </ul>
        <strong>Performance Tracking:</strong>
        <ul>
          <li>Monitor cornering G-forces to improve technique</li>
          <li>Track acceleration times for performance tuning</li>
          <li>Use elevation data for route planning</li>
          <li>Analyze gear shift patterns for smoother riding</li>
        </ul>
        <h2>🔧 Troubleshooting</h2>
        <strong>Common Issues:</strong>
        <ul>
          <li><em>No GPS signal:</em> Ensure location services are enabled</li>
          <li><em>No engine sound detection:</em> Allow microphone access and
            start engine analysis</li>
          <li><em>Inaccurate lean angles:</em> Recalibrate sensors with phone
            properly mounted</li>
          <li><em>Audio not working:</em> Check phone volume and app permissions</li>
          <li><em>Crash detection false positives:</em> Adjust phone mounting
            position</li>
        </ul>
        <strong>Support:</strong>
        <ul>
          <li>Ensure latest browser version for best performance</li>
          <li>Grant all requested permissions for full functionality</li>
          <li>Use in landscape mode for better dashboard visibility</li>
          eleveation
          <li>Keep app updated for new features and bug fixes</li>
        </ul>
         <strong>Created:</strong>
        <ul>
          <li>For ihearcolors.online</li>
          <li>By Dimitris Barnias 2025</li>
          <li>If you like this app, <strong>please support</strong>  by buying me a cup of coffee (or two..) </li>
          <li>Any donation is welcome: PayPall newtones@icloud.com</li>
          <li><strong>Report</strong> any bugs or possible features at: dbarnias@gmail.com</li>
        </ul>
        <div style="background: rgba(255,102,0,0.1); padding: 10px; border-radius: 5px; margin-top: 15px; border-left: 3px solid var(--primary-color);">
          <strong>🎯 Remember:</strong> Spin is designed to enhance your riding
          experience, not replace safe riding practices. Always ride responsibly
          and within your limits. </div>
      </div>
    </div>
    <div id="debug"></div>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
const MotoFindBack = {
  audioCtx: null,
  watchId: null,
  bleepTimer: null,
  lockPosition: null,
  lastUpdateTime: Date.now(),
  lastBleedTime: 0,
  isAudioAllowed: false,
  isActive: false,
  isRideActive: false,
  movementHistory: [],
  currentTempo: 1000,
  emergencyEnabled: true,
  autoLockEnabled: false,
    loadPreviousSessions: true,
  showSessionPrompt: true,
  autoLockDebounce: null,
  currentSpeed: 0,
  reachedPointDisplayed: false,
  isMuted: false,
  isStationary: false,
  lastStationaryTime: null,
  lastStationaryPosition: null,
  speedThreshold: 10,
  maxSpeed: 0,
   isMuted: true,
  totalDistance: 0,
  todayDistance: 0,
  weekDistance: 0,
  monthDistance: 0,
  elevationGain: 0,
  rideStartTime: null,
  accelerationStartTime: null,
  accelerationStartSpeed: 0,
  accelerationTimes: [],
  maxLeanAngle: 0,
  currentLeanAngle: 0,
  currentCornerG: 0,
  maxCornerG: 0,
  maxCornerSpeed: 0,
  corners: [],
  cornerEntrySpeeds: [],
  cornerExitSpeeds: [],
  maintenanceItems: [],
  emergencyContacts: [],
  rideHistory: [],
  isCalibrating: false,
  calibrationSamples: [],
  leanOffset: 0,
  crashDetected: false,
  crashStartTime: null,
  lastPosition: null,
  prevPosition: null,
  rotationSpeed: 0,
  map: null,
  userMarker: null,
  lockMarker: null,
  line: null,
  accelTarget: 100,
  elevationHistory: [],
  canvas: null, // Will store the canvas element
  cornerChart: null,
  tripleTapCount: 0,
  tripleTapTimeout: null,
  lastTapTime: 0,
  isOverlayVisible: false,
  
  
  accelerationPopup: {
  visible: false,
  achievedTime: null,
  startTime: null,
  element: null
},

  
  // Session data structure - MOVED OUTSIDE audioAnalysis
  sessionTemplate: {
    id: null,
    name: '',
    startTime: null,
    endTime: null,
    duration: 0,
    distance: 0,
    maxSpeed: 0,
    avgSpeed: 0,
    elevationGain: 0,
    corners: 0,
    hardBrakingEvents: 0,
    aggressiveCorners: 0,
    routeData: [],
    metrics: {
      accelerationTimes: [],
      leanAngles: [],
      corneringData: [],
      elevationData: []
    },
    weather: '',
    notes: ''
  },
  sessionHistory: [],
  currentSession: null,
  autoSaveInterval: null,

  audioAnalysis: {
    audioContext: null,
    analyser: null,
    microphone: null,
    javascriptNode: null,
    isListening: false,
    engineRPM: 0,
    gearPosition: 0,
    engineHealth: 'Good',
    soundProfile: null,
    lastShiftTime: 0,
    maxDb: 0,
    frequencyData: new Uint8Array(1024),
    
    // Calibration and recording moved INSIDE audioAnalysis
    calibration: {
      isCalibrated: false,
      recordedSample: null,
      referenceFrequency: 0,
      referenceRPM: 0,
      frequencyResponse: [],
      volumeThreshold: 20,
      minRPM: 1000,
      maxRPM: 12000,
      bikeProfile: {
        name: 'Uncalibrated',
        type: 'unknown',
        redline: 8000,
        idleRPM: 1500
      }
      
    },
    recording: {
      isRecording: false,
      recordingBuffer: [],
      recordingStartTime: 0,
      sampleDuration: 3000, // 3 seconds
      analysisBuffer: null
    }
    
  },
  
 
  
init: async function() {
  this.loadUserPreferences();
  this.initMap();
  this.loadContactsFromStorage();
  this.setupTripleTapDetection();
  this.loadSessionsFromStorage();
  
  // Auto-start session when ride starts
  const originalStartRide = this.startRide;
  this.startRide = function() {
    if (!this.currentSession) {
      this.startNewSession();
    }
    return originalStartRide.apply(this, arguments);
  }.bind(this);
  
  // Auto-update session display
  setInterval(() => {
    this.updateSessionDisplay();
  }, 1000);
  
  this.canvas = document.getElementById('elevationCanvas'); // Store the canvas element
  if (!this.canvas) {
    this.log("Error: elevationCanvas element not found", true);
    return;
  }
  
  this.cornerChart = new Chart(document.getElementById('cornerChart').getContext('2d'), {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Corner G-Force',
        data: [],
        borderColor: '#00ccff',
        backgroundColor: 'rgba(0, 204, 255, 0.2)',
        fill: true,
        tension: 0.4
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: { beginAtZero: true, title: { display: true, text: 'G-Force (g)' } },
        x: { title: { display: true, text: 'Corner Number' } }
      }
    }
  });
  
  this.setupEventListeners();
  this.setupTabs();
  this.setupCollapsibles();
  this.loadData();
  this.updateUI();
  this.log("MotoFindBack initialized");
  this.initDeviceOrientation();
      
      document.getElementById("accelTarget").addEventListener("input", (e) => {
  this.accelTarget = parseFloat(e.target.value) || 100;
  const label = document.querySelector('#accelerationTime').previousElementSibling;
  if (label) label.textContent = `0-${this.accelTarget} km/h`;
  const statsLabel = document.querySelector('#statsAcceleration').previousElementSibling;
  if (statsLabel) statsLabel.textContent = `0-${this.accelTarget} km/h`;
  
  // Update the value display
  document.getElementById('accelTargetValue').textContent = this.accelTarget + ' km/h';
  
  // Reset acceleration tracking when target changes
  this.accelerationPopup.startTime = null;
  this.accelerationPopup.achievedTime = null;
});

  document.getElementById("maxDistInput").addEventListener("input", (e) => {
    document.getElementById("maxDistValue").textContent = e.target.value;
  });

  document.getElementById("stationaryTime").addEventListener("input", (e) => {
    document.getElementById("stationaryTimeValue").textContent = e.target.value + ' sec';
  });

  document.getElementById("speedThreshold").addEventListener("input", (e) => {
    this.speedThreshold = parseFloat(e.target.value);
    document.getElementById("speedThresholdValue").textContent = e.target.value + ' km/h';
  });
  
  document.getElementById("addContactBtn").addEventListener("click", () => this.showContactModal());
  document.getElementById("muteBtn").textContent = "Sound Muted";
  document.getElementById("muteBtn").classList.add("muted");
  document.getElementById("muteBtn").disabled = true;
  
  document.getElementById("accelTarget").addEventListener("input", (e) => {
    this.accelTarget = parseFloat(e.target.value) || 100;
    const label = document.querySelector('#accelerationTime').previousElementSibling;
    if (label) label.textContent = `0-${this.accelTarget} km/h`;
    const statsLabel = document.querySelector('#statsAcceleration').previousElementSibling;
    if (statsLabel) statsLabel.textContent = `0-${this.accelTarget} km/h`;
  });
      
        // TEMPORARY: Force show prompt for testing
  console.log('=== TEMPORARY OVERRIDE: Forcing session prompt ===');
  this.showSessionPrompt = true;
  
  // Your existing session loading code...
  await this.loadSessionsFromStorage();
  await this.loadUserPreferences();
  
  console.log('After loading - Sessions:', this.sessionHistory.length, 'Show prompt:', this.showSessionPrompt);
  

  
  console.log('After override - Sessions:', this.sessionHistory.length, 'Show prompt:', this.showSessionPrompt);
  
  if (this.showSessionPrompt && this.sessionHistory.length > 0) {
    console.log('✅ Showing session load prompt (forced)');
    setTimeout(() => {
      this.showSessionLoadPrompt();
    }, 1500);
  } else {
    console.log('❌ Still not showing prompt:', {
      showSessionPrompt: this.showSessionPrompt,
      sessionHistoryLength: this.sessionHistory.length
    });
  }
      
      
  // Fixed the incomplete if statement
  if (this.showSessionPrompt && this.sessionHistory.length > 0) {
    this.showSessionLoadPrompt();
  }

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').then(reg => {
      this.log('Service Worker registered');
    }).catch(err => {
      this.log('Service Worker registration failed: ' + err, true);
    });
  }
      
},
  
                                                            
loadUserPreferences: function() {
  const prefs = localStorage.getItem('motoFindBack_preferences');
  console.log('User preferences:', prefs);
  
  if (prefs) {
    try {
      const preferences = JSON.parse(prefs);
      this.loadPreviousSessions = preferences.loadPreviousSessions !== undefined ? preferences.loadPreviousSessions : true;
      this.showSessionPrompt = preferences.showSessionPrompt !== undefined ? preferences.showSessionPrompt : true;
      
      console.log('Loaded preferences:', {
        loadPreviousSessions: this.loadPreviousSessions,
        showSessionPrompt: this.showSessionPrompt
      });
    } catch (error) {
      console.error('Error loading preferences:', error);
      // Set defaults
      this.loadPreviousSessions = true;
      this.showSessionPrompt = true;
    }
  } else {
    console.log('No preferences found, using defaults');
    this.loadPreviousSessions = true;
    this.showSessionPrompt = true;
  }
},

saveUserPreferences: function() {
  const preferences = {
    loadPreviousSessions: this.loadPreviousSessions,
    showSessionPrompt: this.showSessionPrompt
  };
  localStorage.setItem('motoFindBack_preferences', JSON.stringify(preferences));
  
},

  showSessionLoadPrompt: function() {
  // Check if modal already exists
  if (document.getElementById('sessionLoadModal')) {
    return;
  }
  
  const modal = document.createElement('div');
  modal.id = 'sessionLoadModal';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
  `;
  
  modal.innerHTML = `
    <div style="background: #333; padding: 20px; border-radius: 10px; width: 90%; max-width: 400px; border: 2px solid var(--primary-color);">
      <h3>Load Previous Sessions?</h3>
      <p style="color: #ccc; margin: 15px 0;">Found ${this.sessionHistory.length} saved ride sessions. Load them now?</p>
 <p style="color: #ccc; margin: 15px 0;">Hint: Triple Click -> Change Simpler UI</p>
      
      
      <div style="margin: 15px 0;">
        <label style="color: #ccc; display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="dontAskAgain">
          Don't ask me again
        </label>
      </div>
      
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="loadSessionsYes" class="primary-btn" style="flex: 1;">Yes, Load</button>
        <button id="loadSessionsNo" class="secondary-btn" style="flex: 1;">No, Start Fresh</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Add event listeners
  document.getElementById('loadSessionsYes').addEventListener('click', () => {
    this.loadSessionsChoice(true);
  });
  
  document.getElementById('loadSessionsNo').addEventListener('click', () => {
    this.loadSessionsChoice(false);
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      this.loadSessionsChoice(false);
    }
  });
},
  
  resetSessionPrompt: function() {
  this.showSessionPrompt = true;
  this.saveUserPreferences();
  this.log('Session prompt preference reset to true');
  this.showAlertNotification('Session prompts have been re-enabled!', 'success');
  
  // Optional: Show the prompt immediately
  setTimeout(() => {
    if (this.sessionHistory.length > 0) {
      this.showSessionLoadPrompt();
    }
  }, 1000);
},
  
loadSessionsChoice: function(loadSessions) {
  console.log('=== loadSessionsChoice called ===', { loadSessions });
  
  this.loadPreviousSessions = loadSessions;
  
  const dontAskAgain = document.getElementById('dontAskAgain');
  console.log('DontAskAgain checkbox:', dontAskAgain, 'Checked:', dontAskAgain?.checked);
  
  if (dontAskAgain && dontAskAgain.checked) {
    this.showSessionPrompt = false;
    console.log('User chose: Don\'t ask again');
  }
  
  this.saveUserPreferences();
  
  if (!loadSessions) {
    this.sessionHistory = [];
    this.saveSessionsToStorage();
    console.log('Cleared session history');
  }
  
  // Remove modal
  const modal = document.getElementById('sessionLoadModal');
  console.log('Modal to remove:', modal);
  
  if (modal) {
    document.body.removeChild(modal);
    console.log('✅ Modal removed successfully');
  } else {
    console.log('❌ Modal not found for removal');
  }
  
  this.updateSessionHistoryDisplay();
  this.updateGeneralStatistics();
  console.log('Session choice completed');
},
              
              // Add this temporary method to test CSS
testButtonClickability: function() {
  setTimeout(() => {
    const yesBtn = document.getElementById('loadSessionsYes');
    const noBtn = document.getElementById('loadSessionsNo');
    
    if (yesBtn) {
      console.log('YES button styles:', {
        display: yesBtn.style.display,
        visibility: yesBtn.style.visibility,
        pointerEvents: yesBtn.style.pointerEvents,
        opacity: yesBtn.style.opacity,
        position: yesBtn.style.position,
        zIndex: yesBtn.style.zIndex
      });
      
      // Temporarily add visible border to see button area
      yesBtn.style.border = '2px solid red';
      noBtn.style.border = '2px solid blue';
    }
  }, 100);
},
              
              // Acceleration popup methods
setupAccelerationPopup: function() {
  // Create the popup element
  this.accelerationPopup.element = document.createElement('div');
  this.accelerationPopup.element.id = 'accelerationPopup';
  this.accelerationPopup.element.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #ff6600, #ff3300);
    color: white;
    padding: 25px 30px;
    border-radius: 15px;
    border: 3px solid #fff;
    box-shadow: 0 8px 25px rgba(255, 102, 0, 0.4);
    z-index: 9999;
    text-align: center;
    font-family: Arial, sans-serif;
    cursor: pointer;
    display: none;
    min-width: 200px;
    backdrop-filter: blur(10px);
  `;
  
  this.accelerationPopup.element.innerHTML = `
    <div style="margin-bottom: 15px;">
      <div style="font-size: 1.8em; font-weight: bold; margin-bottom: 5px;">🎯</div>
      <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 8px;">ACCELERATION ACHIEVED!</div>
    </div>
    <div id="accelerationPopupContent" style="font-size: 1.3em; font-weight: bold;">
      Calculating...
    </div>
    <div style="margin-top: 12px; font-size: 0.8em; opacity: 0.9;">
      Click to clear
    </div>
  `;
  
  // Add click to clear
  this.accelerationPopup.element.addEventListener('click', () => {
    this.hideAccelerationPopup();
  });
  
  document.body.appendChild(this.accelerationPopup.element);
},

showAccelerationPopup: function(time, targetSpeed) {
  if (!this.accelerationPopup.element) {
    this.setupAccelerationPopup();
  }
  
  const content = `
    <div style="margin-bottom: 8px;">0-${targetSpeed} km/h</div>
    <div style="font-size: 1.8em;">${time.toFixed(2)}s</div>
  `;
  
  document.getElementById('accelerationPopupContent').innerHTML = content;
  this.accelerationPopup.element.style.display = 'block';
  this.accelerationPopup.visible = true;
  this.accelerationPopup.achievedTime = Date.now();
  
  // Auto-hide after 10 seconds
  setTimeout(() => {
    if (this.accelerationPopup.visible) {
      this.hideAccelerationPopup();
    }
  }, 10000);
},

hideAccelerationPopup: function() {
  if (this.accelerationPopup.element) {
    this.accelerationPopup.element.style.display = 'none';
    this.accelerationPopup.visible = false;
    this.accelerationPopup.achievedTime = null;
    this.accelerationPopup.startTime = null;
  }
},

checkAccelerationAchievement: function() {
  const currentSpeedKmh = this.currentSpeed * 3.6;
  const targetSpeed = this.accelTarget; // User-defined target
  
  // Start timing if we're below target and not already timing
  if (currentSpeedKmh < targetSpeed && !this.accelerationPopup.startTime && !this.accelerationPopup.achievedTime) {
    this.accelerationPopup.startTime = Date.now();
    this.log(`Starting acceleration timer for 0-${targetSpeed} km/h`);
  }
  
  // Check if we reached the target speed
  if (this.accelerationPopup.startTime && 
      !this.accelerationPopup.achievedTime && 
      currentSpeedKmh >= targetSpeed) {
    
    const accelerationTime = (Date.now() - this.accelerationPopup.startTime) / 1000;
    
    // Only show popup if this is a meaningful acceleration (at least 0.5 seconds)
    if (accelerationTime >= 0.5) {
      this.accelerationTimes.push(accelerationTime);
      this.log(`🎯 Acceleration achieved: 0-${targetSpeed} km/h in ${accelerationTime.toFixed(2)}s`);
      
      // Show the popup
      this.showAccelerationPopup(accelerationTime, targetSpeed);
      
      // Update UI
      this.updateUI();
    }
    
    this.accelerationPopup.achievedTime = Date.now();
  }
  
  // Reset if speed drops significantly below target (like after braking)
  if (this.accelerationPopup.startTime && currentSpeedKmh < (targetSpeed * 0.3)) {
    this.accelerationPopup.startTime = null;
    this.accelerationPopup.achievedTime = null;
  }
},

// Test method
testAccelerationPopup: function() {
  const testTime = 4.27;
  this.showAccelerationPopup(testTime, this.accelTarget);
  this.log('Test acceleration popup shown');
},
              
    
    // Microphone initialization
// Update the initMicrophone function to handle permissions better
initMicrophone: function() {
  return new Promise((resolve, reject) => {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      this.log('Microphone access not available');
      reject('Microphone not supported');
      return;
    }

    // Request microphone permission first
    navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        channelCount: 1,
        sampleRate: 44100
      } 
    }).then(stream => {
      this.audioAnalysis.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.audioAnalysis.analyser = this.audioAnalysis.audioContext.createAnalyser();
      this.audioAnalysis.microphone = this.audioAnalysis.audioContext.createMediaStreamSource(stream);
      
      this.audioAnalysis.analyser.fftSize = 2048;
      this.audioAnalysis.analyser.smoothingTimeConstant = 0.6;
      this.audioAnalysis.analyser.minDecibels = -90;
      this.audioAnalysis.analyser.maxDecibels = -10;
      
      this.audioAnalysis.microphone.connect(this.audioAnalysis.analyser);
      
      this.audioAnalysis.javascriptNode = this.audioAnalysis.audioContext.createScriptProcessor(2048, 1, 1);
      this.audioAnalysis.analyser.connect(this.audioAnalysis.javascriptNode);
      this.audioAnalysis.javascriptNode.connect(this.audioAnalysis.audioContext.destination);
      
      this.audioAnalysis.javascriptNode.onaudioprocess = () => {
        if (this.audioAnalysis.isListening) {
          this.analyzeEngineSound();
        }
      };
      
      this.audioAnalysis.isListening = true;
      this.log('Microphone initialized for engine analysis');
      
      // Start visualization
      this.startFrequencyVisualization();
      resolve();
    }).catch(error => {
      this.log('Microphone access denied: ' + error.message, true);
      reject(error);
    });
  });
},

// Engine sound analysis
// Modify analyzeEngineSound to handle recording
analyzeEngineSound: function() {
  if (!this.audioAnalysis.analyser || !this.audioAnalysis.isListening) return;
  
  try {
    this.audioAnalysis.analyser.getByteFrequencyData(this.audioAnalysis.frequencyData);
    
    const hasData = this.audioAnalysis.frequencyData.some(val => val > 0);
    if (!hasData) return;
    
    const dominantFreq = this.findDominantFrequency();
    this.audioAnalysis.engineRPM = this.frequencyToRPM(dominantFreq);
    
    // Store sample if recording
    if (this.audioAnalysis.recording.isRecording) {
      this.audioAnalysis.recording.recordingBuffer.push({
        timestamp: Date.now(),
        dominantFreq: dominantFreq,
        maxDb: this.audioAnalysis.maxDb,
        frequencyData: new Uint8Array(this.audioAnalysis.frequencyData) // Copy array
      });
    }
    
    // Only process if above threshold
 
if (this.audioAnalysis.maxDb > this.audioAnalysis.calibration.volumeThreshold) {
      this.analyzeEngineHealth();
      this.detectGearShifts();
      this.estimateGearPosition();
      this.detectEngineProblems();
      this.updateEngineDisplay();
      this.updateFrequencyVisualization();
    }
    
  } catch (error) {
    console.error("Error in engine sound analysis:", error);
  }
},

// Better frequency detection
findDominantFrequency: function() {
  let maxVolume = 0;
  let dominantFreq = 0;
  let totalEnergy = 0;
  
  // Skip very low frequencies (below 50Hz) which are often noise
  const minBin = Math.floor(50 * this.audioAnalysis.frequencyData.length / (this.audioAnalysis.audioContext.sampleRate / 2));
  
  for (let i = minBin; i < this.audioAnalysis.frequencyData.length; i++) {
    const volume = this.audioAnalysis.frequencyData[i];
    totalEnergy += volume;
    
    if (volume > maxVolume) {
      maxVolume = volume;
      dominantFreq = i * (this.audioAnalysis.audioContext.sampleRate / 2) / this.audioAnalysis.frequencyData.length;
    }
  }
  
  this.audioAnalysis.maxDb = maxVolume;
  this.audioAnalysis.totalEnergy = totalEnergy;
  
  return dominantFreq;
},
  
  // Add frequency visualization to see what's being detected
startFrequencyVisualization: function() {
  this.frequencyCanvas = document.getElementById('frequencyCanvas');
  if (!this.frequencyCanvas) return;
  
  this.frequencyCtx = this.frequencyCanvas.getContext('2d');
  this.frequencyCanvas.width = this.frequencyCanvas.offsetWidth;
  this.frequencyCanvas.height = 100;
},

updateFrequencyVisualization: function() {
  if (!this.frequencyCtx || !this.audioAnalysis.frequencyData) return;
  
  const width = this.frequencyCanvas.width;
  const height = this.frequencyCanvas.height;
  const bufferLength = this.audioAnalysis.frequencyData.length;
  
  // White background
  this.frequencyCtx.fillStyle = 'rgb(255, 255, 255)';
  this.frequencyCtx.fillRect(0, 0, width, height);
  
  // Draw smooth orange waveform
  this.frequencyCtx.lineWidth = 2;
  this.frequencyCtx.strokeStyle = 'rgb(255, 100, 0)';
  this.frequencyCtx.beginPath();
  
  const sliceWidth = width / bufferLength;
  let x = 0;
  
  for (let i = 0; i < bufferLength; i++) {
    const v = this.audioAnalysis.frequencyData[i] / 255;
    const y = height - (v * height);
    
    if (i === 0) {
      this.frequencyCtx.moveTo(x, y);
    } else {
      this.frequencyCtx.lineTo(x, y);
    }
    
    x += sliceWidth;
  }
  
  this.frequencyCtx.stroke();
  
  // Fill under the waveform with orange gradient
  this.frequencyCtx.lineTo(width, height);
  this.frequencyCtx.lineTo(0, height);
  this.frequencyCtx.closePath();
  
  const fillGradient = this.frequencyCtx.createLinearGradient(0, 0, 0, height);
  fillGradient.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
  fillGradient.addColorStop(1, 'rgba(255, 150, 0, 0.2)');
  
  this.frequencyCtx.fillStyle = fillGradient;
  this.frequencyCtx.fill();
},

frequencyToRPM: function(frequency) {
  // This is a simplified conversion - would need calibration for specific bikes
  // Typical motorcycle engines: 1000-12000 RPM
  // 2-stroke: firing every revolution, 4-stroke: every other revolution
  const isFourStroke = true; // Assume 4-stroke for most bikes
  const cylinders = 2; // Assume 2 cylinders for calibration
  
  if (isFourStroke) {
    return (frequency * 60 * 2) / cylinders;
  } else {
    return (frequency * 60) / cylinders;
  }
},

// Engine health monitoring
analyzeEngineHealth: function() {
  const frequencies = Array.from(this.audioAnalysis.frequencyData);
  
  // Check for unusual vibrations/patterns
  const unusualHarmonics = this.detectUnusualHarmonics(frequencies);
  const engineKnock = this.detectEngineKnock(frequencies);
  const exhaustLeak = this.detectExhaustLeak(frequencies);
  
  if (engineKnock.detected) {
    this.audioAnalysis.engineHealth = 'Knocking Detected';
    this.log(`🚨 Engine knock detected: ${engineKnock.severity}`);
    this.triggerMaintenanceAlert('Engine knock detected - check oil and fuel quality');
  } else if (exhaustLeak.detected) {
    this.audioAnalysis.engineHealth = 'Possible Exhaust Leak';
    this.log(`⚠️ Possible exhaust leak detected`);
  } else if (unusualHarmonics) {
    this.audioAnalysis.engineHealth = 'Unusual Vibrations';
  } else {
    this.audioAnalysis.engineHealth = 'Normal';
  }
},

detectUnusualHarmonics: function(frequencies) {
  // Look for unexpected harmonic patterns that might indicate issues
  const fundamental = this.findDominantFrequency();
  const expectedHarmonics = [fundamental * 2, fundamental * 3, fundamental * 4];
  
  let unusualCount = 0;
  expectedHarmonics.forEach(harmonic => {
    const bin = Math.floor(harmonic * this.audioAnalysis.frequencyData.length / (this.audioAnalysis.audioContext.sampleRate / 2));
    if (frequencies[bin] > frequencies[Math.floor(fundamental)] * 0.8) {
      unusualCount++;
    }
  });
  
  return unusualCount > 1;
},

detectEngineKnock: function(frequencies) {
  // Engine knock typically appears as high-frequency spikes
  const highFreqStart = Math.floor(this.audioAnalysis.frequencyData.length * 0.7);
  let highFreqEnergy = 0;
  
  for (let i = highFreqStart; i < this.audioAnalysis.frequencyData.length; i++) {
    highFreqEnergy += frequencies[i];
  }
  
  const avgHighFreq = highFreqEnergy / (this.audioAnalysis.frequencyData.length - highFreqStart);
  const fundamentalEnergy = frequencies[this.findDominantFrequency()];
  
  return {
    detected: avgHighFreq > fundamentalEnergy * 0.3,
    severity: avgHighFreq / fundamentalEnergy
  };
},

detectExhaustLeak: function(frequencies) {
  // Exhaust leaks often create broadband noise
  let totalEnergy = 0;
  let peakEnergy = 0;
  
  for (let i = 0; i < frequencies.length; i++) {
    totalEnergy += frequencies[i];
    if (frequencies[i] > peakEnergy) peakEnergy = frequencies[i];
  }
  
  const avgEnergy = totalEnergy / frequencies.length;
  const broadbandRatio = avgEnergy / peakEnergy;
  
  return {
    detected: broadbandRatio > 0.4,
    ratio: broadbandRatio
  };
},

// Gear shift detection
detectGearShifts: function() {
  const currentTime = Date.now();
  const rpm = this.audioAnalysis.engineRPM;
  
  // Detect rapid RPM drop followed by stabilization (gear shift)
  if (this.lastRPM && rpm < this.lastRPM * 0.6 && currentTime - this.audioAnalysis.lastShiftTime > 2000) {
    // Possible gear shift detected
    this.audioAnalysis.lastShiftTime = currentTime;
    this.gearShiftEvents = this.gearShiftEvents || [];
    this.gearShiftEvents.push({
      time: currentTime,
      fromRPM: this.lastRPM,
      toRPM: rpm,
      speed: this.currentSpeed * 3.6
    });
    
    this.log(`⬆️ Gear shift detected at ${this.currentSpeed * 3.6} km/h`);
    this.analyzeShiftQuality(this.lastRPM, rpm);
  }
  
  this.lastRPM = rpm;
},

analyzeShiftQuality: function(fromRPM, toRPM) {
  const rpmDropRatio = toRPM / fromRPM;
  let shiftQuality = 'Good';
  
  if (rpmDropRatio < 0.4) shiftQuality = 'Hard';
  if (rpmDropRatio > 0.7) shiftQuality = 'Soft';
  if (Math.abs(fromRPM - toRPM) < 500) shiftQuality = 'Clutch Slipping';
  
  this.log(`Shift quality: ${shiftQuality} (${fromRPM.toFixed(0)} → ${toRPM.toFixed(0)} RPM)`);
},

estimateGearPosition: function() {
  if (this.currentSpeed === 0 || this.audioAnalysis.engineRPM === 0) {
    this.audioAnalysis.gearPosition = 0; // Neutral or stopped
    return;
  }
  
  // Simplified gear estimation based on speed/RPM ratio
  const ratio = (this.currentSpeed * 3.6) / this.audioAnalysis.engineRPM;
  
  if (ratio < 0.02) this.audioAnalysis.gearPosition = 1;
  else if (ratio < 0.035) this.audioAnalysis.gearPosition = 2;
  else if (ratio < 0.05) this.audioAnalysis.gearPosition = 3;
  else if (ratio < 0.065) this.audioAnalysis.gearPosition = 4;
  else if (ratio < 0.08) this.audioAnalysis.gearPosition = 5;
  else this.audioAnalysis.gearPosition = 6;
},

// Engine problem detection
detectEngineProblems: function() {
  const currentTime = Date.now();
  
  // Misfire detection (irregular engine sound)
  const regularity = this.analyzeEngineRegularity();
  if (regularity < 0.7) {
    this.log('⚠️ Possible engine misfire detected');
  }
  
  // Over-revving protection
  if (this.audioAnalysis.engineRPM > 10000 && this.currentSpeed > 0) {
    this.log('🚨 Engine over-revving detected!');
    this.triggerOverRevAlert();
  }
  
  // Lugging detection (too low RPM for speed)
  if (this.audioAnalysis.engineRPM < 2000 && this.currentSpeed > 30) {
    this.log('⚠️ Engine lugging detected - downshift recommended');
  }
},

analyzeEngineRegularity: function() {
  // Analyze how regular the engine pulses are
  const recentRPMS = this.rpmHistory || [];
  recentRPMS.push(this.audioAnalysis.engineRPM);
  
  if (recentRPMS.length > 50) recentRPMS.shift();
  this.rpmHistory = recentRPMS;
  
  if (recentRPMS.length < 10) return 1.0;
  
  // Calculate coefficient of variation
  const mean = recentRPMS.reduce((a, b) => a + b) / recentRPMS.length;
  const variance = recentRPMS.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recentRPMS.length;
  const stdDev = Math.sqrt(variance);
  const cv = stdDev / mean;
  
  return Math.max(0, 1 - cv);
},
  
  startEngineAnalysis: function() {
  this.initMicrophone().then(() => {
    document.getElementById("startEngineAnalysis").textContent = "Analysis Running";
    document.getElementById("startEngineAnalysis").style.background = "linear-gradient(to bottom, #00cc66, #00aa55)";
    this.log("Engine sound analysis started");
  }).catch(error => {
    this.log("Failed to start engine analysis: " + error, true);
    alert("Please allow microphone access to analyze engine sounds");
  });
},

stopEngineAnalysis: function() {
  if (this.audioAnalysis.javascriptNode) {
    this.audioAnalysis.javascriptNode.disconnect();
    this.audioAnalysis.javascriptNode = null;
  }
  if (this.audioAnalysis.microphone) {
    this.audioAnalysis.microphone.disconnect();
    this.audioAnalysis.microphone = null;
  }
  if (this.audioAnalysis.audioContext) {
    this.audioAnalysis.audioContext.close();
    this.audioAnalysis.audioContext = null;
  }
  
  this.audioAnalysis.isListening = false;
  document.getElementById("startEngineAnalysis").textContent = "Start Engine Analysis";
  document.getElementById("startEngineAnalysis").style.background = "";
  this.log("Engine sound analysis stopped");
},
  
  // Recording-based calibration
startRecordingCalibration: function() {
  if (!this.audioAnalysis.isListening) {
    alert('Please start engine analysis first');
    return;
  }

  this.audioAnalysis.recording.isRecording = true;
  this.audioAnalysis.recording.recordingBuffer = [];
  this.audioAnalysis.recording.recordingStartTime = Date.now();
  
  document.getElementById('calibrationStatus').textContent = '🎤 Recording... Rev engine steadily for 3 seconds';
  document.getElementById('calibrationStatus').style.color = 'var(--warning-color)';
  document.getElementById('startRecordingBtn').textContent = 'Recording...';
  document.getElementById('startRecordingBtn').style.background = 'linear-gradient(to bottom, #ff3333, #cc0000)';
  
  this.log('Started recording calibration sample');
  
  // Set timeout to stop recording automatically
  setTimeout(() => {
    if (this.audioAnalysis.recording.isRecording) {
      this.stopRecordingCalibration();
    }
  }, this.audioAnalysis.recording.sampleDuration);
},

stopRecordingCalibration: function() {
  if (!this.audioAnalysis.recording.isRecording) return;
  
  this.audioAnalysis.recording.isRecording = false;
  
  // Process the recorded sample
  this.processRecordedSample();
  
  document.getElementById('startRecordingBtn').textContent = 'Record Engine Sample';
  document.getElementById('startRecordingBtn').style.background = '';
  this.log('Stopped recording calibration sample');
},
  
processRecordedSample: function() {
  if (this.audioAnalysis.recording.recordingBuffer.length === 0) {
    this.log('No recording data to process', true);
    return;
  }
  
  document.getElementById('calibrationStatus').textContent = '🔍 Analyzing recording...';
  
  // Analyze the recorded sample
  const analysis = this.analyzeRecordedSample(this.audioAnalysis.recording.recordingBuffer);
  
  if (analysis.success) {
    this.applyCalibrationProfile(analysis);
    document.getElementById('calibrationStatus').textContent = `✅ Calibrated! ${analysis.estimatedRPM.toFixed(0)} RPM detected`;
    document.getElementById('calibrationStatus').style.color = 'var(--success-color)';
    document.getElementById('detectedRange').textContent = `${analysis.idleRPM.toFixed(0)}-${analysis.redlineRPM.toFixed(0)} RPM`;
    
    this.log(`Calibration successful! Engine profile: ${analysis.engineType}, RPM range: ${analysis.idleRPM}-${analysis.redlineRPM}`);
  } else {
    document.getElementById('calibrationStatus').textContent = '❌ Calibration failed - try again';
    document.getElementById('calibrationStatus').style.color = 'var(--error-color)';
    this.log('Calibration failed: ' + analysis.error, true);
  }
},

analyzeRecordedSample: function(recordingBuffer) {
  try {
    // Extract frequency characteristics from recording
    const frequencyStats = this.analyzeFrequencyCharacteristics(recordingBuffer);
    const amplitudeStats = this.analyzeAmplitudeCharacteristics(recordingBuffer);
    
    // Determine engine type based on frequency profile
    const engineType = this.classifyEngineType(frequencyStats);
    
    // Estimate RPM range based on frequency content
    const rpmEstimate = this.estimateRPMFromFrequency(frequencyStats.dominantFreq, engineType);
    
    // Calculate RPM range
    const idleRPM = Math.max(800, rpmEstimate * 0.15);
    const redlineRPM = rpmEstimate * 1.8;
    
    // Create frequency response profile
    const frequencyResponse = this.buildFrequencyResponse(recordingBuffer);
    
    return {
      success: true,
      dominantFrequency: frequencyStats.dominantFreq,
      estimatedRPM: rpmEstimate,
      engineType: engineType,
      idleRPM: idleRPM,
      redlineRPM: redlineRPM,
      frequencyResponse: frequencyResponse,
      harmonics: frequencyStats.harmonics,
      volumeRange: amplitudeStats
    };
    
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
},

analyzeFrequencyCharacteristics: function(recordingBuffer) {
  let dominantFreq = 0;
  let maxAmplitude = 0;
  const harmonics = [];
  
  // Analyze frequency content across all samples
  recordingBuffer.forEach(sample => {
    if (sample.maxDb > maxAmplitude) {
      maxAmplitude = sample.maxDb;
      dominantFreq = sample.dominantFreq;
    }
    
    // Collect harmonic information
    if (sample.dominantFreq > 50) { // Ignore very low frequencies
      harmonics.push({
        freq: sample.dominantFreq,
        amplitude: sample.maxDb,
        time: sample.timestamp
      });
    }
  });
  
  return {
    dominantFreq: dominantFreq,
    maxAmplitude: maxAmplitude,
    harmonics: harmonics,
    frequencyVariance: this.calculateFrequencyVariance(harmonics)
  };
},

analyzeAmplitudeCharacteristics: function(recordingBuffer) {
  const amplitudes = recordingBuffer.map(sample => sample.maxDb);
  const minAmplitude = Math.min(...amplitudes);
  const maxAmplitude = Math.max(...amplitudes);
  const avgAmplitude = amplitudes.reduce((a, b) => a + b) / amplitudes.length;
  
  return {
    min: minAmplitude,
    max: maxAmplitude,
    average: avgAmplitude,
    dynamicRange: maxAmplitude - minAmplitude
  };
},

classifyEngineType: function(frequencyStats) {
  const dominantFreq = frequencyStats.dominantFreq;
  
  if (dominantFreq < 80) return 'cruiser';
  if (dominantFreq < 150) return 'standard';
  if (dominantFreq < 250) return 'sport';
  return 'high-rev';
},

estimateRPMFromFrequency: function(dominantFreq, engineType) {
  // Base RPM estimation with engine type adjustments
  const baseRPM = dominantFreq * 60; // Basic conversion
  
  switch(engineType) {
    case 'cruiser':
      return Math.min(6000, baseRPM * 0.8);
    case 'standard':
      return Math.min(9000, baseRPM * 1.0);
    case 'sport':
      return Math.min(12000, baseRPM * 1.2);
    case 'high-rev':
      return Math.min(14000, baseRPM * 1.4);
    default:
      return Math.min(10000, baseRPM * 1.0);
  }
},

buildFrequencyResponse: function(recordingBuffer) {
  // Build a frequency response profile for this engine
  const freqBins = new Array(20).fill(0).map((_, i) => i * 100 + 50); // 50-2050 Hz
  const response = {};
  
  freqBins.forEach(freq => {
    const amplitudes = recordingBuffer
      .filter(sample => Math.abs(sample.dominantFreq - freq) < 25) // ±25 Hz window
      .map(sample => sample.maxDb);
    
    response[freq] = amplitudes.length > 0 ? 
      amplitudes.reduce((a, b) => a + b) / amplitudes.length : 0;
  });
  
  return response;
},

applyCalibrationProfile: function(analysis) {
  this.audioAnalysis.calibration.isCalibrated = true;
  this.audioAnalysis.calibration.referenceFrequency = analysis.dominantFrequency;
  this.audioAnalysis.calibration.referenceRPM = analysis.estimatedRPM;
  this.audioAnalysis.calibration.frequencyResponse = analysis.frequencyResponse;
  this.audioAnalysis.calibration.minRPM = analysis.idleRPM;
  this.audioAnalysis.calibration.maxRPM = analysis.redlineRPM;
  this.audioAnalysis.calibration.volumeThreshold = analysis.volumeRange.average * 0.3;
  
  this.audioAnalysis.calibration.bikeProfile = {
    name: `Calibrated ${analysis.engineType}`,
    type: analysis.engineType,
    redline: analysis.redlineRPM,
    idleRPM: analysis.idleRPM
  };
  
  // Update UI
  document.getElementById('bikeProfileName').textContent = this.audioAnalysis.calibration.bikeProfile.name;
  document.getElementById('calibrationMultiplier').textContent = (analysis.estimatedRPM / (analysis.dominantFrequency * 60)).toFixed(2) + 'x';
},

// Updated frequencyToRPM with impulse response matching
frequencyToRPM: function(frequency) {

  const cal = this.audioAnalysis.calibration;
  
  if (frequency < 20) return 0;
  
  if (cal.isCalibrated) {
    // Use the recorded calibration profile
    return this.calculateRPMFromCalibration(frequency);
  } else {
    // Fallback to basic calculation
    return this.frequencyToRPMBasic(frequency);
  }
},

calculateRPMFromCalibration: function(currentFrequency) {
  const cal = this.audioAnalysis.calibration;
  
  // Base calculation using recorded reference
  let baseRPM = (currentFrequency / cal.referenceFrequency) * cal.referenceRPM;
  
  // Apply frequency response correction
  const responseCorrection = this.getFrequencyResponseCorrection(currentFrequency);
  baseRPM *= responseCorrection;
  
  // Apply limits
  baseRPM = Math.max(cal.minRPM, Math.min(cal.maxRPM, baseRPM));
  
  return Math.round(baseRPM);
},

getFrequencyResponseCorrection: function(frequency) {
  const response = this.audioAnalysis.calibration.frequencyResponse;
  if (!response || Object.keys(response).length === 0) return 1.0;
  
  // Find closest frequency bin
  const frequencies = Object.keys(response).map(f => parseInt(f));
  const closestFreq = frequencies.reduce((prev, curr) => {
    return (Math.abs(curr - frequency) < Math.abs(prev - frequency) ? curr : prev);
  });
  
  const expectedAmplitude = response[closestFreq];
  if (expectedAmplitude === 0) return 1.0;
  
  // Calculate correction based on expected vs current response
  const currentAmplitude = this.audioAnalysis.maxDb;
  const correction = expectedAmplitude / (currentAmplitude || 1);
  
  // Limit correction to reasonable range
  return Math.max(0.5, Math.min(2.0, correction));
},

frequencyToRPMBasic: function(frequency) {
  // Basic fallback calculation
  const baseRPM = frequency * 60;
  return Math.max(1000, Math.min(12000, baseRPM));
},
  
  // Manual calibration functions
updateReferenceRPM: function(rpm) {
  document.getElementById('referenceRpmValue').textContent = rpm;
  this.manualReferenceRPM = parseInt(rpm);
},

applyManualCalibration: function() {
  if (!this.audioAnalysis.isListening) {
    alert('Start engine analysis first');
    return;
  }
  
  if (!this.manualReferenceRPM) {
    alert('Set reference RPM first');
    return;
  }
  
  // Use current frequency reading as reference
  const currentFreq = this.findDominantFrequency();
  if (currentFreq < 20) {
    alert('No engine sound detected');
    return;
  }
  
  this.audioAnalysis.calibration.isCalibrated = true;
  this.audioAnalysis.calibration.referenceFrequency = currentFreq;
  this.audioAnalysis.calibration.referenceRPM = this.manualReferenceRPM;
  
  document.getElementById('calibrationStatus').textContent = `Manual: ${this.manualReferenceRPM} RPM`;
  document.getElementById('calibrationStatus').style.color = 'var(--success-color)';
  
  this.log(`Manual calibration applied: ${currentFreq.toFixed(1)} Hz = ${this.manualReferenceRPM} RPM`);
},
  
  // Simple emergency toggle
toggleEmergency: function() {
  this.emergencyEnabled = !this.emergencyEnabled;
  const status = document.getElementById('emergencyStatus');
  
  if (this.emergencyEnabled) {
    status.textContent = "ENABLED";
    status.style.color = "var(--success-color)";
    document.getElementById('emergencyBtn').disabled = false;
  } else {
    status.textContent = "DISABLED"; 
    status.style.color = "var(--error-color)";
    document.getElementById('emergencyBtn').disabled = true;
  }
},
  
  updateGeneralStatistics: function() {
  if (this.sessionHistory.length === 0) {
    this.resetStatisticsDisplay();
    return;
  }
  
  const stats = this.calculateGeneralStatistics();
  
  document.getElementById('statsTotalDistance').textContent = stats.totalDistance.toFixed(1) + ' km';
  document.getElementById('statsMaxSpeedAll').textContent = stats.maxSpeed.toFixed(1) + ' km/h';
  document.getElementById('statsMaxLeanAll').textContent = stats.maxLeanAngle.toFixed(1) + '°';
  document.getElementById('statsMaxElevationAll').textContent = stats.maxElevationGain.toFixed(0) + ' m';
  document.getElementById('statsMaxCornerSpeedAll').textContent = stats.maxCornerSpeed.toFixed(1) + ' km/h';
  document.getElementById('statsMaxCornerGAll').textContent = stats.maxCornerG.toFixed(2) + ' g';
  document.getElementById('statsBest0to60').textContent = stats.best0to60 > 0 ? stats.best0to60.toFixed(2) + ' s' : '--';
  document.getElementById('statsBest0to100').textContent = stats.best0to100 > 0 ? stats.best0to100.toFixed(2) + ' s' : '--';
},

calculateGeneralStatistics: function() {
  let totalDistance = 0;
  let maxSpeed = 0;
  let maxLeanAngle = 0;
  let maxElevationGain = 0;
  let maxCornerSpeed = 0;
  let maxCornerG = 0;
  let best0to60 = Infinity;
  let best0to100 = Infinity;
  
  this.sessionHistory.forEach(session => {
    totalDistance += session.distance || 0;
    maxSpeed = Math.max(maxSpeed, session.maxSpeed || 0);
    maxElevationGain = Math.max(maxElevationGain, session.elevationGain || 0);
    
    // Get max values from metrics
    if (session.metrics) {
      if (session.metrics.leanAngles && session.metrics.leanAngles.length > 0) {
        const sessionMaxLean = Math.max(...session.metrics.leanAngles.map(l => l.angle || 0));
        maxLeanAngle = Math.max(maxLeanAngle, sessionMaxLean);
      }
      
      if (session.metrics.corneringData && session.metrics.corneringData.length > 0) {
        const sessionMaxCornerSpeed = Math.max(...session.metrics.corneringData.map(c => c.speed || 0));
        const sessionMaxCornerG = Math.max(...session.metrics.corneringData.map(c => c.g || 0));
        maxCornerSpeed = Math.max(maxCornerSpeed, sessionMaxCornerSpeed);
        maxCornerG = Math.max(maxCornerG, sessionMaxCornerG);
      }
      
      if (session.metrics.accelerationTimes && session.metrics.accelerationTimes.length > 0) {
        // For simplicity, using the best acceleration time from the session
        const sessionBestAccel = Math.min(...session.metrics.accelerationTimes.filter(t => t > 0));
        if (sessionBestAccel < best0to100) {
          best0to100 = sessionBestAccel;
        }
        // For 0-60, we'd need separate tracking, but using same for demo
        best0to60 = Math.min(best0to60, sessionBestAccel * 0.6); // Rough estimate
      }
    }
  });
  
  return {
    totalDistance,
    maxSpeed,
    maxLeanAngle,
    maxElevationGain,
    maxCornerSpeed,
    maxCornerG,
    best0to60: best0to60 !== Infinity ? best0to60 : 0,
    best0to100: best0to100 !== Infinity ? best0to100 : 0
  };
},

resetStatisticsDisplay: function() {
  document.getElementById('statsTotalDistance').textContent = '0 km';
  document.getElementById('statsMaxSpeedAll').textContent = '0 km/h';
  document.getElementById('statsMaxLeanAll').textContent = '0°';
  document.getElementById('statsMaxElevationAll').textContent = '0 m';
  document.getElementById('statsMaxCornerSpeedAll').textContent = '0 km/h';
  document.getElementById('statsMaxCornerGAll').textContent = '0 g';
  document.getElementById('statsBest0to60').textContent = '--';
  document.getElementById('statsBest0to100').textContent = '--';
},

exportAllStatistics: function() {
  const stats = this.calculateGeneralStatistics();
  const data = {
    generalStatistics: stats,
    totalSessions: this.sessionHistory.length,
    sessions: this.sessionHistory,
    exportedAt: new Date().toISOString()
  };
  
  const dataStr = JSON.stringify(data, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `motorcycle_stats_${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  this.log("All statistics exported");
},

clearAllStatistics: function() {
  if (confirm('Are you sure you want to clear ALL statistics and session data? This cannot be undone!')) {
    this.sessionHistory = [];
    this.saveSessionsToStorage();
    this.updateGeneralStatistics();
    this.updateSessionHistoryDisplay();
    this.log("All statistics cleared");
  }
},
  
  // Session management functions
startNewSession: function() {
  const sessionId = 'session_' + Date.now();
  
  this.currentSession = {
    ...this.sessionTemplate,
    id: sessionId,
    name: `Ride ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,
    startTime: Date.now(),
    routeData: [],
    metrics: {
      accelerationTimes: [],
      leanAngles: [],
      corneringData: [],
      elevationData: []
    }
  };
  
  // Start auto-save every 30 seconds
  this.autoSaveInterval = setInterval(() => {
    this.autoSaveSession();
  }, 30000);
  
  this.log(`New session started: ${sessionId}`);
  this.updateSessionDisplay();
},

autoSaveSession: function() {
  if (!this.currentSession) return;
  
  this.updateCurrentSessionData();
  this.saveSessionsToStorage();
  this.log('Session auto-saved');
},

updateCurrentSessionData: function() {
  if (!this.currentSession) return;
  
  // Update basic metrics
  this.currentSession.distance = this.todayDistance;
  this.currentSession.maxSpeed = this.maxSpeed;
  this.currentSession.avgSpeed = this.calculateAverageSpeed();
  this.currentSession.elevationGain = this.elevationGain;
  this.currentSession.corners = this.corners.length;
  this.currentSession.duration = Date.now() - this.currentSession.startTime;
  
  // Count safety events
  this.currentSession.hardBrakingEvents = this.hardBrakingEvents ? this.hardBrakingEvents.length : 0;
  this.currentSession.aggressiveCorners = this.aggressiveCorneringEvents ? this.aggressiveCorneringEvents.length : 0;
  
  // Add current position to route
  if (this.lastPosition) {
    this.currentSession.routeData.push({
      lat: this.lastPosition.lat,
      lon: this.lastPosition.lon,
      alt: this.lastPosition.alt,
      speed: this.currentSpeed,
      timestamp: Date.now(),
      leanAngle: this.currentLeanAngle
    });
    
    // Keep only last 1000 points to prevent memory issues
    if (this.currentSession.routeData.length > 1000) {
      this.currentSession.routeData = this.currentSession.routeData.slice(-1000);
    }
  }
  
  // Update detailed metrics
  this.currentSession.metrics.accelerationTimes = [...this.accelerationTimes];
  this.currentSession.metrics.leanAngles.push({
    angle: this.currentLeanAngle,
    timestamp: Date.now()
  });
  this.currentSession.metrics.corneringData = [...this.corners];
  this.currentSession.metrics.elevationData = [...this.elevationHistory];
},

saveCurrentSession: function() {
  if (!this.currentSession) {
    alert('No active session to save');
    return;
  }
  
  this.updateCurrentSessionData();
  
  // Add end time
  this.currentSession.endTime = Date.now();
  this.currentSession.duration = this.currentSession.endTime - this.currentSession.startTime;
  
  // Prompt for session name and notes
  const sessionName = prompt('Enter a name for this ride session:', this.currentSession.name);
  if (sessionName !== null) {
    this.currentSession.name = sessionName;
    
    const sessionNotes = prompt('Add any notes about this ride (optional):', '');
    if (sessionNotes !== null) {
      this.currentSession.notes = sessionNotes;
    }
    
    // Add to session history
    this.sessionHistory.unshift({...this.currentSession});
    
    // Save to storage
    this.saveSessionsToStorage();
    
    this.log(`Session saved: ${this.currentSession.name}`);
    this.showSessionSavedNotification();
    
    // Clear current session
    this.currentSession = null;
    clearInterval(this.autoSaveInterval);
    
    this.updateSessionHistoryDisplay();
  }
},

quickSaveSession: function() {
  if (!this.currentSession) {
    this.startNewSession();
  }
  
  this.updateCurrentSessionData();
  this.saveSessionsToStorage();
  this.showQuickSaveNotification();
  this.log('Session quick-saved');
},

exportSession: function(sessionId = null) {
  const session = sessionId ? 
    this.sessionHistory.find(s => s.id === sessionId) : 
    this.currentSession;
  
  if (!session) {
    alert('No session to export');
    return;
  }
  
  const dataStr = JSON.stringify(session, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `ride_session_${session.name.replace(/[^a-z0-9]/gi, '_')}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  this.log(`Session exported: ${session.name}`);
},

loadSession: function(sessionId) {
  const session = this.sessionHistory.find(s => s.id === sessionId);
  if (!session) return;
  
  // Create a visual replay of the session
  this.replaySession(session);
},

replaySession: function(session) {
  // Basic session info display
  alert(`Session: ${session.name}\nDistance: ${session.distance.toFixed(1)} km\nDuration: ${this.formatDuration(session.duration)}\nMax Speed: ${session.maxSpeed.toFixed(1)} km/h`);
  
  // You could implement a full replay on the map here
  this.log(`Loaded session: ${session.name}`);
},

deleteSession: function(sessionId) {
  if (confirm('Are you sure you want to delete this session?')) {
    this.sessionHistory = this.sessionHistory.filter(s => s.id !== sessionId);
    this.saveSessionsToStorage();
    this.updateSessionHistoryDisplay();
    this.log('Session deleted');
  }
},

// Storage functions
saveSessionsToStorage: function() {
  const data = {
    sessions: this.sessionHistory,
    lastUpdated: Date.now()
  };
  localStorage.setItem('rideSessions', JSON.stringify(data));
},

loadSessionsFromStorage: function() {
  const saved = localStorage.getItem('rideSessions');
  console.log('Loading sessions from storage:', saved ? 'Data found' : 'No data');
  
  if (saved) {
    try {
      const data = JSON.parse(saved);
      this.sessionHistory = data.sessions || [];
      console.log('Successfully loaded sessions:', this.sessionHistory.length);
      this.updateSessionHistoryDisplay();
    } catch (error) {
      console.error('Error loading saved sessions:', error);
      this.sessionHistory = [];
    }
  } else {
    this.sessionHistory = [];
    console.log('No saved sessions found in storage');
  }
},

// Utility functions
formatDuration: function(milliseconds) {
  const seconds = Math.floor(milliseconds / 1000);
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  
  if (hours > 0) {
    return `${hours}h ${minutes}m ${secs}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${secs}s`;
  } else {
    return `${secs}s`;
  }
},

formatDistance: function(km) {
  if (km < 1) {
    return `${(km * 1000).toFixed(0)} m`;
  }
  return `${km.toFixed(1)} km`;
},

// Session display functions
updateSessionDisplay: function() {
  const sessionInfo = document.getElementById('sessionInfo');
  if (!this.currentSession) {
    sessionInfo.style.display = 'none';
    return;
  }
  
  sessionInfo.style.display = 'block';
  document.getElementById('sessionName').textContent = this.currentSession.name;
  document.getElementById('sessionDuration').textContent = this.formatDuration(Date.now() - this.currentSession.startTime);
  document.getElementById('sessionDistance').textContent = this.formatDistance(this.currentSession.distance);
  document.getElementById('sessionMaxSpeed').textContent = this.currentSession.maxSpeed.toFixed(1) + ' km/h';
  document.getElementById('sessionCorners').textContent = this.currentSession.corners;
},

updateSessionHistoryDisplay: function() {
  const historyList = document.getElementById('sessionHistoryList');
  
  if (this.sessionHistory.length === 0) {
    historyList.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">No saved sessions yet</div>';
    return;
  }
  
  historyList.innerHTML = this.sessionHistory.map(session => `
    <div class="session-item" data-session-id="${session.id}">
      <div class="session-header">
        <strong>${session.name}</strong>
        <span class="session-date">${new Date(session.startTime).toLocaleDateString()}</span>
      </div>
      <div class="session-details">
        <span>${this.formatDistance(session.distance)}</span>
        <span>${this.formatDuration(session.duration)}</span>
        <span>${session.maxSpeed.toFixed(1)} km/h</span>
        <span>${session.corners} corners</span>
      </div>
      <div class="session-actions">
        <button onclick="MotoFindBack.exportSession('${session.id}')" title="Export">📤</button>
        <button onclick="MotoFindBack.loadSession('${session.id}')" title="View">👁️</button>
        <button onclick="MotoFindBack.deleteSession('${session.id}')" title="Delete" style="background: #ff3333;">🗑️</button>
      </div>
      ${session.notes ? `<div class="session-notes">${session.notes}</div>` : ''}
    </div>
  `).join('');
},

// UI Notification functions
showSessionSavedNotification: function() {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(to bottom, #00cc66, #00aa55);
    color: white;
    padding: 15px 20px;
    border-radius: 8px;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    font-weight: bold;
  `;
  notification.textContent = '✅ Ride Session Saved!';
  document.body.appendChild(notification);
  
  setTimeout(() => {
    document.body.removeChild(notification);
  }, 3000);
},

showQuickSaveNotification: function() {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(to bottom, var(--accent-color), #0099cc);
    color: white;
    padding: 10px 15px;
    border-radius: 6px;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    font-size: 0.9em;
  `;
  notification.textContent = '💾 Session Quick-Saved';
  document.body.appendChild(notification);
  
  setTimeout(() => {
    document.body.removeChild(notification);
  }, 2000);
},

// UI Updates
updateEngineDisplay: function() {
  if (!document.getElementById('engineRPM')) return;
  
  document.getElementById('engineRPM').textContent = Math.round(this.audioAnalysis.engineRPM) + ' RPM';
  document.getElementById('engineGear').textContent = this.audioAnalysis.gearPosition;
  document.getElementById('engineHealth').textContent = this.audioAnalysis.engineHealth;
  document.getElementById('engineVolume').textContent = this.audioAnalysis.maxDb + ' dB';
  
  // Debug info
  document.getElementById('micStatus').textContent = this.audioAnalysis.isListening ? 'Listening' : 'Stopped';
  const dominantFreq = this.findDominantFrequency();
  document.getElementById('debugFreq').textContent = Math.round(dominantFreq);
  document.getElementById('debugVolume').textContent = this.audioAnalysis.maxDb;
  document.getElementById('debugEnergy').textContent = this.audioAnalysis.totalEnergy || 0;
},
    
// Triple-tap detection setup
setupTripleTapDetection: function() {
  document.addEventListener('click', (e) => {
    this.handleTripleTap(e);
  });
  
  // Also close overlay when clicking on it
  document.getElementById('tripleTapOverlay').addEventListener('click', (e) => {
    this.hideOverlay();
  });
},

handleTripleTap: function(e) {
  const currentTime = Date.now();
  const timeSinceLastTap = currentTime - this.lastTapTime;
  
  // Reset if too much time passed between taps (500ms max between taps)
  if (timeSinceLastTap > 500) {
    this.tripleTapCount = 1;
  } else {
    this.tripleTapCount++;
  }
  
  this.lastTapTime = currentTime;
  
  // Clear existing timeout
  if (this.tripleTapTimeout) {
    clearTimeout(this.tripleTapTimeout);
  }
  
  // Check for triple tap
  if (this.tripleTapCount >= 3) {
    this.tripleTapCount = 0;
    this.showOverlay();
    return;
  }
  
  // Reset counter after timeout
  this.tripleTapTimeout = setTimeout(() => {
    this.tripleTapCount = 0;
  }, 500);
},

showOverlay: function() {
  if (this.isOverlayVisible) return;
  
  this.isOverlayVisible = true;
  const overlay = document.getElementById('tripleTapOverlay');
  overlay.classList.add('active');
  
  // Update stats
  this.updateOverlayStats();
  
  // Start animation for enlarged wheel
  this.updateEnlargedWheelAnimation();
  
  this.log("Triple-tap overlay shown");
},

hideOverlay: function() {
  if (!this.isOverlayVisible) return;
  
  this.isOverlayVisible = false;
  const overlay = document.getElementById('tripleTapOverlay');
  overlay.classList.remove('active');
  
  this.log("Triple-tap overlay hidden");
},

updateOverlayStats: function() {
  document.getElementById('overlayAvgSpeed').textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
  document.getElementById('overlayLeanAngle').textContent = this.currentLeanAngle + "°";
  document.getElementById('overlayMaxLean').textContent = this.maxLeanAngle + "°";
  document.getElementById('overlayCurrentSpeed').textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
},

updateEnlargedWheelAnimation: function() {
  const enlargedWheel = document.querySelector('.enlarged-wheel');
  const enlargedSpokes = document.querySelectorAll('.enlarged-wheel .wheel-spoke');
  
  if (this.currentSpeed <= 0.1) {
    enlargedWheel.style.animation = 'none';
    enlargedSpokes.forEach(spoke => spoke.style.animation = 'none');
  } else {
    const speedKmh = this.currentSpeed * 3.6;
    const rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
    enlargedWheel.style.animation = `wheel-spin ${rotationSpeed}s linear infinite`;
    enlargedSpokes.forEach((spoke, index) => {
      const spokeSpeed = rotationSpeed * (1 + index * 0.5);
      spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
    });
  }
},

// Update your existing updateWheelAnimation function to also update the enlarged wheel:
updateWheelAnimation: function() {
  const wheel = document.querySelector('.spinning-wheel');
  const spokes = document.querySelectorAll('.wheel-spoke');
  
  if (this.currentSpeed <= 0.1) {
    wheel.style.animation = 'none';
    spokes.forEach(spoke => spoke.style.animation = 'none');
  } else {
    const speedKmh = this.currentSpeed * 3.6;
    this.rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
    wheel.style.animation = `wheel-spin ${this.rotationSpeed}s linear infinite`;
    spokes.forEach((spoke, index) => {
      const spokeSpeed = this.rotationSpeed * (1 + index * 0.5);
      spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
    });
  }
  
  // Also update enlarged wheel if visible
  if (this.isOverlayVisible) {
    this.updateEnlargedWheelAnimation();
  }
},

 updateElevationProfile: function() {
  if (!this.canvas) {
    this.log("Error: elevationCanvas element not found", true);
    return;
  }
  
  const ctx = this.canvas.getContext('2d');
  if (!ctx) {
    this.log("Error: Unable to get 2D context for elevationCanvas", true);
    return;
  }
  
  // Get the container dimensions
  const container = this.canvas.parentElement;
  this.canvas.width = container.clientWidth;
  this.canvas.height = container.clientHeight;
  
  const w = this.canvas.width;
  const h = this.canvas.height;
  
  // Clear canvas with dark background
  ctx.fillStyle = '#222';
  ctx.fillRect(0, 0, w, h);
  
  if (this.elevationHistory.length < 2) {
    // Draw placeholder message
    ctx.fillStyle = '#666';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Not enough elevation data', w / 2, h / 2);
    this.log("Not enough elevation data to plot");
    return;
  }

  // Smooth the elevation data
  const smoothedElevations = [];
  for (let i = 0; i < this.elevationHistory.length; i++) {
    const start = Math.max(0, i - 1);
    const end = Math.min(this.elevationHistory.length - 1, i + 1);
    const avgElev = this.elevationHistory.slice(start, end + 1)
      .reduce((sum, p) => sum + p.elev, 0) / (end - start + 1);
    smoothedElevations.push(avgElev);
  }

  const minElev = Math.min(...smoothedElevations);
  const maxElev = Math.max(...smoothedElevations);
  const range = maxElev - minElev || 1;

  // Draw the elevation line
  ctx.beginPath();
  ctx.moveTo(0, h - 10); // Leave some padding at bottom
  
  smoothedElevations.forEach((elev, i) => {
    const x = (i / (smoothedElevations.length - 1)) * w;
    const y = h - 10 - ((elev - minElev) / range * (h - 20)); // Padding top and bottom
    ctx.lineTo(x, y);
  });
  
  ctx.strokeStyle = 'var(--accent-color)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Add gradient fill under the line
  ctx.lineTo(w, h - 10);
  ctx.lineTo(0, h - 10);
  ctx.closePath();
  
  const gradient = ctx.createLinearGradient(0, 0, 0, h);
  gradient.addColorStop(0, 'rgba(0, 204, 255, 0.3)');
  gradient.addColorStop(1, 'rgba(0, 204, 255, 0.1)');
  ctx.fillStyle = gradient;
  ctx.fill();

  // Add scale markers
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h - 10);
  ctx.lineTo(w, h - 10);
  ctx.stroke();

  // Update elevation stats
  document.getElementById('totalElevationGain').textContent = this.elevationGain.toFixed(0) + ' m';
  document.getElementById('elevationGain').textContent = this.elevationGain.toFixed(0) + ' m';
    document.getElementById('maxElevation').textContent = maxElev.toFixed(0) + ' m';
    document.getElementById('minElevation').textContent = minElev.toFixed(0) + ' m';
  },

  // Remaining methods (unchanged from previous response)
  initMap: function() {
    this.map = L.map('map').setView([51.505, -0.09], 15);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(this.map);

    const userIcon = L.divIcon({ className: 'user-marker', html: '📍', iconSize: [24, 24] });
    const lockIcon = L.divIcon({ className: 'lock-marker', html: '🔒', iconSize: [24, 24] });
    this.userMarker = L.marker([0, 0], { icon: userIcon }).addTo(this.map);
    this.lockMarker = L.marker([0, 0], { icon: lockIcon }).addTo(this.map);
    this.line = L.polyline([], { color: '#ff6600', weight: 2 }).addTo(this.map);
  },

  setupTabs: function() {
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
      });
    });
  },

  setupCollapsibles: function() {
    const coll = document.getElementsByClassName("collapsible");
    for (let i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        const content = this.nextElementSibling;
        content.style.maxHeight = content.style.maxHeight ? null : content.scrollHeight + "px";
      });
    }
  },

setupEventListeners: function() {
  document.getElementById("testBtn").addEventListener("click", () => {
    this.initAudio();
    this.playTestSound();
    if (this.isAudioAllowed) this.lockCurrentPosition();
  });
  document.getElementById("calibrateBtn").addEventListener("click", () => this.calibrateSensors());
  document.getElementById("autoLockBtn").addEventListener("click", () => this.toggleAutoLock());
  document.getElementById("muteBtn").addEventListener("click", () => this.toggleMute());
  document.getElementById("stopBtn").addEventListener("click", () => this.stop());
  document.getElementById("startRideBtn").addEventListener("click", () => this.startRide());
  document.getElementById("resetMetricsBtn").addEventListener("click", () => this.resetMetrics());
  document.getElementById("exportMetricsBtn").addEventListener("click", () => this.exportMetrics());
  document.getElementById("emergencyBtn").addEventListener("click", () => this.sendEmergencyAlert());
  document.getElementById("testEmergencyBtn").addEventListener("click", () => this.testEmergency());
  document.getElementById("addContactBtn").addEventListener("click", () => this.addEmergencyContact());
  document.getElementById("addMaintenanceBtn").addEventListener("click", () => this.showMaintenanceForm());
  document.getElementById("resetMaintenanceBtn").addEventListener("click", () => this.resetMaintenance());
  document.getElementById("saveMaintenanceBtn").addEventListener("click", () => this.saveMaintenanceItem());
  document.getElementById("startEngineAnalysis").addEventListener("click", () => this.startEngineAnalysis());
  document.getElementById("calibrateEngine").addEventListener("click", () => this.calibrateEngine());
  document.getElementById("startSessionBtn").addEventListener("click", () => this.startNewSession());
  document.getElementById("saveSessionBtn").addEventListener("click", () => this.saveCurrentSession());
  document.getElementById("quickSaveBtn").addEventListener("click", () => this.quickSaveSession());
  document.getElementById("exportSessionBtn").addEventListener("click", () => this.exportSession());
  document.getElementById("startRecordingBtn").addEventListener("click", () => this.startRecordingCalibration());
  document.getElementById("startSessionBtn").addEventListener("click", () => this.startNewSession());

},  

  initDeviceOrientation: function() {
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', (event) => {
        if (this.isCalibrating) {
          this.calibrationSamples.push(event.gamma || 0);
          return;
        }
        if (event.gamma !== null) {
          this.currentLeanAngle = Math.round(Math.abs(event.gamma - this.leanOffset));
          this.updateLeanAngleDisplay();
          if (this.currentLeanAngle > this.maxLeanAngle) this.maxLeanAngle = this.currentLeanAngle;
          const speedMs = this.currentSpeed;
          this.currentCornerG = this.calculateCornerG(speedMs, this.currentLeanAngle);
          this.detectCorner(this.lastPosition?.lat, this.lastPosition?.lon, speedMs * 3.6, this.currentLeanAngle, this.currentCornerG);
        }
        if (event.beta !== null && !this.crashDetected) {
          const betaAbs = Math.abs(event.beta);
          if (betaAbs > 70) {
            if (!this.crashStartTime) {
              this.crashStartTime = Date.now();
              document.getElementById('crashStatus').textContent = 'Possible crash detected... Confirming';
              document.getElementById('crashStatus').className = 'status warning';
              this.log('Possible crash detected, confirming for 5 seconds');
            }
            if (Date.now() - this.crashStartTime > 5000) {
              this.crashDetected = true;
              this.triggerCrashAlert();
            }
          } else if (this.crashStartTime) {
            this.crashStartTime = null;
            document.getElementById('crashStatus').textContent = 'Crash Detection: Inactive';
            document.getElementById('crashStatus').className = 'status';
            this.log('Crash condition cleared');
          }
        }
      });
    } else {
      this.log("Device orientation not supported", true);
      document.getElementById('crashStatus').textContent = 'Crash Detection: Not supported';
      document.getElementById('crashStatus').className = 'status error';
    }
  },

  calibrateSensors: function() {
    this.isCalibrating = true;
    this.calibrationSamples = [];
    document.getElementById('calibrateStatus').textContent = 'Calibrating... Keep phone steady for 5 seconds.';
    this.log('Starting sensor calibration');
    setTimeout(() => {
      if (this.calibrationSamples.length > 0) {
        const avgGamma = this.calibrationSamples.reduce((a, b) => a + b, 0) / this.calibrationSamples.length;
        this.leanOffset = avgGamma;
        document.getElementById('calibrateStatus').textContent = 'Calibrated! Offset: ' + this.leanOffset.toFixed(1) + '°';
        document.getElementById('calibrateStatus').className = 'status success';
        this.log('Calibration complete: offset ' + this.leanOffset.toFixed(1) + '°');
      } else {
        document.getElementById('calibrateStatus').textContent = 'Calibration failed - no data';
        document.getElementById('calibrateStatus').className = 'status error';
        this.log('Calibration failed');
      }
      this.isCalibrating = false;
    }, 5000);
  },



  updateLeanAngleDisplay: function() {
    const leanBike = document.getElementById('leanBike');
    const leanValue = document.getElementById('leanValue');
    const dashboardLean = document.getElementById('leanAngle');
    const displayAngle = Math.min(45, this.currentLeanAngle);
    leanBike.style.transform = `translateX(-50%) rotate(${displayAngle}deg)`;
    leanValue.textContent = `${this.currentLeanAngle}°`;
    dashboardLean.textContent = `${this.currentLeanAngle}°`;
    this.log(`Lean angle updated: ${this.currentLeanAngle}°`);
   if (this.isOverlayVisible) {
    document.getElementById('overlayLeanAngle').textContent = this.currentLeanAngle + "°";
    if (this.currentLeanAngle > this.maxLeanAngle) {
      document.getElementById('overlayMaxLean').textContent = this.maxLeanAngle + "°";
    }
  }
},

  calculateCornerG: function(speedMs, leanAngle) {
    return Math.tan(leanAngle * Math.PI / 180);
  },

  detectCorner: function(lat, lon, speedKmh, leanAngle, cornerG) {
    if (!lat || !lon || this.movementHistory.length < 3 || leanAngle < 5) return;
    const recent = this.movementHistory.slice(-3);
    const avgBearingChange = recent.reduce((sum, item, idx) => {
      if (idx === 0) return sum;
      const dLon = recent[idx].lon - recent[idx - 1].lon;
      const dLat = recent[idx].lat - recent[idx - 1].lat;
      return sum + Math.atan2(dLon, dLat) * 180 / Math.PI;
    }, 0) / 2;
    if (Math.abs(avgBearingChange) > 2 && cornerG > 0.2) {
      const cornerType = leanAngle > 30 ? 'Tight' : leanAngle > 15 ? 'Medium' : 'Sweeping';
      const corner = {
        startLat: recent[0].lat,
        startLon: recent[0].lon,
        speed: parseFloat(speedKmh),
        entrySpeed: parseFloat(recent[0].speed * 3.6),
        exitSpeed: parseFloat(speedKmh),
        g: cornerG,
        lean: leanAngle,
        type: cornerType,
        time: Date.now()
      };
      this.corners.push(corner);
      this.cornerEntrySpeeds.push(corner.entrySpeed);
      this.cornerExitSpeeds.push(corner.exitSpeed);
      if (speedKmh > this.maxCornerSpeed) this.maxCornerSpeed = parseFloat(speedKmh);
      if (cornerG > this.maxCornerG) this.maxCornerG = cornerG;
      this.updateCornerDisplay();
    }
  },

  updateCornerDisplay: function() {
    document.getElementById('currentCornerG').textContent = this.currentCornerG.toFixed(2) + ' g';
    document.getElementById('maxCornerSpeed').textContent = this.maxCornerSpeed.toFixed(1) + ' km/h';
    document.getElementById('maxCornerG').textContent = this.maxCornerG.toFixed(2) + ' g';
    const avgLean = this.corners.reduce((sum, c) => sum + c.lean, 0) / Math.max(1, this.corners.length);
    document.getElementById('avgCornerLean').textContent = avgLean.toFixed(1) + '°';
    const avgEntrySpeed = this.cornerEntrySpeeds.reduce((sum, s) => sum + s, 0) / Math.max(1, this.cornerEntrySpeeds.length);
    document.getElementById('avgCornerEntrySpeed').textContent = avgEntrySpeed.toFixed(1) + ' km/h';
    const cornerList = document.getElementById('cornerList');
    cornerList.innerHTML = this.corners.slice(-5).map(c =>
      `<p>${c.type} Corner: ${c.speed.toFixed(1)} km/h, Entry: ${c.entrySpeed.toFixed(1)} km/h, Exit: ${c.exitSpeed.toFixed(1)} km/h, ${c.g.toFixed(2)}g, ${c.lean}°</p>`
    ).join('') || 'No corners detected yet.';
    this.cornerChart.data.labels = this.corners.slice(-5).map((_, i) => `Corner ${i + 1}`);
    this.cornerChart.data.datasets[0].data = this.corners.slice(-5).map(c => c.g.toFixed(2));
    this.cornerChart.update();
  },

  updateWheelAnimation: function() {
    const wheel = document.querySelector('.spinning-wheel');
    const spokes = document.querySelectorAll('.wheel-spoke');
    if (this.currentSpeed <= 0.1) {
      wheel.style.animation = 'none';
      spokes.forEach(spoke => spoke.style.animation = 'none');
      this.log('Wheel animation stopped (speed <= 0.1 m/s)');
    } else {
      const speedKmh = this.currentSpeed * 3.6;
      this.rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
      wheel.style.animation = `wheel-spin ${this.rotationSpeed}s linear infinite`;
      spokes.forEach((spoke, index) => {
        const spokeSpeed = this.rotationSpeed * (1 + index * 0.5);
        spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
      });
      this.log(`Wheel animation updated: ${this.rotationSpeed.toFixed(2)}s per rotation at ${speedKmh.toFixed(1)} km/h`);
    }
  },

toggleMute: function() {
  this.isMuted = !this.isMuted;
  const muteBtn = document.getElementById("muteBtn");
  const audioStatus = document.getElementById("audioStatus");
  
  if (this.isMuted) {
    muteBtn.textContent = "Sound Muted";
    muteBtn.classList.add("muted");
    audioStatus.textContent = "Audio: Muted";
    audioStatus.className = "status warning";
    clearTimeout(this.bleepTimer);
    this.log("Audio muted");
  } else {
    muteBtn.textContent = "Mute Sound";
    muteBtn.classList.remove("muted");
    audioStatus.textContent = "Audio: Active";
    audioStatus.className = "status success";
    // Restart bleep if active
    if (this.isActive) {
      this.startBleep();
    }
    this.log("Audio unmuted");
  }
},

  toggleAutoLock: function() {
    this.autoLockEnabled = !this.autoLockEnabled;
    if (this.autoLockEnabled) {
      document.getElementById("autoLockBtn").textContent = "Auto-Lock: ON";
      document.getElementById("autoLockBtn").style.backgroundColor = "#ff6600";
      document.getElementById("autoLockBtn").style.color = "#000";
      document.getElementById("autoLockSettings").style.display = "block";
      this.log("Auto-lock enabled - will lock when stopped for specified time");
      this.updateGpsStatus("Auto-lock enabled - will lock when stopped");
    } else {
      document.getElementById("autoLockBtn").textContent = "Auto-Lock Mode";
      document.getElementById("autoLockBtn").style.backgroundColor = "";
      document.getElementById("autoLockBtn").style.color = "";
      document.getElementById("autoLockSettings").style.display = "none";
      clearTimeout(this.autoLockDebounce);
      this.autoLockDebounce = null;
      this.isStationary = false;
      this.lastStationaryTime = null;
      this.lastStationaryPosition = null;
      this.speedThreshold = 10;
      document.getElementById("speedThreshold").value = 10;
      document.getElementById("speedThresholdValue").textContent = "10 km/h";
      this.log("Auto-lock disabled");
      this.updateGpsStatus("Auto-lock disabled");
    }
    this.updateUI();
  },

initAudio: function() {
  if (this.audioCtx) {
    if (this.audioCtx.state === 'suspended') {
      this.audioCtx.resume().then(() => this.log("Audio context resumed"));
    }
    return;
  }
  try {
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    document.getElementById("audioStatus").textContent = "Audio: Initialized (Muted)";
    document.getElementById("audioStatus").className = "status warning";
    document.getElementById("autoLockBtn").disabled = false;
    document.getElementById("muteBtn").disabled = false;
    this.isAudioAllowed = true;
    this.log("Audio system initialized (initially muted)");
  } catch (e) {
    document.getElementById("audioStatus").textContent = `Audio: ${e.message}`;
    document.getElementById("audioStatus").className = "status error";
    this.log(`Audio init error: ${e.message}`, true);
  }
},

  playTestSound: function() {
    if (!this.audioCtx || this.isMuted) {
      this.log("Audio context not ready or muted", true);
      return;
    }
    try {
      const now = this.audioCtx.currentTime;
      const osc = this.audioCtx.createOscillator();
      const gain = this.audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      osc.connect(gain);
      gain.connect(this.audioCtx.destination);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 0.1);
      gain.gain.linearRampToValueAtTime(0, now + 0.5);
      osc.start(now);
      osc.stop(now + 0.5);
      this.log("Test sound played");
    } catch (e) {
      this.log(`Test sound error: ${e.message}`, true);
    }
  },

  lockCurrentPosition: function() {
    if (!this.lastPosition) {
      this.log("No position available to lock", true);
      return;
    }
    this.lockPosition = { lat: this.lastPosition.lat, lon: this.lastPosition.lon };
    this.lockMarker.setLatLng([this.lockPosition.lat, this.lockPosition.lon]);
    document.getElementById("lockStatus").textContent = `Lock Status: Locked at Lat ${this.lockPosition.lat.toFixed(6)}, Lon ${this.lockPosition.lon.toFixed(6)}`;
    document.getElementById("lockStatus").className = "status success";
    this.isActive = true;
    document.getElementById("stopBtn").disabled = false;
    document.getElementById("muteBtn").disabled = false;
    this.updateGpsStatus("Position locked");
    this.log(`Position locked at Lat ${this.lockPosition.lat.toFixed(6)}, Lon ${this.lockPosition.lon.toFixed(6)}`);
    this.startBleep();
  },

  startBleep: function() {
    if (!this.isActive || this.isMuted || !this.audioCtx) return;
    clearTimeout(this.bleepTimer);
    const distance = this.calculateDistance(this.lastPosition, this.lockPosition);
    const maxDist = parseFloat(document.getElementById("maxDistInput").value);
    const freq = parseFloat(document.getElementById("freqInput").value);
    let tempo = 1000;
    if (distance < maxDist) {
      tempo = Math.max(100, 1000 * (distance / maxDist));
      const now = this.audioCtx.currentTime;
      const osc = this.audioCtx.createOscillator();
      const gain = this.audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, now);
      osc.connect(gain);
      gain.connect(this.audioCtx.destination);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 0.05);
      gain.gain.linearRampToValueAtTime(0, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
    }
    document.getElementById("bleepRate").textContent = (60000 / tempo).toFixed(0);
    this.currentTempo = tempo;
    this.bleepTimer = setTimeout(() => this.startBleep(), tempo);
  },

  calculateDistance: function(pos1, pos2) {
    if (!pos1 || !pos2) return Infinity;
    const R = 6371e3;
    const φ1 = pos1.lat * Math.PI / 180;
    const φ2 = pos2.lat * Math.PI / 180;
    const Δφ = (pos2.lat - pos1.lat) * Math.PI / 180;
    const Δλ = (pos2.lon - pos1.lon) * Math.PI / 180;
    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
              Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  },

  updateGpsStatus: function(message) {
    document.getElementById("gpsStatus").textContent = `GPS: ${message}`;
    document.getElementById("gpsStatus").className = message.includes("error") ? "status error" : "status success";
  },

  updateUI: function() {
    document.getElementById("currentSpeed").textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
    document.getElementById("maxSpeed").textContent = this.maxSpeed.toFixed(1) + " km/h";
    document.getElementById("avgSpeed").textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
    document.getElementById("todayDistance").textContent = this.todayDistance.toFixed(1) + " km";
    document.getElementById("statsToday").textContent = this.todayDistance.toFixed(1) + " km";
    document.getElementById("statsWeek").textContent = this.weekDistance.toFixed(1) + " km";
    document.getElementById("statsMonth").textContent = this.monthDistance.toFixed(1) + " km";
    document.getElementById("statsTotal").textContent = this.totalDistance.toFixed(1) + " km";
    document.getElementById("statsCurrentSpeed").textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
    document.getElementById("statsMaxSpeed").textContent = this.maxSpeed.toFixed(1) + " km/h";
    document.getElementById("statsAvgSpeed").textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
    document.getElementById("statsAcceleration").textContent = this.calculateAccelerationTime().toFixed(2) + " s";
    document.getElementById("accelerationTime").textContent = this.calculateAccelerationTime().toFixed(2) + " s";
    this.updateCornerDisplay();
    this.updateElevationProfile();
    this.updateMaintenanceList();
    this.updateEmergencyContacts();
    this.updateRideHistory();
    this.updateGeneralStatistics();
     if (this.isOverlayVisible) {
    this.updateOverlayStats();
    this.updateEnlargedWheelAnimation();
  }
  },

  calculateAverageSpeed: function() {
    if (this.movementHistory.length < 2) return 0;
    const totalSpeed = this.movementHistory.reduce((sum, pos) => sum + pos.speed * 3.6, 0);
    return totalSpeed / this.movementHistory.length;
  },

  calculateAccelerationTime: function() {
    if (!this.accelerationTimes.length) return 0;
    return this.accelerationTimes.reduce((sum, time) => sum + time, 0) / this.accelerationTimes.length;
  },

startRide: function() {
  if (this.isRideActive) {
    // If ride is active, stop it and save session
    this.stop();
    if (this.currentSession) {
      this.saveCurrentSession();
    }
    return;
  }
  
  // Start new ride
  this.isRideActive = true;
  this.rideStartTime = Date.now();
  this.movementHistory = [];
  this.corners = [];
  this.cornerEntrySpeeds = [];
  this.cornerExitSpeeds = [];
  this.elevationHistory = [];
  this.elevationGain = 0;
  this.maxSpeed = 0;
  this.maxLeanAngle = 0;
  this.maxCornerG = 0;
  this.maxCornerSpeed = 0;
  this.accelerationTimes = [];
  
  document.getElementById("startRideBtn").textContent = "Stop & Save Ride";
  document.getElementById("startRideBtn").style.background = "linear-gradient(to bottom, #ff3333, #cc0000)";
  document.getElementById("startRideBtn").disabled = false;
  
  this.watchId = navigator.geolocation.watchPosition(
    pos => this.updatePosition(pos),
    err => this.handleGpsError(err),
    { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
  );
  
  // Auto-start session
  if (!this.currentSession) {
    this.startNewSession();
  }
  
  this.log("Ride started");
},

  updatePosition: function(pos) {
    this.prevPosition = this.lastPosition;
    this.checkAccelerationAchievement();
    this.lastPosition = { lat: pos.coords.latitude, lon: pos.coords.longitude, alt: pos.coords.altitude || 0 };
    this.currentSpeed = pos.coords.speed || 0;
    if (this.currentSpeed > this.maxSpeed) this.maxSpeed = this.currentSpeed * 3.6;
    this.movementHistory.push({ lat: this.lastPosition.lat, lon: this.lastPosition.lon, speed: this.currentSpeed, alt: this.lastPosition.alt, time: Date.now() });

    if (this.prevPosition) {
      const distance = this.calculateDistance(this.prevPosition, this.lastPosition) / 1000;
      this.totalDistance += distance;
      this.todayDistance += distance;
      this.weekDistance += distance;
      this.monthDistance += distance;

      if (this.prevPosition.alt && this.lastPosition.alt && this.lastPosition.alt > this.prevPosition.alt) {
        this.elevationGain += this.lastPosition.alt - this.prevPosition.alt;
      }
      this.elevationHistory.push({ elev: this.lastPosition.alt, time: Date.now() });
    }

    if (this.isRideActive && this.currentSpeed * 3.6 >= this.accelTarget && this.accelerationStartTime && !this.accelerationTimes.some(t => t)) {
      const accelTime = (Date.now() - this.accelerationStartTime) / 1000;
      this.accelerationTimes.push(accelTime);
      this.accelerationStartTime = null;
    } else if (this.currentSpeed * 3.6 < this.accelTarget && !this.accelerationStartTime) {
      this.accelerationStartTime = Date.now();
    }

    this.userMarker.setLatLng([this.lastPosition.lat, this.lastPosition.lon]);
    this.line.addLatLng([this.lastPosition.lat, this.lastPosition.lon]);
    this.map.panTo([this.lastPosition.lat, this.lastPosition.lon]);

    if (this.lockPosition) {
      const distance = this.calculateDistance(this.lastPosition, this.lockPosition);
      document.getElementById("distance").textContent = distance.toFixed(0);
      document.getElementById("accuracy").textContent = pos.coords.accuracy.toFixed(1);
      if (distance < 5 && !this.reachedPointDisplayed) {
        document.getElementById("reachedMessage").style.display = "block";
        this.reachedPointDisplayed = true;
        setTimeout(() => {
          document.getElementById("reachedMessage").style.display = "none";
          this.reachedPointDisplayed = false;
        }, 5000);
        this.stop();
      }
      this.updateDirection();
    }

    if (this.autoLockEnabled) {
      if (this.currentSpeed * 3.6 < this.speedThreshold) {
        if (!this.lastStationaryTime) {
          this.lastStationaryTime = Date.now();
          this.lastStationaryPosition = this.lastPosition;
        } else if (Date.now() - this.lastStationaryTime > parseInt(document.getElementById("stationaryTime").value) * 1000) {
          this.lockCurrentPosition();
          this.toggleAutoLock();
        }
      } else {
        this.lastStationaryTime = null;
        this.lastStationaryPosition = null;
      }
    }

    this.updateWheelAnimation();
    this.updateUI();
    this.startBleep();
  },

  handleGpsError: function(err) {
    this.log(`GPS error: ${err.message}`, true);
    this.updateGpsStatus(`Error: ${err.message}`);
  },

  updateDirection: function() {
    if (!this.lastPosition || !this.lockPosition) return;
    const dLon = this.lockPosition.lon - this.lastPosition.lon;
    const dLat = this.lockPosition.lat - this.lastPosition.lat;
    const angle = Math.atan2(dLon, dLat) * 180 / Math.PI;
    document.getElementById("directionArrow").style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
    document.getElementById("directionStatus").textContent = `Direction: ${angle.toFixed(0)}°`;
  },

  stop: function() {
    if (this.watchId) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
    clearTimeout(this.bleepTimer);
    this.isActive = false;
    this.isRideActive = false;
    document.getElementById("startRideBtn").textContent = "Start Ride";
    document.getElementById("startRideBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
    document.getElementById("muteBtn").disabled = true;
    document.getElementById("lockStatus").textContent = "Lock Status: Not locked";
    document.getElementById("lockStatus").className = "status";
    this.lockPosition = null;
    this.updateWheelAnimation();
    this.log("Tracking stopped");
    if (this.rideStartTime) {
      this.rideHistory.push({
        startTime: this.rideStartTime,
        distance: this.todayDistance,
        maxSpeed: this.maxSpeed,
        avgSpeed: this.calculateAverageSpeed(),
        acceleration: this.calculateAccelerationTime(),
        corners: this.corners.length,
        elevationGain: this.elevationGain
      });
      this.rideStartTime = null;
    }
    this.updateRideHistory();
  },

  resetMetrics: function() {
    this.maxSpeed = 0;
    this.totalDistance = 0;
    this.todayDistance = 0;
    this.weekDistance = 0;
    this.monthDistance = 0;
    this.elevationGain = 0;
    this.corners = [];
    this.cornerEntrySpeeds = [];
    this.cornerExitSpeeds = [];
    this.maxCornerG = 0;
    this.maxCornerSpeed = 0;
    this.accelerationTimes = [];
    this.elevationHistory = [];
    this.updateUI();
    this.log("Metrics reset");
  },

  exportMetrics: function() {
    const data = {
      totalDistance: this.totalDistance,
      todayDistance: this.todayDistance,
      weekDistance: this.weekDistance,
      monthDistance: this.monthDistance,
      maxSpeed: this.maxSpeed,
      avgSpeed: this.calculateAverageSpeed(),
      acceleration: this.calculateAccelerationTime(),
      corners: this.corners,
      elevationGain: this.elevationGain,
      elevationHistory: this.elevationHistory,
      rideHistory: this.rideHistory
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ride_metrics.json';
    a.click();
    URL.revokeObjectURL(url);
    this.log("Metrics exported");
  },

sendEmergencyAlert: function(message = null) {

  if (!this.emergencyEnabled) {
    alert("Emergency features are disabled");
    return;
  }
  const msg = message || `${document.getElementById('emergencyMessage').value} Lat: ${this.lastPosition?.lat.toFixed(6)}, Lon: ${this.lastPosition?.lon.toFixed(6)}`;
  
  this.emergencyContacts.forEach(contact => {
    // Method 1: Open SMS app (works on mobile)
    const smsUrl = `sms:${contact}?body=${encodeURIComponent(msg)}`;
    window.open(smsUrl, '_blank');
    
    // Method 2: For web fallback - use Share API if available
    if (navigator.share) {
      navigator.share({
        title: 'EMERGENCY ALERT',
        text: msg,
        url: window.location.href
      }).catch(err => {
        console.log('Share API failed, using SMS fallback');
        window.open(smsUrl, '_blank');
      });
    }
    
    this.log(`Sending emergency alert to ${contact}: ${msg}`);
  });
  
  // Visual feedback
  document.getElementById('emergencyBtn').textContent = 'ALERT SENT!';
  document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, #00cc66, #00aa55)';
  setTimeout(() => {
    document.getElementById('emergencyBtn').textContent = 'EMERGENCY ALERT';
    document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, var(--error-color), #cc0000)';
  }, 3000);
  
  this.log("Emergency alerts sent to all contacts");
},

testEmergency: function() {
  this.log("Testing emergency alert");
  // For test, just show what would be sent without actually sending
  const testMsg = "TEST ALERT: This is a test emergency message. Lat: " + 
                 (this.lastPosition?.lat.toFixed(6) || 'unknown') + 
                 ", Lon: " + (this.lastPosition?.lon.toFixed(6) || 'unknown');
  
  if (confirm(`Test Emergency Alert:\n\n${testMsg}\n\nOpen SMS app to test?`)) {
    this.sendEmergencyAlert("TEST ALERT: This is a test emergency message.");
  }
},

// Emergency contacts functions:
showContactModal: function() {
  document.getElementById('addContactModal').style.display = 'flex';
  document.getElementById('newContactName').value = '';
  document.getElementById('newContactNumber').value = '';
  document.getElementById('newContactName').focus();
},

closeContactModal: function() {
  document.getElementById('addContactModal').style.display = 'none';
},

saveNewContact: function() {
  const name = document.getElementById('newContactName').value.trim();
  const number = document.getElementById('newContactNumber').value.trim();
  
  if (!name) {
    alert('Please enter a contact name');
    return;
  }
  
  if (!number) {
    alert('Please enter a phone number');
    return;
  }

  // Validate phone number (basic validation)
  const cleanNumber = number.replace(/[^\d+]/g, '');
  if (cleanNumber.length < 10) {
    alert('Please enter a valid phone number');
    return;
  }

  // Add contact to array
  this.emergencyContacts.push({
    id: Date.now(), // Unique ID
    name: name,
    number: cleanNumber
  });

  // Save to localStorage
  this.saveContactsToStorage();
  
  // Update UI
  this.updateEmergencyContacts();
  this.closeContactModal();
  
  this.log(`Contact added: ${name} - ${cleanNumber}`);
},

updateEmergencyContacts: function() {
  const list = document.getElementById("emergencyContactList");
  
  if (this.emergencyContacts.length === 0) {
    list.innerHTML = `
      <div style="text-align: center; padding: 20px; color: #aaa;">
        No emergency contacts added yet.<br>
        Click "Add Contact" to add your first contact.
      </div>
    `;
    return;
  }

  list.innerHTML = this.emergencyContacts.map(contact => `
    <div class="contact-item" data-contact-id="${contact.id}">
      <div class="contact-info">
        <strong>${contact.name}</strong><br>
        <span style="font-size: 0.9em; color: #ccc;">${contact.number}</span>
      </div>
      <div class="contact-actions">
        <button onclick="MotoFindBack.callContact('${contact.number}')" title="Call">📞</button>
        <button onclick="MotoFindBack.messageContact('${contact.number}')" title="Message">💬</button>
        <button onclick="MotoFindBack.removeContact(${contact.id})" title="Remove" style="background: #ff3333;">🗑️</button>
      </div>
    </div>
  `).join('');
},

removeContact: function(contactId) {
  if (confirm('Remove this contact?')) {
    this.emergencyContacts = this.emergencyContacts.filter(contact => contact.id !== contactId);
    this.saveContactsToStorage();
    this.updateEmergencyContacts();
    this.log('Contact removed');
  }
},

// Updated sendEmergencyAlert to work with contact objects
sendEmergencyAlert: function(message = null) {
  if (this.emergencyContacts.length === 0) {
    alert('No emergency contacts added! Please add contacts first.');
    this.showContactModal();
    return;
  }

  const msg = message || `${document.getElementById('emergencyMessage').value} Lat: ${this.lastPosition?.lat.toFixed(6)}, Lon: ${this.lastPosition?.lon.toFixed(6)}`;
  
  this.emergencyContacts.forEach(contact => {
    const smsUrl = `sms:${contact.number}?body=${encodeURIComponent(msg)}`;
    window.open(smsUrl, '_blank');
    this.log(`Sending emergency alert to ${contact.name}: ${contact.number}`);
  });

  // Visual feedback
  document.getElementById('emergencyBtn').textContent = 'ALERT SENT!';
  document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, #00cc66, #00aa55)';
  setTimeout(() => {
    document.getElementById('emergencyBtn').textContent = 'EMERGENCY ALERT';
    document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, var(--error-color), #cc0000)';
  }, 3000);
},

// Updated contact functions to work with numbers
callContact: function(phoneNumber) {
  const telUrl = `tel:${phoneNumber}`;
  window.open(telUrl, '_blank');
  this.log(`Calling ${phoneNumber}`);
},

messageContact: function(phoneNumber) {
  const msg = document.getElementById('emergencyMessage').value + 
              ` Lat: ${this.lastPosition?.lat.toFixed(6) || 'unknown'}, Lon: ${this.lastPosition?.lon.toFixed(6) || 'unknown'}`;
  const smsUrl = `sms:${phoneNumber}?body=${encodeURIComponent(msg)}`;
  window.open(smsUrl, '_blank');
  this.log(`Messaging ${phoneNumber}`);
},

// Storage functions
saveContactsToStorage: function() {
  localStorage.setItem('emergencyContacts', JSON.stringify(this.emergencyContacts));
},

loadContactsFromStorage: function() {
  const saved = localStorage.getItem('emergencyContacts');
  if (saved) {
    this.emergencyContacts = JSON.parse(saved);
    this.updateEmergencyContacts();
  }
},

// Background communication with service worker
backgroundComm: {
  async postMessage(type, payload) {
    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      return new Promise((resolve) => {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          resolve(event.data);
        };
        navigator.serviceWorker.controller.postMessage(
          { type, payload },
          [messageChannel.port2]
        );
      });
    }
    return { success: false };
  }
},

// Store data in background
async storeInBackground(data) {
  const result = await this.backgroundComm.postMessage('STORE_BACKGROUND_DATA', data);
  if (result.success) {
    this.log('Data stored for background processing');
  }
},

// Queue emergency alert for background sending
async queueEmergencyForBackground(alertData) {
  const result = await this.backgroundComm.postMessage('QUEUE_EMERGENCY_ALERT', alertData);
  if (result.success) {
    this.log('Emergency alert queued for background sending');
  }
},


// Enhanced crash detection with actual alert sending
triggerCrashAlert: function() {
  if (!this.emergencyEnabled) return;
  document.getElementById('crashStatus').textContent = 'Crash detected! Sending alert...';
  document.getElementById('crashStatus').className = 'status error';
  this.log('Crash confirmed, triggering emergency alert');
  
  if (this.lastPosition) {
    const message = `🚨 CRASH DETECTED! ${document.getElementById('emergencyMessage').value} 
Location: https://maps.google.com/?q=${this.lastPosition.lat},${this.lastPosition.lon}
Lat: ${this.lastPosition.lat.toFixed(6)}, Lon: ${this.lastPosition.lon.toFixed(6)}`;
    
    // Send actual emergency alerts
    this.sendEmergencyAlert(message);
    
    // Also try to make an emergency call if possible
    setTimeout(() => {
      if (confirm('Crash detected! Call emergency services?')) {
        window.open('tel:112', '_blank'); // Europe emergency
        // window.open('tel:911', '_blank'); // US emergency
      }
    }, 1000);
    
  } else {
    this.log('No recent position available for crash alert', true);
    document.getElementById('crashStatus').textContent = 'Crash detected, but no position available';
  }
},

callEmergency: function() {
  // Determine local emergency number based on region or let user choose
  const emergencyNumbers = ['112', '911', '999'];
  const number = emergencyNumbers[0]; // Use first one, or implement region detection
  
  if (confirm(`Call emergency services (${number})?`)) {
    window.open(`tel:${number}`, '_blank');
  }
},



  saveMaintenanceItem: function() {
    const name = document.getElementById("newMaintenanceName").value;
    const interval = parseInt(document.getElementById("newMaintenanceInterval").value);
    if (name && interval) {
      this.maintenanceItems.push({ name, interval, progress: 0 });
      this.updateMaintenanceList();
      document.getElementById("newMaintenanceName").value = "";
      document.getElementById("newMaintenanceInterval").value = "";
      this.log(`Maintenance item added: ${name}`);
    }
  },

  resetMaintenance: function() {
    this.maintenanceItems = [];
    this.updateMaintenanceList();
    this.log("Maintenance items reset");
  },

  updateMaintenanceList: function() {
    const list = document.getElementById("maintenanceList");
    list.innerHTML = this.maintenanceItems.map(item => `
      <div class="maintenance-item">
        <div>${item.name}</div>
        <div class="maintenance-progress">
          <div class="maintenance-progress-bar" style="width: ${(item.progress / item.interval) * 100}%"></div>
        </div>
        <div>${item.progress}/${item.interval} km</div>
      </div>
    `).join('') || `
      <div class="maintenance-item">
        <div>Oil Change</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 30%"></div></div>
        <div>2000/5000 km</div>
      </div>
      <div class="maintenance-item">
        <div>Tire Pressure</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 70%"></div></div>
        <div>Check weekly</div>
      </div>
      <div class="maintenance-item">
        <div>Chain Lubrication</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 50%"></div></div>
        <div>500/1000 km</div>
      </div>
    `;
  },

  updateRideHistory: function() {
    const history = document.getElementById("rideHistory");
    history.innerHTML = this.rideHistory.map(ride => `
      <div>Ride on ${new Date(ride.startTime).toLocaleString()}: ${ride.distance.toFixed(1)} km, Max Speed: ${ride.maxSpeed.toFixed(1)} km/h, Avg Speed: ${ride.avgSpeed.toFixed(1)} km/h, 0-${this.accelTarget} km/h: ${ride.acceleration.toFixed(2)} s, Corners: ${ride.corners}, Elevation Gain: ${ride.elevationGain.toFixed(0)} m</div>
    `).join('') || "No ride history yet.";
  },

  loadData: function() {
    this.log("Loading saved data (placeholder)");
  },

  log: function(message, isError = false) {
    const debug = document.getElementById("debug");
    debug.innerHTML += `<div style="color: ${isError ? '#ff3333' : '#aaa'}">${new Date().toLocaleTimeString()}: ${message}</div>`;
    debug.scrollTop = debug.scrollHeight;
  }
};
      
MotoFindBack.init();
</script>
  </body>
</html>
