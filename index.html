<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spin - Motorcycle GPS Locator</title>
    <!-- Leaflet Map CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
    :root {
      --primary-color: #ff6600;
      --secondary-color: #333;
      --accent-color: #00ccff;
      --text-color: #fff;
      --warning-color: #ffcc00;
      --error-color: #ff3333;
      --success-color: #00cc66;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      color: var(--text-color);
      text-align: center;
      padding: 1em;
      max-width: 1000px;
      margin: 0 auto;
    }
    
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1em;
      position: relative;
    }
    
    .app-title {
      font-size: 2.2em;
      margin: 0;
      color: var(--primary-color);
      text-shadow: 0 0 5px rgba(255, 102, 0, 0.3);
    }
    
    .wheel-container {
      position: relative;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .spinning-wheel {
      width: 50px;
      height: 50px;
      position: relative;
      animation: wheel-spin 3s linear infinite;
    }
    
    .wheel-outer {
      fill: none;
      stroke: var(--primary-color);
      stroke-width: 3;
      stroke-dasharray: 5;
      animation: wheel-dash 1s linear infinite;
    }
    
    .wheel-inner {
      fill: none;
      stroke: var(--accent-color);
      stroke-width: 2;
    }
    
    .wheel-spoke {
      stroke: var(--accent-color);
      stroke-width: 2;
      transform-origin: center;
    }
    
    .spoke-1 { animation: spoke-spin 4s linear infinite; }
    .spoke-2 { animation: spoke-spin 3s linear infinite reverse; }
    .spoke-3 { animation: spoke-spin 5s linear infinite; }
    
    @keyframes wheel-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes wheel-dash {
      to {
        stroke-dashoffset: -10;
      }
    }
    
    @keyframes spoke-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .wheel-pulse {
      fill: var(--primary-color);
      animation: wheel-pulse 2s ease-in-out infinite;
    }
    
    @keyframes wheel-pulse {
      0%, 100% { opacity: 0.7; transform: scale(0.95); }
      50% { opacity: 1; transform: scale(1); }
    }
    
    .dashboard {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .dashboard-item {
      background: rgba(40, 40, 40, 0.7);
      border-radius: 10px;
      padding: 10px;
      border: 1px solid #444;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    .dashboard-value {
      font-size: 1.8em;
      font-weight: bold;
      color: var(--accent-color);
      margin: 5px 0;
    }
    
    .dashboard-label {
      font-size: 0.9em;
      color: #aaa;
    }
    
    .panel {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid #444;
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .control-group {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    
    input, button, select {
      margin: 0.5em;
      padding: 0.7em 1em;
      font-size: 1em;
      background: #333;
      color: var(--text-color);
      border: 1px solid #555;
      border-radius: 6px;
      transition: all 0.3s ease;
    }
    
    button {
      cursor: pointer;
      background: linear-gradient(to bottom, #444, #333);
      font-weight: bold;
    }
    
    button:hover:not(:disabled) {
      background: linear-gradient(to bottom, #555, #444);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .primary-btn {
      background: linear-gradient(to bottom, var(--primary-color), #e55d00);
      color: #fff;
      border: 1px solid #ff8533;
    }
    
    .secondary-btn {
      background: linear-gradient(to bottom, #555, #444);
      color: #fff;
    }
    
    .warning-btn {
      background: linear-gradient(to bottom, var(--warning-color), #e6b800);
      color: #000;
    }
    
    .emergency-btn {
      background: linear-gradient(to bottom, var(--error-color), #cc0000);
      color: #fff;
      animation: pulse-emergency 2s infinite;
    }
    
    @keyframes pulse-emergency {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    #debug {
      text-align: left;
      margin: 20px auto;
      padding: 10px;
      border: 1px dashed #555;
      color: #aaa;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9em;
      background: rgba(20, 20, 20, 0.8);
      border-radius: 5px;
    }
    
    .status {
      margin: 10px 0;
      padding: 8px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .success {
      background: rgba(0, 204, 102, 0.2);
      border: 1px solid var(--success-color);
      color: var(--success-color);
    }
    
    .error {
      background: rgba(255, 51, 51, 0.2);
      border: 1px solid var(--error-color);
      color: var(--error-color);
    }
    
    .warning {
      background: rgba(255, 204, 0, 0.2);
      border: 1px solid var(--warning-color);
      color: var(--warning-color);
    }
    
    .speed-indicator {
      font-size: 1em;
      margin-top: 5px;
      color: var(--accent-color);
      font-weight: bold;
    }
    
    .auto-lock-settings {
      margin-top: 10px;
      padding: 10px;
      border-top: 1px dashed #555;
    }
    
    .slider-label {
      display: inline-flex;
      align-items: center;
      margin-left: 5px;
      color: var(--accent-color);
    }
    
    .direction-container {
      position: relative;
      width: 100px;
      height: 100px;
      margin: 10px auto;
    }
    
    #directionArrow {
      width: 0; 
      height: 0; 
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 40px solid var(--primary-color);
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: 50% 0;
      transform: translate(-50%, -50%) rotate(0deg);
      transition: transform 0.3s ease;
    }
    
    .direction-circle {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 1px dashed var(--accent-color);
      border-radius: 50%;
      top: 0;
      left: 0;
      box-sizing: border-box;
    }
    
    .direction-status {
      font-size: 0.9em;
      margin-top: 5px;
    }
    
    #map {
      height: 250px;
      width: 100%;
      background: #222;
      border: 1px solid #555;
      border-radius: 8px;
      margin-top: 10px;
    }
    
    .user-marker, .lock-marker {
      font-size: 20px;
      text-shadow: 0 0 3px #000;
    }
    
    .leaflet-control-attribution {
      background: rgba(0, 0, 0, 0.7) !important;
      color: #aaa !important;
      font-family: monospace;
      font-size: 0.8em;
    }
    
    .reached-message {
      color: var(--success-color);
      font-weight: bold;
      animation: pulse 1.5s infinite;
    }
    
    button.muted {
      background: #f00 !important;
      color: #fff !important;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .lean-container {
      position: relative;
      width: 200px;
      height: 100px;
      margin: 10px auto;
      background: rgba(50, 50, 50, 0.7);
      border-radius: 100px 100px 0 0;
      overflow: hidden;
    }
    
    .lean-bike {
      position: absolute;
      width: 40px;
      height: 60px;
      background: var(--primary-color);
      border-radius: 10px 10px 0 0;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      transition: transform 0.1s ease; /* Faster transition for lean angle */
    }
    
    .lean-scale {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: space-around;
    }
    
    .lean-mark {
      width: 1px;
      height: 10px;
      background: #666;
      position: relative;
      top: 10px;
    }
    
    .lean-mark:nth-child(6) {
      height: 20px;
      background: var(--accent-color);
    }
    
    .lean-value {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-weight: bold;
      color: var(--accent-color);
    }
    
    .tabs {
      display: flex;
      margin-bottom: 10px;
      border-bottom: 1px solid #444;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
      margin-right: 5px;
      background: rgba(50, 50, 50, 0.7);
    }
    
    .tab.active {
      background: rgba(30, 30, 30, 0.9);
      border-color: #444;
      border-bottom: 1px solid rgba(30, 30, 30, 0.9);
      margin-bottom: -1px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .maintenance-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin: 5px 0;
      background: rgba(50, 50, 50, 0.5);
      border-radius: 5px;
    }
    
    .maintenance-progress {
      height: 10px;
      background: #333;
      border-radius: 5px;
      flex-grow: 1;
      margin: 0 10px;
      overflow: hidden;
    }
    
    .maintenance-progress-bar {
      height: 100%;
      background: linear-gradient(to right, var(--success-color), var(--warning-color), var(--error-color));
      border-radius: 5px;
    }
    
    .emergency-panel {
      background: rgba(204, 0, 0, 0.2);
      border: 1px solid var(--error-color);
    }
    
    .emergency-contacts {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin: 10px 0;
    }
    
    .contact-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: rgba(50, 50, 50, 0.7);
      border-radius: 5px;
      min-width: 120px;
    }
    
    .collapsible {
      cursor: pointer;
      padding: 10px;
      border: none;
      text-align: center;
      outline: none;
      font-size: 1em;
      color: var(--primary-color);
      background: transparent;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .collapsible:after {
      content: '‚ñº';
      font-size: 0.8em;
      margin-left: 5px;
      transition: transform 0.2s;
    }
    
    .collapsible.active:after {
      transform: rotate(180deg);
    }
    
    .collapsible-content {
      padding: 0 10px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.2s ease-out;
    }
    
    .corner-analysis {
      margin: 10px 0;
      padding: 10px;
      background: rgba(50, 50, 50, 0.5);
      border-radius: 5px;
      text-align: left;
    }
    
    .elevation-profile {
      height: 150px;
      background: #333;
      border-radius: 5px;
      margin: 10px 0;
      position: relative;
    }
      
      /* Triple-tap overlay styles */
.triple-tap-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  z-index: 10000;
  display: none;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

.triple-tap-overlay.active {
  display: flex;
}

.enlarged-wheel {
  width: 200px;
  height: 200px;
  position: relative;
  margin-bottom: 30px;
}

.enlarged-wheel .wheel-outer {
  fill: none;
  stroke: var(--primary-color);
  stroke-width: 4;
  stroke-dasharray: 5;
  animation: wheel-dash 1s linear infinite;
}

.enlarged-wheel .wheel-inner {
  fill: none;
  stroke: var(--accent-color);
  stroke-width: 3;
}

.enlarged-wheel .wheel-spoke {
  stroke: var(--accent-color);
  stroke-width: 3;
  transform-origin: center;
}

.enlarged-wheel .wheel-pulse {
  fill: var(--primary-color);
  animation: wheel-pulse 2s ease-in-out infinite;
}

.overlay-stats {
  text-align: center;
  background: rgba(40, 40, 40, 0.8);
  padding: 20px;
  border-radius: 15px;
  border: 2px solid var(--primary-color);
  min-width: 250px;
}

.overlay-stat-item {
  margin: 10px 0;
  font-size: 1.2em;
}

.overlay-stat-value {
  color: var(--accent-color);
  font-weight: bold;
  font-size: 1.4em;
}

.overlay-close-hint {
  position: absolute;
  bottom: 30px;
  color: #aaa;
  font-size: 0.9em;
}
    
    @media (max-width: 768px) {
      .dashboard {
        grid-template-columns: 1fr;
      }
      
      .app-header {
        flex-direction: column;
      }
      
      .control-group {
        flex-direction: column;
        align-items: center;
      }
      
      .wheel-container {
        margin-top: 10px;
      }
    }
  </style>
  </head>
  <body>
    <!-- Triple Tap Overlay -->
<div class="triple-tap-overlay" id="tripleTapOverlay">
  <div class="enlarged-wheel">
    <svg viewBox="0 0 100 100">
      <circle class="wheel-outer" cx="50" cy="50" r="40" />
      <circle class="wheel-inner" cx="50" cy="50" r="25" />
      <line class="wheel-spoke spoke-1" x1="50" y1="50" x2="75" y2="50" />
      <line class="wheel-spoke spoke-2" x1="50" y1="50" x2="50" y2="25" />
      <line class="wheel-spoke spoke-3" x1="50" y1="50" x2="30" y2="70" />
      <circle class="wheel-pulse" cx="50" cy="50" r="8" />
    </svg>
  </div>
  
  <div class="overlay-stats">
    <div class="overlay-stat-item">
      Average Speed: <span class="overlay-stat-value" id="overlayAvgSpeed">-- km/h</span>
    </div>
    <div class="overlay-stat-item">
      Current Lean: <span class="overlay-stat-value" id="overlayLeanAngle">--¬∞</span>
    </div>
    <div class="overlay-stat-item">
      Max Lean: <span class="overlay-stat-value" id="overlayMaxLean">--¬∞</span>
    </div>
    <div class="overlay-stat-item">
      Current Speed: <span class="overlay-stat-value" id="overlayCurrentSpeed">-- km/h</span>
    </div>
  </div>
  
  <div class="overlay-close-hint">Tap anywhere to close</div>
</div>
    <div class="app-header">
      <h1 class="app-title">Spin</h1>
      <div class="wheel-container">
        <svg class="spinning-wheel" viewBox="0 0 100 100">
          <circle class="wheel-outer" cx="50" cy="50" r="40"></circle>
          <circle class="wheel-inner" cx="50" cy="50" r="25"></circle>
          <line class="wheel-spoke spoke-1" x1="50" y1="50" x2="75" y2="50"></line>
          <line class="wheel-spoke spoke-2" x1="50" y1="50" x2="50" y2="25"></line>
          <line class="wheel-spoke spoke-3" x1="50" y1="50" x2="30" y2="70"></line>
          <circle class="wheel-pulse" cx="50" cy="50" r="8"></circle> </svg> </div>
    </div>
    <div class="dashboard">
      <div class="dashboard-item">
        <div class="dashboard-label">Current Speed</div>
        <div class="dashboard-value" id="currentSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Speed</div>
        <div class="dashboard-value" id="maxSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Average Speed</div>
        <div class="dashboard-value" id="avgSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Current Lean Angle</div>
        <div class="dashboard-value" id="leanAngle">--¬∞</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Today's Distance</div>
        <div class="dashboard-value" id="todayDistance">-- km</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Elevation Gain</div>
        <div class="dashboard-value" id="elevationGain">-- m</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Cornering Speed</div>
        <div class="dashboard-value" id="maxCornerSpeed">-- km/h</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">Max Corner G</div>
        <div class="dashboard-value" id="maxCornerG">-- g</div>
      </div>
      <div class="dashboard-item">
        <div class="dashboard-label">0-100 km/h</div>
        <div class="dashboard-value" id="accelerationTime">-- s</div>
      </div>
    </div>
    <div class="tabs">
      <div class="tab active" data-tab="navigation">Nav</div>
      <div class="tab" data-tab="metrics">Metrics</div>
      <div class="tab" data-tab="emergency">SOS</div>
      <div class="tab" data-tab="maintenance">Upkeep</div>
    </div>
      
    <div class="tab-content active" id="navigation-tab">
      <div class="panel">
        <h2>GPS Navigation</h2>
        <p class="warning">TAP "TEST AUDIO &amp; LOCK" FIRST!</p>
        <div class="control-group"> <button id="testBtn" class="primary-btn">Test
            Audio &amp; Lock</button> <button id="calibrateBtn" class="secondary-btn">Calibrate
            Sensors</button> <button id="autoLockBtn" class="secondary-btn" disabled="disabled">Auto-Lock
            Mode</button> <button id="muteBtn" class="secondary-btn" disabled="disabled">Mute
            Sound</button> <button id="stopBtn" class="secondary-btn" disabled="disabled">Stop</button>
        </div>
        <div id="autoLockSettings" style="display: none;">
          <div class="control-group">
            <div class="control-item"> <label for="stationaryTime">Stationary
                Confirmation Time</label>
              <div> <input id="stationaryTime" value="30" min="5" max="60" type="range">
                <span id="stationaryTimeValue" class="slider-label">30 sec</span>
              </div>
            </div>
            <div class="control-item"> <label for="speedThreshold">Speed
                Threshold (km/h)</label>
              <div> <input id="speedThreshold" value="10" min="5" max="20" type="range">
                <span id="speedThresholdValue" class="slider-label">10 km/h</span>
              </div>
            </div>
          </div>
        </div>
     
        <div id="calibrateStatus" class="status">Sensors not calibrated</div>
        <div id="lockStatus" class="status">Lock Status: Not locked</div>
        <div id="audioStatus" class="status">Audio: Not initialized</div>
        <div id="gpsStatus" class="status">GPS: Ready</div>
        <div id="reachedMessage" class="reached-message" style="display: none;">You
          have reached GPS locked point!</div>
      </div>
      <div class="panel">
        <h2>Position Map</h2>
        <div id="map"></div>
      </div>
      <div class="panel"> <button class="collapsible">Direction Indicator ‚ñº</button>
        <div class="collapsible-content">
          <div class="direction-container">
            <div id="directionArrow"></div>
            <div class="direction-circle"></div>
          </div>
          <div id="directionStatus" class="direction-status">Direction: --</div>
        </div>
        <button class="collapsible">Sonar Parameters ‚ñº</button>
        <div class="collapsible-content">
          <div class="control-group">
            <div class="control-item"> <label for="freqInput">Bleep Freq (Hz)</label><br>
              <input id="freqInput" value="800" min="20" max="20000" type="number">
            </div>
            <div class="control-item"> <label for="maxDistInput">Max Distance
                (m)</label><br>
              <input id="maxDistInput" value="50" min="1" max="500" type="range">
              <span id="maxDistValue">50</span> m </div>
          </div>
        </div>
        <button class="collapsible">Data Output ‚ñº</button>
        <div class="collapsible-content">
          <div class="control-group">
            <div class="control-item"> <label>Distance</label><br>
              <span id="distance">--</span> m </div>
            <div class="control-item"> <label>Accuracy</label><br>
              <span id="accuracy">--</span> m </div>
            <div class="control-item"> <label>BPM</label><br>
              <span id="bleepRate">--</span> </div>
          </div>
        </div>
    
      </div>
    </div>
    <div class="tab-content" id="metrics-tab">
      <div class="panel">
        <h2>Ride Metrics</h2>
        <div class="control-group"> <button id="startRideBtn" class="primary-btn">Start
            Ride</button> <button id="resetMetricsBtn" class="secondary-btn">Reset
            Metrics</button> <button id="exportMetricsBtn" class="secondary-btn">Export
            Data</button> </div>
        <div class="control-group">
          <div class="control-item"> <label for="accelTarget">Acceleration
              Target (km/h)</label><br>
            <input id="accelTarget" value="100" min="10" max="200" type="number">
          </div>
        </div>
        <div class="lean-container">
          <div class="lean-scale">
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
            <div class="lean-mark"></div>
          </div>
          <div class="lean-bike" id="leanBike"></div>
          <div class="lean-value" id="leanValue">0¬∞</div>
        </div>
        <div class="corner-analysis">
          <h3>Cornering Analysis</h3>
          <p>Current Corner G: <span id="currentCornerG">0 g</span></p>
          <p>Max Corner Speed: <span id="currentMaxCornerSpeed">0 km/h</span></p>
          <p>Avg Corner Lean: <span id="avgCornerLean">0¬∞</span></p>
          <div id="cornerList">No corners detected yet.</div>
        </div>
        <div class="elevation-profile">
          <h3>Elevation Profile</h3>
          <canvas id="elevationCanvas" width="100%" height="150"></canvas>
          <p>Total Elevation Gain: <span id="totalElevationGain">0 m</span></p>
        </div>
        <div class="control-group">
          <div class="control-item">
            <h3>Distance Statistics</h3>
            <div>Today: <span id="statsToday">0 km</span></div>
            <div>This Week: <span id="statsWeek">0 km</span></div>
            <div>This Month: <span id="statsMonth">0 km</span></div>
            <div>Total: <span id="statsTotal">0 km</span></div>
          </div>
          <div class="control-item">
            <h3>Speed Statistics</h3>
            <div>Current: <span id="statsCurrentSpeed">0 km/h</span></div>
            <div>Average: <span id="statsAvgSpeed">0 km/h</span></div>
            <div>Max: <span id="statsMaxSpeed">0 km/h</span></div>
            <div>0-100 km/h: <span id="statsAcceleration">-- s</span></div>
          </div>
        </div>
        <!-- Add to Metrics tab -->
<div class="panel">
  <h3>Engine Sound Analysis</h3>
  
  <div class="control-group">
    <button id="startEngineAnalysis" class="primary-btn">Start Engine Analysis</button>
    <button id="calibrateEngine" class="secondary-btn">Calibrate Engine</button>
  </div>
  
  <div class="dashboard">
    <div class="dashboard-item">
      <div class="dashboard-label">Engine RPM</div>
      <div class="dashboard-value" id="engineRPM">--</div>
    </div>
    <div class="dashboard-item">
      <div class="dashboard-label">Estimated Gear</div>
      <div class="dashboard-value" id="engineGear">--</div>
    </div>
    <div class="dashboard-item">
      <div class="dashboard-label">Engine Health</div>
      <div class="dashboard-value" id="engineHealth">--</div>
    </div>
    <div class="dashboard-item">
      <div class="dashboard-label">Sound Level</div>
      <div class="dashboard-value" id="engineVolume">-- dB</div>
    </div>
  </div>

  <div class="control-group">
    <div class="control-item">
      <h4>Shift Analysis</h4>
      <div>Total Shifts: <span id="totalShifts">0</span></div>
      <div>Last Shift Quality: <span id="lastShiftQuality">--</span></div>
      <div>Avg Shift RPM: <span id="avgShiftRPM">--</span></div>
    </div>
  </div>
  
  <!-- Real-time frequency visualization -->
  <div class="control-item">
    <h4>Sound Spectrum</h4>
    <canvas id="frequencyCanvas" width="100%" height="100" style="background: #222; border-radius: 5px;"></canvas>
  </div>
</div>
            <div class="panel">
          <h3>Cornering Analysis</h3>
          <!-- Add this canvas for the corner chart --> <canvas id="cornerChart"
            width="100%"
            height="200"></canvas>
          <!-- Your existing corner analysis content -->
          <p>Current Corner G: <span id="currentCornerG">0 g</span></p>
          <p>Max Corner Speed: <span id="currentMaxCornerSpeed">0 km/h</span></p>
          <p>Avg Corner Lean: <span id="avgCornerLean">0¬∞</span></p>
          <p>Avg Corner Entry Speed: <span id="avgCornerEntrySpeed">0 km/h</span></p>
          <div id="cornerList">No corners detected yet.</div>
        </div>  
        <div class="control-item">
          <h3>Ride History</h3>
          <div id="rideHistory" style="max-height: 200px; overflow-y: auto; text-align: left; padding: 10px; background: rgba(40,40,40,0.7); border-radius: 5px;">
            No ride history yet. </div>
        </div>
      </div>
    </div>
    

  
    <div class="tab-content" id="emergency-tab">
  <div class="panel emergency-panel">
    <h2>Emergency Features</h2>
    
    <div class="control-group">
      <button id="emergencyBtn" class="emergency-btn">EMERGENCY ALERT</button>
    </div>
    
    <div id="crashStatus" class="status">Crash Detection: Inactive</div>
    
    <div class="control-group">
      <div class="control-item">
        <label for="emergencyMessage">Emergency Message</label><br>
        <textarea id="emergencyMessage" rows="3" style="width: 100%;">I need help! My current location is: </textarea>
      </div>
    </div>
    
    <h3>Emergency Contacts</h3>
    <div class="emergency-contacts" id="emergencyContactList">
      <!-- Contacts will appear here -->
    </div>
    
    <div class="control-group">
      <button id="addContactBtn" class="primary-btn">‚ûï Add Contact</button>
      <button id="testEmergencyBtn" class="warning-btn">Test Emergency</button>
      <button id="callEmergencyBtn" class="emergency-btn" onclick="MotoFindBack.callEmergency()">Call 112/911</button>
    </div>

    <!-- Add Contact Modal -->
    <div id="addContactModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center;">
      <div style="background: #333; padding: 20px; border-radius: 10px; width: 90%; max-width: 400px;">
        <h3>Add Emergency Contact</h3>
        <input type="text" id="newContactName" placeholder="Contact Name" style="width: 100%; margin: 10px 0; padding: 10px; background: #444; color: white; border: 1px solid #555; border-radius: 5px;">
        <input type="text" id="newContactNumber" placeholder="Phone Number" style="width: 100%; margin: 10px 0; padding: 10px; background: #444; color: white; border: 1px solid #555; border-radius: 5px;">
        <div style="display: flex; gap: 10px; margin-top: 15px;">
          <button onclick="MotoFindBack.saveNewContact()" class="primary-btn" style="flex: 1;">Save</button>
          <button onclick="MotoFindBack.closeContactModal()" class="secondary-btn" style="flex: 1;">Cancel</button>
        </div>
      </div>
    </div>
  </div>
</div>
        
    <div class="tab-content" id="maintenance-tab">
      <div class="panel">
        <h2>Maintenance Alerts</h2>
        <div class="control-group"> <button id="addMaintenanceBtn" class="primary-btn">Add
            Maintenance Item</button> <button id="resetMaintenanceBtn" class="secondary-btn">Reset
            All</button> </div>
        <div id="maintenanceList">
          <div class="maintenance-item">
            <div>Oil Change</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 30%;"></div>
            </div>
            <div>2000/5000 km</div>
          </div>
          <div class="maintenance-item">
            <div>Tire Pressure</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 70%;"></div>
            </div>
            <div>Check weekly</div>
          </div>
          <div class="maintenance-item">
            <div>Chain Lubrication</div>
            <div class="maintenance-progress">
              <div class="maintenance-progress-bar" style="width: 50%;"></div>
            </div>
            <div>500/1000 km</div>
          </div>
        </div>
        <div class="control-group">
          <div class="control-item">
            <h3>Add New Maintenance Item</h3>
            <input id="newMaintenanceName" placeholder="Item name" type="text">
            <input id="newMaintenanceInterval" placeholder="Interval (km)" type="number">
            <button id="saveMaintenanceBtn" class="secondary-btn">Save</button>
          </div>
        </div>
      </div>
    </div>
    <div class="panel">
      <h2 class="help-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
        Help Guide ‚ñº </h2>
      <div id="helpContent" style="display: none; text-align: left; padding: 10px;">
        <h1>Spin</h1>
        <h2>Purpose:</h2>
        Motorcycle-focused GPS navigation with ride metrics, emergency features,
        and maintenance tracking. The spinning wheel in the header rotates to
        reflect your current speed, spinning faster as you ride faster.
        <h2>Navigation Tab</h2>
        <strong>GPS Navigation:</strong> Lock your position and navigate back
        with audio cues.<br>
        <strong>Calibrate Sensors:</strong> Place phone on bike in riding
        position and tap to set baseline for lean angle and crash detection.<br>
        <strong>Auto-Lock Mode:</strong> Automatically locks position when
        motorcycle is stationary.<br>
        <strong>Direction Indicator:</strong> Visual compass pointing to locked
        position.<br>
        <strong>Sonar Parameters:</strong> Adjust audio feedback frequency and
        range.
        <h2>Metrics Tab</h2>
        <strong>Ride Metrics:</strong> Track speed, distance, acceleration, and
        lean angles with real-time updates.<br>
        <strong>Cornering Analysis:</strong> Detects corners using GPS curvature
        and lean angle, calculates cornering G and speeds.<br>
        <strong>Elevation Gain:</strong> Tracks altitude changes using GPS data,
        with a profile chart.<br>
        <strong>Lean Angle Indicator:</strong> Visual display of motorcycle lean
        during corners, updated rapidly for responsiveness.<br>
        <strong>Distance Statistics:</strong> Daily, weekly, monthly, and total
        distance tracking.<br>
        <strong>Acceleration Timer:</strong> Measures 0-100 km/h acceleration.
        <h2>Emergency Tab</h2>
        <strong>Emergency Alert:</strong> Send your location to emergency
        contacts manually.<br>
        <strong>Crash Detection:</strong> Automatically sends location to
        contacts if bike is detected lying flat for 5 seconds.<br>
        <strong>Quick Contacts:</strong> Pre-set emergency contacts for quick
        access.<br>
        <strong>Custom Message:</strong> Edit the emergency message with your
        details.
        <h2>Maintenance Tab</h2>
        <strong>Maintenance Alerts:</strong> Track service intervals based on
        mileage.<br>
        <strong>Progress Indicators:</strong> Visual progress bars for each
        maintenance item.<br>
        <strong>Custom Items:</strong> Add your own maintenance tasks and
        intervals.
        <h2>Quick Start</h2>
        1. Mount phone securely and tap "Calibrate Sensors" to set lean angle
        and crash detection baseline.<br>
        2. Set emergency contacts in the Emergency tab.<br>
        3. Tap "Test Audio &amp; Lock" to initialize the app.<br>
        4. Use the Navigation tab to lock your parking position.<br>
        5. Check the Metrics tab during your ride for performance data; watch
        the header wheel spin with your speed.<br>
        6. Add maintenance schedules in the Maintenance tab.
        <h2>Tips</h2>
        - For accurate lean angles and crash detection, mount your phone
        securely on the motorcycle and calibrate sensors.<br>
        - Set up emergency contacts before your first ride to enable crash
        detection alerts.<br>
        - Regular maintenance alerts help keep your motorcycle in top condition.<br>
        - Export your ride data to track your riding habits over time. </div>
    </div>
    <div id="debug"></div>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
const MotoFindBack = {
  audioCtx: null,
  watchId: null,
  bleepTimer: null,
  lockPosition: null,
  lastUpdateTime: Date.now(),
  lastBleedTime: 0,
  isAudioAllowed: false,
  isActive: false,
  isRideActive: false,
  movementHistory: [],
  currentTempo: 1000,
  autoLockEnabled: false,
  autoLockDebounce: null,
  currentSpeed: 0,
  reachedPointDisplayed: false,
  isMuted: false,
  isStationary: false,
  lastStationaryTime: null,
  lastStationaryPosition: null,
  speedThreshold: 10,
  maxSpeed: 0,
  totalDistance: 0,
  todayDistance: 0,
  weekDistance: 0,
  monthDistance: 0,
  elevationGain: 0,
  rideStartTime: null,
  accelerationStartTime: null,
  accelerationStartSpeed: 0,
  accelerationTimes: [],
  maxLeanAngle: 0,
  currentLeanAngle: 0,
  currentCornerG: 0,
  maxCornerG: 0,
  maxCornerSpeed: 0,
  corners: [],
  cornerEntrySpeeds: [],
  cornerExitSpeeds: [],
  maintenanceItems: [],
  emergencyContacts: [],
  rideHistory: [],
  isCalibrating: false,
  calibrationSamples: [],
  leanOffset: 0,
  crashDetected: false,
  crashStartTime: null,
  lastPosition: null,
  prevPosition: null,
  rotationSpeed: 0,
  map: null,
  userMarker: null,
  lockMarker: null,
  line: null,
  accelTarget: 100,
  elevationHistory: [],
  canvas: null, // Will store the canvas element
  cornerChart: null,
  tripleTapCount: 0,
tripleTapTimeout: null,
lastTapTime: 0,
isOverlayVisible: false,
  audioAnalysis: {
  audioContext: null,
  analyser: null,
  microphone: null,
  javascriptNode: null,
  isListening: false,
  engineRPM: 0,
  gearPosition: 0,
  engineHealth: 'Good',
  soundProfile: null,
  lastShiftTime: 0,
  maxDb: 0,
   frequencyData: new Uint8Array(1024)
},

  init: async function() {
    this.initMap();
  this.loadContactsFromStorage();
  this.setupTripleTapDetection();
    this.canvas = document.getElementById('elevationCanvas'); // Store the canvas element
    if (!this.canvas) {
      this.log("Error: elevationCanvas element not found", true);
      return;
    }
    this.cornerChart = new Chart(document.getElementById('cornerChart').getContext('2d'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Corner G-Force',
          data: [],
          borderColor: '#00ccff',
          backgroundColor: 'rgba(0, 204, 255, 0.2)',
          fill: true,
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        scales: {
          y: { beginAtZero: true, title: { display: true, text: 'G-Force (g)' } },
          x: { title: { display: true, text: 'Corner Number' } }
        }
      }
    });
    this.setupEventListeners();
    this.setupTabs();
    this.setupCollapsibles();
    this.loadData();
    this.updateUI();
    this.log("MotoFindBack initialized");
    this.initDeviceOrientation();

    document.getElementById("maxDistInput").addEventListener("input", (e) => {
      document.getElementById("maxDistValue").textContent = e.target.value;
    });

    document.getElementById("stationaryTime").addEventListener("input", (e) => {
      document.getElementById("stationaryTimeValue").textContent = e.target.value + ' sec';
    });

    document.getElementById("speedThreshold").addEventListener("input", (e) => {
      this.speedThreshold = parseFloat(e.target.value);
      document.getElementById("speedThresholdValue").textContent = e.target.value + ' km/h';
    });
      
      document.getElementById("addContactBtn").addEventListener("click", () => this.showContactModal());

    document.getElementById("accelTarget").addEventListener("input", (e) => {
      this.accelTarget = parseFloat(e.target.value) || 100;
      const label = document.querySelector('#accelerationTime').previousElementSibling;
      if (label) label.textContent = `0-${this.accelTarget} km/h`;
      const statsLabel = document.querySelector('#statsAcceleration').previousElementSibling;
      if (statsLabel) statsLabel.textContent = `0-${this.accelTarget} km/h`;
    });

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(reg => {
        this.log('Service Worker registered');
      }).catch(err => {
        this.log('Service Worker registration failed: ' + err, true);
      });
    }
  },
    
    
    // Microphone initialization
initMicrophone: function() {
  return new Promise((resolve, reject) => {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      this.log('Microphone access not available');
      reject('Microphone not supported');
      return;
    }

    navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      } 
    }).then(stream => {
      this.audioAnalysis.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.audioAnalysis.analyser = this.audioAnalysis.audioContext.createAnalyser();
      this.audioAnalysis.microphone = this.audioAnalysis.audioContext.createMediaStreamSource(stream);
      
      this.audioAnalysis.analyser.fftSize = 2048;
      this.audioAnalysis.analyser.smoothingTimeConstant = 0.8;
      
      this.audioAnalysis.microphone.connect(this.audioAnalysis.analyser);
      
      this.audioAnalysis.javascriptNode = this.audioAnalysis.audioContext.createScriptProcessor(2048, 1, 1);
      this.audioAnalysis.analyser.connect(this.audioAnalysis.javascriptNode);
      this.audioAnalysis.javascriptNode.connect(this.audioAnalysis.audioContext.destination);
      
      this.audioAnalysis.javascriptNode.onaudioprocess = () => {
        this.analyzeEngineSound();
      };
      
      this.audioAnalysis.isListening = true;
      this.log('Microphone initialized for engine analysis');
      resolve();
    }).catch(error => {
      this.log('Microphone access denied: ' + error.message, true);
      reject(error);
    });
  });
},

// Engine sound analysis
analyzeEngineSound: function() {
  if (!this.audioAnalysis.analyser) return;
  
  // Get frequency data
  this.audioAnalysis.analyser.getByteFrequencyData(this.audioAnalysis.frequencyData);
  
  // Calculate dominant frequency (engine RPM correlate)
  const dominantFreq = this.findDominantFrequency();
  this.audioAnalysis.engineRPM = this.frequencyToRPM(dominantFreq);
  
  // Analyze engine health
  this.analyzeEngineHealth();
  
  // Detect gear shifts
  this.detectGearShifts();
  
  // Estimate current gear
  this.estimateGearPosition();
  
  // Detect engine problems
  this.detectEngineProblems();
  
  // Update UI
  this.updateEngineDisplay();
},

findDominantFrequency: function() {
  let maxVolume = 0;
  let dominantFreq = 0;
  
  for (let i = 0; i < this.audioAnalysis.frequencyData.length; i++) {
    if (this.audioAnalysis.frequencyData[i] > maxVolume) {
      maxVolume = this.audioAnalysis.frequencyData[i];
      dominantFreq = i * (this.audioAnalysis.audioContext.sampleRate / 2) / this.audioAnalysis.frequencyData.length;
    }
  }
  
  this.audioAnalysis.maxDb = maxVolume;
  return dominantFreq;
},

frequencyToRPM: function(frequency) {
  // This is a simplified conversion - would need calibration for specific bikes
  // Typical motorcycle engines: 1000-12000 RPM
  // 2-stroke: firing every revolution, 4-stroke: every other revolution
  const isFourStroke = true; // Assume 4-stroke for most bikes
  const cylinders = 2; // Assume 2 cylinders for calibration
  
  if (isFourStroke) {
    return (frequency * 60 * 2) / cylinders;
  } else {
    return (frequency * 60) / cylinders;
  }
},

// Engine health monitoring
analyzeEngineHealth: function() {
  const frequencies = Array.from(this.audioAnalysis.frequencyData);
  
  // Check for unusual vibrations/patterns
  const unusualHarmonics = this.detectUnusualHarmonics(frequencies);
  const engineKnock = this.detectEngineKnock(frequencies);
  const exhaustLeak = this.detectExhaustLeak(frequencies);
  
  if (engineKnock.detected) {
    this.audioAnalysis.engineHealth = 'Knocking Detected';
    this.log(`üö® Engine knock detected: ${engineKnock.severity}`);
    this.triggerMaintenanceAlert('Engine knock detected - check oil and fuel quality');
  } else if (exhaustLeak.detected) {
    this.audioAnalysis.engineHealth = 'Possible Exhaust Leak';
    this.log(`‚ö†Ô∏è Possible exhaust leak detected`);
  } else if (unusualHarmonics) {
    this.audioAnalysis.engineHealth = 'Unusual Vibrations';
  } else {
    this.audioAnalysis.engineHealth = 'Normal';
  }
},

detectUnusualHarmonics: function(frequencies) {
  // Look for unexpected harmonic patterns that might indicate issues
  const fundamental = this.findDominantFrequency();
  const expectedHarmonics = [fundamental * 2, fundamental * 3, fundamental * 4];
  
  let unusualCount = 0;
  expectedHarmonics.forEach(harmonic => {
    const bin = Math.floor(harmonic * this.audioAnalysis.frequencyData.length / (this.audioAnalysis.audioContext.sampleRate / 2));
    if (frequencies[bin] > frequencies[Math.floor(fundamental)] * 0.8) {
      unusualCount++;
    }
  });
  
  return unusualCount > 1;
},

detectEngineKnock: function(frequencies) {
  // Engine knock typically appears as high-frequency spikes
  const highFreqStart = Math.floor(this.audioAnalysis.frequencyData.length * 0.7);
  let highFreqEnergy = 0;
  
  for (let i = highFreqStart; i < this.audioAnalysis.frequencyData.length; i++) {
    highFreqEnergy += frequencies[i];
  }
  
  const avgHighFreq = highFreqEnergy / (this.audioAnalysis.frequencyData.length - highFreqStart);
  const fundamentalEnergy = frequencies[this.findDominantFrequency()];
  
  return {
    detected: avgHighFreq > fundamentalEnergy * 0.3,
    severity: avgHighFreq / fundamentalEnergy
  };
},

detectExhaustLeak: function(frequencies) {
  // Exhaust leaks often create broadband noise
  let totalEnergy = 0;
  let peakEnergy = 0;
  
  for (let i = 0; i < frequencies.length; i++) {
    totalEnergy += frequencies[i];
    if (frequencies[i] > peakEnergy) peakEnergy = frequencies[i];
  }
  
  const avgEnergy = totalEnergy / frequencies.length;
  const broadbandRatio = avgEnergy / peakEnergy;
  
  return {
    detected: broadbandRatio > 0.4,
    ratio: broadbandRatio
  };
},

// Gear shift detection
detectGearShifts: function() {
  const currentTime = Date.now();
  const rpm = this.audioAnalysis.engineRPM;
  
  // Detect rapid RPM drop followed by stabilization (gear shift)
  if (this.lastRPM && rpm < this.lastRPM * 0.6 && currentTime - this.audioAnalysis.lastShiftTime > 2000) {
    // Possible gear shift detected
    this.audioAnalysis.lastShiftTime = currentTime;
    this.gearShiftEvents = this.gearShiftEvents || [];
    this.gearShiftEvents.push({
      time: currentTime,
      fromRPM: this.lastRPM,
      toRPM: rpm,
      speed: this.currentSpeed * 3.6
    });
    
    this.log(`‚¨ÜÔ∏è Gear shift detected at ${this.currentSpeed * 3.6} km/h`);
    this.analyzeShiftQuality(this.lastRPM, rpm);
  }
  
  this.lastRPM = rpm;
},

analyzeShiftQuality: function(fromRPM, toRPM) {
  const rpmDropRatio = toRPM / fromRPM;
  let shiftQuality = 'Good';
  
  if (rpmDropRatio < 0.4) shiftQuality = 'Hard';
  if (rpmDropRatio > 0.7) shiftQuality = 'Soft';
  if (Math.abs(fromRPM - toRPM) < 500) shiftQuality = 'Clutch Slipping';
  
  this.log(`Shift quality: ${shiftQuality} (${fromRPM.toFixed(0)} ‚Üí ${toRPM.toFixed(0)} RPM)`);
},

estimateGearPosition: function() {
  if (this.currentSpeed === 0 || this.audioAnalysis.engineRPM === 0) {
    this.audioAnalysis.gearPosition = 0; // Neutral or stopped
    return;
  }
  
  // Simplified gear estimation based on speed/RPM ratio
  const ratio = (this.currentSpeed * 3.6) / this.audioAnalysis.engineRPM;
  
  if (ratio < 0.02) this.audioAnalysis.gearPosition = 1;
  else if (ratio < 0.035) this.audioAnalysis.gearPosition = 2;
  else if (ratio < 0.05) this.audioAnalysis.gearPosition = 3;
  else if (ratio < 0.065) this.audioAnalysis.gearPosition = 4;
  else if (ratio < 0.08) this.audioAnalysis.gearPosition = 5;
  else this.audioAnalysis.gearPosition = 6;
},

// Engine problem detection
detectEngineProblems: function() {
  const currentTime = Date.now();
  
  // Misfire detection (irregular engine sound)
  const regularity = this.analyzeEngineRegularity();
  if (regularity < 0.7) {
    this.log('‚ö†Ô∏è Possible engine misfire detected');
  }
  
  // Over-revving protection
  if (this.audioAnalysis.engineRPM > 10000 && this.currentSpeed > 0) {
    this.log('üö® Engine over-revving detected!');
    this.triggerOverRevAlert();
  }
  
  // Lugging detection (too low RPM for speed)
  if (this.audioAnalysis.engineRPM < 2000 && this.currentSpeed > 30) {
    this.log('‚ö†Ô∏è Engine lugging detected - downshift recommended');
  }
},

analyzeEngineRegularity: function() {
  // Analyze how regular the engine pulses are
  const recentRPMS = this.rpmHistory || [];
  recentRPMS.push(this.audioAnalysis.engineRPM);
  
  if (recentRPMS.length > 50) recentRPMS.shift();
  this.rpmHistory = recentRPMS;
  
  if (recentRPMS.length < 10) return 1.0;
  
  // Calculate coefficient of variation
  const mean = recentRPMS.reduce((a, b) => a + b) / recentRPMS.length;
  const variance = recentRPMS.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recentRPMS.length;
  const stdDev = Math.sqrt(variance);
  const cv = stdDev / mean;
  
  return Math.max(0, 1 - cv);
},

// UI Updates
updateEngineDisplay: function() {
  if (!document.getElementById('engineRPM')) return;
  
  document.getElementById('engineRPM').textContent = Math.round(this.audioAnalysis.engineRPM) + ' RPM';
  document.getElementById('engineGear').textContent = this.audioAnalysis.gearPosition;
  document.getElementById('engineHealth').textContent = this.audioAnalysis.engineHealth;
  document.getElementById('engineVolume').textContent = this.audioAnalysis.maxDb + ' dB';
},
    
// Triple-tap detection setup
setupTripleTapDetection: function() {
  document.addEventListener('click', (e) => {
    this.handleTripleTap(e);
  });
  
  // Also close overlay when clicking on it
  document.getElementById('tripleTapOverlay').addEventListener('click', (e) => {
    this.hideOverlay();
  });
},

handleTripleTap: function(e) {
  const currentTime = Date.now();
  const timeSinceLastTap = currentTime - this.lastTapTime;
  
  // Reset if too much time passed between taps (500ms max between taps)
  if (timeSinceLastTap > 500) {
    this.tripleTapCount = 1;
  } else {
    this.tripleTapCount++;
  }
  
  this.lastTapTime = currentTime;
  
  // Clear existing timeout
  if (this.tripleTapTimeout) {
    clearTimeout(this.tripleTapTimeout);
  }
  
  // Check for triple tap
  if (this.tripleTapCount >= 3) {
    this.tripleTapCount = 0;
    this.showOverlay();
    return;
  }
  
  // Reset counter after timeout
  this.tripleTapTimeout = setTimeout(() => {
    this.tripleTapCount = 0;
  }, 500);
},

showOverlay: function() {
  if (this.isOverlayVisible) return;
  
  this.isOverlayVisible = true;
  const overlay = document.getElementById('tripleTapOverlay');
  overlay.classList.add('active');
  
  // Update stats
  this.updateOverlayStats();
  
  // Start animation for enlarged wheel
  this.updateEnlargedWheelAnimation();
  
  this.log("Triple-tap overlay shown");
},

hideOverlay: function() {
  if (!this.isOverlayVisible) return;
  
  this.isOverlayVisible = false;
  const overlay = document.getElementById('tripleTapOverlay');
  overlay.classList.remove('active');
  
  this.log("Triple-tap overlay hidden");
},

updateOverlayStats: function() {
  document.getElementById('overlayAvgSpeed').textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
  document.getElementById('overlayLeanAngle').textContent = this.currentLeanAngle + "¬∞";
  document.getElementById('overlayMaxLean').textContent = this.maxLeanAngle + "¬∞";
  document.getElementById('overlayCurrentSpeed').textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
},

updateEnlargedWheelAnimation: function() {
  const enlargedWheel = document.querySelector('.enlarged-wheel');
  const enlargedSpokes = document.querySelectorAll('.enlarged-wheel .wheel-spoke');
  
  if (this.currentSpeed <= 0.1) {
    enlargedWheel.style.animation = 'none';
    enlargedSpokes.forEach(spoke => spoke.style.animation = 'none');
  } else {
    const speedKmh = this.currentSpeed * 3.6;
    const rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
    enlargedWheel.style.animation = `wheel-spin ${rotationSpeed}s linear infinite`;
    enlargedSpokes.forEach((spoke, index) => {
      const spokeSpeed = rotationSpeed * (1 + index * 0.5);
      spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
    });
  }
},

// Update your existing updateWheelAnimation function to also update the enlarged wheel:
updateWheelAnimation: function() {
  const wheel = document.querySelector('.spinning-wheel');
  const spokes = document.querySelectorAll('.wheel-spoke');
  
  if (this.currentSpeed <= 0.1) {
    wheel.style.animation = 'none';
    spokes.forEach(spoke => spoke.style.animation = 'none');
  } else {
    const speedKmh = this.currentSpeed * 3.6;
    this.rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
    wheel.style.animation = `wheel-spin ${this.rotationSpeed}s linear infinite`;
    spokes.forEach((spoke, index) => {
      const spokeSpeed = this.rotationSpeed * (1 + index * 0.5);
      spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
    });
  }
  
  // Also update enlarged wheel if visible
  if (this.isOverlayVisible) {
    this.updateEnlargedWheelAnimation();
  }
},

  updateElevationProfile: function() {
    if (!this.canvas) {
      this.log("Error: canvas not initialized", true);
      return;
    }
    const ctx = this.canvas.getContext('2d'); // Get context here
    if (!ctx) {
      this.log("Error: Unable to get 2D context for elevationCanvas", true);
      return;
    }
    this.canvas.width = this.canvas.parentElement.offsetWidth; // Reset width to handle resizing
    const w = this.canvas.width;
    const h = this.canvas.height;
    ctx.clearRect(0, 0, w, h);

    if (this.elevationHistory.length < 2) {
      this.log("Not enough elevation data to plot");
      return;
    }

    const smoothedElevations = [];
    for (let i = 0; i < this.elevationHistory.length; i++) {
      const start = Math.max(0, i - 1);
      const end = Math.min(this.elevationHistory.length - 1, i + 1);
      const avgElev = this.elevationHistory.slice(start, end + 1)
        .reduce((sum, p) => sum + p.elev, 0) / (end - start + 1);
      smoothedElevations.push(avgElev);
    }

    const minElev = Math.min(...smoothedElevations);
    const maxElev = Math.max(...smoothedElevations);
    const range = maxElev - minElev || 1;

    ctx.beginPath();
    ctx.moveTo(0, h);
    smoothedElevations.forEach((elev, i) => {
      const x = (i / (smoothedElevations.length - 1)) * w;
      const y = h - ((elev - minElev) / range * h * 0.8);
      ctx.lineTo(x, y);
    });
    ctx.strokeStyle = 'var(--accent-color)';
    ctx.lineWidth = 2;
    ctx.stroke();

    document.getElementById('totalElevationGain').textContent = this.elevationGain.toFixed(0) + ' m';
    document.getElementById('elevationGain').textContent = this.elevationGain.toFixed(0) + ' m';
    document.getElementById('maxElevation').textContent = maxElev.toFixed(0) + ' m';
    document.getElementById('minElevation').textContent = minElev.toFixed(0) + ' m';
  },

  // Remaining methods (unchanged from previous response)
  initMap: function() {
    this.map = L.map('map').setView([51.505, -0.09], 15);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(this.map);

    const userIcon = L.divIcon({ className: 'user-marker', html: 'üìç', iconSize: [24, 24] });
    const lockIcon = L.divIcon({ className: 'lock-marker', html: 'üîí', iconSize: [24, 24] });
    this.userMarker = L.marker([0, 0], { icon: userIcon }).addTo(this.map);
    this.lockMarker = L.marker([0, 0], { icon: lockIcon }).addTo(this.map);
    this.line = L.polyline([], { color: '#ff6600', weight: 2 }).addTo(this.map);
  },

  setupTabs: function() {
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
      });
    });
  },

  setupCollapsibles: function() {
    const coll = document.getElementsByClassName("collapsible");
    for (let i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        const content = this.nextElementSibling;
        content.style.maxHeight = content.style.maxHeight ? null : content.scrollHeight + "px";
      });
    }
  },

  setupEventListeners: function() {
    document.getElementById("testBtn").addEventListener("click", () => {
      this.initAudio();
      this.playTestSound();
      if (this.isAudioAllowed) this.lockCurrentPosition();
    });
    document.getElementById("calibrateBtn").addEventListener("click", () => this.calibrateSensors());
    document.getElementById("autoLockBtn").addEventListener("click", () => this.toggleAutoLock());
    document.getElementById("muteBtn").addEventListener("click", () => this.toggleMute());
    document.getElementById("stopBtn").addEventListener("click", () => this.stop());
    document.getElementById("startRideBtn").addEventListener("click", () => this.startRide());
    document.getElementById("resetMetricsBtn").addEventListener("click", () => this.resetMetrics());
    document.getElementById("exportMetricsBtn").addEventListener("click", () => this.exportMetrics());
    document.getElementById("emergencyBtn").addEventListener("click", () => this.sendEmergencyAlert());
    document.getElementById("testEmergencyBtn").addEventListener("click", () => this.testEmergency());
    document.getElementById("addContactBtn").addEventListener("click", () => this.addEmergencyContact());
    document.getElementById("addMaintenanceBtn").addEventListener("click", () => this.showMaintenanceForm());
    document.getElementById("resetMaintenanceBtn").addEventListener("click", () => this.resetMaintenance());
    document.getElementById("saveMaintenanceBtn").addEventListener("click", () => this.saveMaintenanceItem());
  },

  initDeviceOrientation: function() {
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', (event) => {
        if (this.isCalibrating) {
          this.calibrationSamples.push(event.gamma || 0);
          return;
        }
        if (event.gamma !== null) {
          this.currentLeanAngle = Math.round(Math.abs(event.gamma - this.leanOffset));
          this.updateLeanAngleDisplay();
          if (this.currentLeanAngle > this.maxLeanAngle) this.maxLeanAngle = this.currentLeanAngle;
          const speedMs = this.currentSpeed;
          this.currentCornerG = this.calculateCornerG(speedMs, this.currentLeanAngle);
          this.detectCorner(this.lastPosition?.lat, this.lastPosition?.lon, speedMs * 3.6, this.currentLeanAngle, this.currentCornerG);
        }
        if (event.beta !== null && !this.crashDetected) {
          const betaAbs = Math.abs(event.beta);
          if (betaAbs > 70) {
            if (!this.crashStartTime) {
              this.crashStartTime = Date.now();
              document.getElementById('crashStatus').textContent = 'Possible crash detected... Confirming';
              document.getElementById('crashStatus').className = 'status warning';
              this.log('Possible crash detected, confirming for 5 seconds');
            }
            if (Date.now() - this.crashStartTime > 5000) {
              this.crashDetected = true;
              this.triggerCrashAlert();
            }
          } else if (this.crashStartTime) {
            this.crashStartTime = null;
            document.getElementById('crashStatus').textContent = 'Crash Detection: Inactive';
            document.getElementById('crashStatus').className = 'status';
            this.log('Crash condition cleared');
          }
        }
      });
    } else {
      this.log("Device orientation not supported", true);
      document.getElementById('crashStatus').textContent = 'Crash Detection: Not supported';
      document.getElementById('crashStatus').className = 'status error';
    }
  },

  calibrateSensors: function() {
    this.isCalibrating = true;
    this.calibrationSamples = [];
    document.getElementById('calibrateStatus').textContent = 'Calibrating... Keep phone steady for 5 seconds.';
    this.log('Starting sensor calibration');
    setTimeout(() => {
      if (this.calibrationSamples.length > 0) {
        const avgGamma = this.calibrationSamples.reduce((a, b) => a + b, 0) / this.calibrationSamples.length;
        this.leanOffset = avgGamma;
        document.getElementById('calibrateStatus').textContent = 'Calibrated! Offset: ' + this.leanOffset.toFixed(1) + '¬∞';
        document.getElementById('calibrateStatus').className = 'status success';
        this.log('Calibration complete: offset ' + this.leanOffset.toFixed(1) + '¬∞');
      } else {
        document.getElementById('calibrateStatus').textContent = 'Calibration failed - no data';
        document.getElementById('calibrateStatus').className = 'status error';
        this.log('Calibration failed');
      }
      this.isCalibrating = false;
    }, 5000);
  },



  updateLeanAngleDisplay: function() {
    const leanBike = document.getElementById('leanBike');
    const leanValue = document.getElementById('leanValue');
    const dashboardLean = document.getElementById('leanAngle');
    const displayAngle = Math.min(45, this.currentLeanAngle);
    leanBike.style.transform = `translateX(-50%) rotate(${displayAngle}deg)`;
    leanValue.textContent = `${this.currentLeanAngle}¬∞`;
    dashboardLean.textContent = `${this.currentLeanAngle}¬∞`;
    this.log(`Lean angle updated: ${this.currentLeanAngle}¬∞`);
   if (this.isOverlayVisible) {
    document.getElementById('overlayLeanAngle').textContent = this.currentLeanAngle + "¬∞";
    if (this.currentLeanAngle > this.maxLeanAngle) {
      document.getElementById('overlayMaxLean').textContent = this.maxLeanAngle + "¬∞";
    }
  }
},

  calculateCornerG: function(speedMs, leanAngle) {
    return Math.tan(leanAngle * Math.PI / 180);
  },

  detectCorner: function(lat, lon, speedKmh, leanAngle, cornerG) {
    if (!lat || !lon || this.movementHistory.length < 3 || leanAngle < 5) return;
    const recent = this.movementHistory.slice(-3);
    const avgBearingChange = recent.reduce((sum, item, idx) => {
      if (idx === 0) return sum;
      const dLon = recent[idx].lon - recent[idx - 1].lon;
      const dLat = recent[idx].lat - recent[idx - 1].lat;
      return sum + Math.atan2(dLon, dLat) * 180 / Math.PI;
    }, 0) / 2;
    if (Math.abs(avgBearingChange) > 2 && cornerG > 0.2) {
      const cornerType = leanAngle > 30 ? 'Tight' : leanAngle > 15 ? 'Medium' : 'Sweeping';
      const corner = {
        startLat: recent[0].lat,
        startLon: recent[0].lon,
        speed: parseFloat(speedKmh),
        entrySpeed: parseFloat(recent[0].speed * 3.6),
        exitSpeed: parseFloat(speedKmh),
        g: cornerG,
        lean: leanAngle,
        type: cornerType,
        time: Date.now()
      };
      this.corners.push(corner);
      this.cornerEntrySpeeds.push(corner.entrySpeed);
      this.cornerExitSpeeds.push(corner.exitSpeed);
      if (speedKmh > this.maxCornerSpeed) this.maxCornerSpeed = parseFloat(speedKmh);
      if (cornerG > this.maxCornerG) this.maxCornerG = cornerG;
      this.updateCornerDisplay();
    }
  },

  updateCornerDisplay: function() {
    document.getElementById('currentCornerG').textContent = this.currentCornerG.toFixed(2) + ' g';
    document.getElementById('maxCornerSpeed').textContent = this.maxCornerSpeed.toFixed(1) + ' km/h';
    document.getElementById('maxCornerG').textContent = this.maxCornerG.toFixed(2) + ' g';
    const avgLean = this.corners.reduce((sum, c) => sum + c.lean, 0) / Math.max(1, this.corners.length);
    document.getElementById('avgCornerLean').textContent = avgLean.toFixed(1) + '¬∞';
    const avgEntrySpeed = this.cornerEntrySpeeds.reduce((sum, s) => sum + s, 0) / Math.max(1, this.cornerEntrySpeeds.length);
    document.getElementById('avgCornerEntrySpeed').textContent = avgEntrySpeed.toFixed(1) + ' km/h';
    const cornerList = document.getElementById('cornerList');
    cornerList.innerHTML = this.corners.slice(-5).map(c =>
      `<p>${c.type} Corner: ${c.speed.toFixed(1)} km/h, Entry: ${c.entrySpeed.toFixed(1)} km/h, Exit: ${c.exitSpeed.toFixed(1)} km/h, ${c.g.toFixed(2)}g, ${c.lean}¬∞</p>`
    ).join('') || 'No corners detected yet.';
    this.cornerChart.data.labels = this.corners.slice(-5).map((_, i) => `Corner ${i + 1}`);
    this.cornerChart.data.datasets[0].data = this.corners.slice(-5).map(c => c.g.toFixed(2));
    this.cornerChart.update();
  },

  updateWheelAnimation: function() {
    const wheel = document.querySelector('.spinning-wheel');
    const spokes = document.querySelectorAll('.wheel-spoke');
    if (this.currentSpeed <= 0.1) {
      wheel.style.animation = 'none';
      spokes.forEach(spoke => spoke.style.animation = 'none');
      this.log('Wheel animation stopped (speed <= 0.1 m/s)');
    } else {
      const speedKmh = this.currentSpeed * 3.6;
      this.rotationSpeed = Math.max(0.2, 2 / (speedKmh / 10));
      wheel.style.animation = `wheel-spin ${this.rotationSpeed}s linear infinite`;
      spokes.forEach((spoke, index) => {
        const spokeSpeed = this.rotationSpeed * (1 + index * 0.5);
        spoke.style.animation = `spoke-spin ${spokeSpeed}s linear infinite ${index % 2 === 0 ? '' : 'reverse'}`;
      });
      this.log(`Wheel animation updated: ${this.rotationSpeed.toFixed(2)}s per rotation at ${speedKmh.toFixed(1)} km/h`);
    }
  },

  toggleMute: function() {
    this.isMuted = !this.isMuted;
    const muteBtn = document.getElementById("muteBtn");
    if (this.isMuted) {
      muteBtn.textContent = "Sound Muted";
      muteBtn.classList.add("muted");
      clearTimeout(this.bleepTimer);
      this.log("Audio muted");
    } else {
      muteBtn.textContent = "Mute Sound";
      muteBtn.classList.remove("muted");
      this.log("Audio unmuted");
    }
  },

  toggleAutoLock: function() {
    this.autoLockEnabled = !this.autoLockEnabled;
    if (this.autoLockEnabled) {
      document.getElementById("autoLockBtn").textContent = "Auto-Lock: ON";
      document.getElementById("autoLockBtn").style.backgroundColor = "#ff6600";
      document.getElementById("autoLockBtn").style.color = "#000";
      document.getElementById("autoLockSettings").style.display = "block";
      this.log("Auto-lock enabled - will lock when stopped for specified time");
      this.updateGpsStatus("Auto-lock enabled - will lock when stopped");
    } else {
      document.getElementById("autoLockBtn").textContent = "Auto-Lock Mode";
      document.getElementById("autoLockBtn").style.backgroundColor = "";
      document.getElementById("autoLockBtn").style.color = "";
      document.getElementById("autoLockSettings").style.display = "none";
      clearTimeout(this.autoLockDebounce);
      this.autoLockDebounce = null;
      this.isStationary = false;
      this.lastStationaryTime = null;
      this.lastStationaryPosition = null;
      this.speedThreshold = 10;
      document.getElementById("speedThreshold").value = 10;
      document.getElementById("speedThresholdValue").textContent = "10 km/h";
      this.log("Auto-lock disabled");
      this.updateGpsStatus("Auto-lock disabled");
    }
    this.updateUI();
  },

  initAudio: function() {
    if (this.audioCtx) {
      if (this.audioCtx.state === 'suspended') {
        this.audioCtx.resume().then(() => this.log("Audio context resumed"));
      }
      return;
    }
    try {
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      document.getElementById("audioStatus").textContent = "Audio: Initialized";
      document.getElementById("audioStatus").className = "status success";
      document.getElementById("autoLockBtn").disabled = false;
      this.isAudioAllowed = true;
      this.log("Audio system initialized");
    } catch (e) {
      document.getElementById("audioStatus").textContent = `Audio: ${e.message}`;
      document.getElementById("audioStatus").className = "status error";
      this.log(`Audio init error: ${e.message}`, true);
    }
  },

  playTestSound: function() {
    if (!this.audioCtx || this.isMuted) {
      this.log("Audio context not ready or muted", true);
      return;
    }
    try {
      const now = this.audioCtx.currentTime;
      const osc = this.audioCtx.createOscillator();
      const gain = this.audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      osc.connect(gain);
      gain.connect(this.audioCtx.destination);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 0.1);
      gain.gain.linearRampToValueAtTime(0, now + 0.5);
      osc.start(now);
      osc.stop(now + 0.5);
      this.log("Test sound played");
    } catch (e) {
      this.log(`Test sound error: ${e.message}`, true);
    }
  },

  lockCurrentPosition: function() {
    if (!this.lastPosition) {
      this.log("No position available to lock", true);
      return;
    }
    this.lockPosition = { lat: this.lastPosition.lat, lon: this.lastPosition.lon };
    this.lockMarker.setLatLng([this.lockPosition.lat, this.lockPosition.lon]);
    document.getElementById("lockStatus").textContent = `Lock Status: Locked at Lat ${this.lockPosition.lat.toFixed(6)}, Lon ${this.lockPosition.lon.toFixed(6)}`;
    document.getElementById("lockStatus").className = "status success";
    this.isActive = true;
    document.getElementById("stopBtn").disabled = false;
    document.getElementById("muteBtn").disabled = false;
    this.updateGpsStatus("Position locked");
    this.log(`Position locked at Lat ${this.lockPosition.lat.toFixed(6)}, Lon ${this.lockPosition.lon.toFixed(6)}`);
    this.startBleep();
  },

  startBleep: function() {
    if (!this.isActive || this.isMuted || !this.audioCtx) return;
    clearTimeout(this.bleepTimer);
    const distance = this.calculateDistance(this.lastPosition, this.lockPosition);
    const maxDist = parseFloat(document.getElementById("maxDistInput").value);
    const freq = parseFloat(document.getElementById("freqInput").value);
    let tempo = 1000;
    if (distance < maxDist) {
      tempo = Math.max(100, 1000 * (distance / maxDist));
      const now = this.audioCtx.currentTime;
      const osc = this.audioCtx.createOscillator();
      const gain = this.audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, now);
      osc.connect(gain);
      gain.connect(this.audioCtx.destination);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 0.05);
      gain.gain.linearRampToValueAtTime(0, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
    }
    document.getElementById("bleepRate").textContent = (60000 / tempo).toFixed(0);
    this.currentTempo = tempo;
    this.bleepTimer = setTimeout(() => this.startBleep(), tempo);
  },

  calculateDistance: function(pos1, pos2) {
    if (!pos1 || !pos2) return Infinity;
    const R = 6371e3;
    const œÜ1 = pos1.lat * Math.PI / 180;
    const œÜ2 = pos2.lat * Math.PI / 180;
    const ŒîœÜ = (pos2.lat - pos1.lat) * Math.PI / 180;
    const ŒîŒª = (pos2.lon - pos1.lon) * Math.PI / 180;
    const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  },

  updateGpsStatus: function(message) {
    document.getElementById("gpsStatus").textContent = `GPS: ${message}`;
    document.getElementById("gpsStatus").className = message.includes("error") ? "status error" : "status success";
  },

  updateUI: function() {
    document.getElementById("currentSpeed").textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
    document.getElementById("maxSpeed").textContent = this.maxSpeed.toFixed(1) + " km/h";
    document.getElementById("avgSpeed").textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
    document.getElementById("todayDistance").textContent = this.todayDistance.toFixed(1) + " km";
    document.getElementById("statsToday").textContent = this.todayDistance.toFixed(1) + " km";
    document.getElementById("statsWeek").textContent = this.weekDistance.toFixed(1) + " km";
    document.getElementById("statsMonth").textContent = this.monthDistance.toFixed(1) + " km";
    document.getElementById("statsTotal").textContent = this.totalDistance.toFixed(1) + " km";
    document.getElementById("statsCurrentSpeed").textContent = (this.currentSpeed * 3.6).toFixed(1) + " km/h";
    document.getElementById("statsMaxSpeed").textContent = this.maxSpeed.toFixed(1) + " km/h";
    document.getElementById("statsAvgSpeed").textContent = this.calculateAverageSpeed().toFixed(1) + " km/h";
    document.getElementById("statsAcceleration").textContent = this.calculateAccelerationTime().toFixed(2) + " s";
    document.getElementById("accelerationTime").textContent = this.calculateAccelerationTime().toFixed(2) + " s";
    this.updateCornerDisplay();
    this.updateElevationProfile();
    this.updateMaintenanceList();
    this.updateEmergencyContacts();
    this.updateRideHistory();
     if (this.isOverlayVisible) {
    this.updateOverlayStats();
    this.updateEnlargedWheelAnimation();
  }
  },

  calculateAverageSpeed: function() {
    if (this.movementHistory.length < 2) return 0;
    const totalSpeed = this.movementHistory.reduce((sum, pos) => sum + pos.speed * 3.6, 0);
    return totalSpeed / this.movementHistory.length;
  },

  calculateAccelerationTime: function() {
    if (!this.accelerationTimes.length) return 0;
    return this.accelerationTimes.reduce((sum, time) => sum + time, 0) / this.accelerationTimes.length;
  },

  startRide: function() {
    if (this.isRideActive) return;
    this.isRideActive = true;
    this.rideStartTime = Date.now();
    this.movementHistory = [];
    this.corners = [];
    this.cornerEntrySpeeds = [];
    this.cornerExitSpeeds = [];
    this.elevationHistory = [];
    this.elevationGain = 0;
    this.maxSpeed = 0;
    this.maxLeanAngle = 0;
    this.maxCornerG = 0;
    this.maxCornerSpeed = 0;
    this.accelerationTimes = [];
    document.getElementById("startRideBtn").textContent = "Ride Active";
    document.getElementById("startRideBtn").disabled = true;
    this.watchId = navigator.geolocation.watchPosition(
      pos => this.updatePosition(pos),
      err => this.handleGpsError(err),
      { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
    );
    this.log("Ride started");
  },

  updatePosition: function(pos) {
    this.prevPosition = this.lastPosition;
    this.lastPosition = { lat: pos.coords.latitude, lon: pos.coords.longitude, alt: pos.coords.altitude || 0 };
    this.currentSpeed = pos.coords.speed || 0;
    if (this.currentSpeed > this.maxSpeed) this.maxSpeed = this.currentSpeed * 3.6;
    this.movementHistory.push({ lat: this.lastPosition.lat, lon: this.lastPosition.lon, speed: this.currentSpeed, alt: this.lastPosition.alt, time: Date.now() });

    if (this.prevPosition) {
      const distance = this.calculateDistance(this.prevPosition, this.lastPosition) / 1000;
      this.totalDistance += distance;
      this.todayDistance += distance;
      this.weekDistance += distance;
      this.monthDistance += distance;

      if (this.prevPosition.alt && this.lastPosition.alt && this.lastPosition.alt > this.prevPosition.alt) {
        this.elevationGain += this.lastPosition.alt - this.prevPosition.alt;
      }
      this.elevationHistory.push({ elev: this.lastPosition.alt, time: Date.now() });
    }

    if (this.isRideActive && this.currentSpeed * 3.6 >= this.accelTarget && this.accelerationStartTime && !this.accelerationTimes.some(t => t)) {
      const accelTime = (Date.now() - this.accelerationStartTime) / 1000;
      this.accelerationTimes.push(accelTime);
      this.accelerationStartTime = null;
    } else if (this.currentSpeed * 3.6 < this.accelTarget && !this.accelerationStartTime) {
      this.accelerationStartTime = Date.now();
    }

    this.userMarker.setLatLng([this.lastPosition.lat, this.lastPosition.lon]);
    this.line.addLatLng([this.lastPosition.lat, this.lastPosition.lon]);
    this.map.panTo([this.lastPosition.lat, this.lastPosition.lon]);

    if (this.lockPosition) {
      const distance = this.calculateDistance(this.lastPosition, this.lockPosition);
      document.getElementById("distance").textContent = distance.toFixed(0);
      document.getElementById("accuracy").textContent = pos.coords.accuracy.toFixed(1);
      if (distance < 5 && !this.reachedPointDisplayed) {
        document.getElementById("reachedMessage").style.display = "block";
        this.reachedPointDisplayed = true;
        setTimeout(() => {
          document.getElementById("reachedMessage").style.display = "none";
          this.reachedPointDisplayed = false;
        }, 5000);
        this.stop();
      }
      this.updateDirection();
    }

    if (this.autoLockEnabled) {
      if (this.currentSpeed * 3.6 < this.speedThreshold) {
        if (!this.lastStationaryTime) {
          this.lastStationaryTime = Date.now();
          this.lastStationaryPosition = this.lastPosition;
        } else if (Date.now() - this.lastStationaryTime > parseInt(document.getElementById("stationaryTime").value) * 1000) {
          this.lockCurrentPosition();
          this.toggleAutoLock();
        }
      } else {
        this.lastStationaryTime = null;
        this.lastStationaryPosition = null;
      }
    }

    this.updateWheelAnimation();
    this.updateUI();
    this.startBleep();
  },

  handleGpsError: function(err) {
    this.log(`GPS error: ${err.message}`, true);
    this.updateGpsStatus(`Error: ${err.message}`);
  },

  updateDirection: function() {
    if (!this.lastPosition || !this.lockPosition) return;
    const dLon = this.lockPosition.lon - this.lastPosition.lon;
    const dLat = this.lockPosition.lat - this.lastPosition.lat;
    const angle = Math.atan2(dLon, dLat) * 180 / Math.PI;
    document.getElementById("directionArrow").style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
    document.getElementById("directionStatus").textContent = `Direction: ${angle.toFixed(0)}¬∞`;
  },

  stop: function() {
    if (this.watchId) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
    clearTimeout(this.bleepTimer);
    this.isActive = false;
    this.isRideActive = false;
    document.getElementById("startRideBtn").textContent = "Start Ride";
    document.getElementById("startRideBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
    document.getElementById("muteBtn").disabled = true;
    document.getElementById("lockStatus").textContent = "Lock Status: Not locked";
    document.getElementById("lockStatus").className = "status";
    this.lockPosition = null;
    this.updateWheelAnimation();
    this.log("Tracking stopped");
    if (this.rideStartTime) {
      this.rideHistory.push({
        startTime: this.rideStartTime,
        distance: this.todayDistance,
        maxSpeed: this.maxSpeed,
        avgSpeed: this.calculateAverageSpeed(),
        acceleration: this.calculateAccelerationTime(),
        corners: this.corners.length,
        elevationGain: this.elevationGain
      });
      this.rideStartTime = null;
    }
    this.updateRideHistory();
  },

  resetMetrics: function() {
    this.maxSpeed = 0;
    this.totalDistance = 0;
    this.todayDistance = 0;
    this.weekDistance = 0;
    this.monthDistance = 0;
    this.elevationGain = 0;
    this.corners = [];
    this.cornerEntrySpeeds = [];
    this.cornerExitSpeeds = [];
    this.maxCornerG = 0;
    this.maxCornerSpeed = 0;
    this.accelerationTimes = [];
    this.elevationHistory = [];
    this.updateUI();
    this.log("Metrics reset");
  },

  exportMetrics: function() {
    const data = {
      totalDistance: this.totalDistance,
      todayDistance: this.todayDistance,
      weekDistance: this.weekDistance,
      monthDistance: this.monthDistance,
      maxSpeed: this.maxSpeed,
      avgSpeed: this.calculateAverageSpeed(),
      acceleration: this.calculateAccelerationTime(),
      corners: this.corners,
      elevationGain: this.elevationGain,
      elevationHistory: this.elevationHistory,
      rideHistory: this.rideHistory
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ride_metrics.json';
    a.click();
    URL.revokeObjectURL(url);
    this.log("Metrics exported");
  },

sendEmergencyAlert: function(message = null) {
  const msg = message || `${document.getElementById('emergencyMessage').value} Lat: ${this.lastPosition?.lat.toFixed(6)}, Lon: ${this.lastPosition?.lon.toFixed(6)}`;
  
  this.emergencyContacts.forEach(contact => {
    // Method 1: Open SMS app (works on mobile)
    const smsUrl = `sms:${contact}?body=${encodeURIComponent(msg)}`;
    window.open(smsUrl, '_blank');
    
    // Method 2: For web fallback - use Share API if available
    if (navigator.share) {
      navigator.share({
        title: 'EMERGENCY ALERT',
        text: msg,
        url: window.location.href
      }).catch(err => {
        console.log('Share API failed, using SMS fallback');
        window.open(smsUrl, '_blank');
      });
    }
    
    this.log(`Sending emergency alert to ${contact}: ${msg}`);
  });
  
  // Visual feedback
  document.getElementById('emergencyBtn').textContent = 'ALERT SENT!';
  document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, #00cc66, #00aa55)';
  setTimeout(() => {
    document.getElementById('emergencyBtn').textContent = 'EMERGENCY ALERT';
    document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, var(--error-color), #cc0000)';
  }, 3000);
  
  this.log("Emergency alerts sent to all contacts");
},

testEmergency: function() {
  this.log("Testing emergency alert");
  // For test, just show what would be sent without actually sending
  const testMsg = "TEST ALERT: This is a test emergency message. Lat: " + 
                 (this.lastPosition?.lat.toFixed(6) || 'unknown') + 
                 ", Lon: " + (this.lastPosition?.lon.toFixed(6) || 'unknown');
  
  if (confirm(`Test Emergency Alert:\n\n${testMsg}\n\nOpen SMS app to test?`)) {
    this.sendEmergencyAlert("TEST ALERT: This is a test emergency message.");
  }
},

// Emergency contacts functions:
showContactModal: function() {
  document.getElementById('addContactModal').style.display = 'flex';
  document.getElementById('newContactName').value = '';
  document.getElementById('newContactNumber').value = '';
  document.getElementById('newContactName').focus();
},

closeContactModal: function() {
  document.getElementById('addContactModal').style.display = 'none';
},

saveNewContact: function() {
  const name = document.getElementById('newContactName').value.trim();
  const number = document.getElementById('newContactNumber').value.trim();
  
  if (!name) {
    alert('Please enter a contact name');
    return;
  }
  
  if (!number) {
    alert('Please enter a phone number');
    return;
  }

  // Validate phone number (basic validation)
  const cleanNumber = number.replace(/[^\d+]/g, '');
  if (cleanNumber.length < 10) {
    alert('Please enter a valid phone number');
    return;
  }

  // Add contact to array
  this.emergencyContacts.push({
    id: Date.now(), // Unique ID
    name: name,
    number: cleanNumber
  });

  // Save to localStorage
  this.saveContactsToStorage();
  
  // Update UI
  this.updateEmergencyContacts();
  this.closeContactModal();
  
  this.log(`Contact added: ${name} - ${cleanNumber}`);
},

updateEmergencyContacts: function() {
  const list = document.getElementById("emergencyContactList");
  
  if (this.emergencyContacts.length === 0) {
    list.innerHTML = `
      <div style="text-align: center; padding: 20px; color: #aaa;">
        No emergency contacts added yet.<br>
        Click "Add Contact" to add your first contact.
      </div>
    `;
    return;
  }

  list.innerHTML = this.emergencyContacts.map(contact => `
    <div class="contact-item" data-contact-id="${contact.id}">
      <div class="contact-info">
        <strong>${contact.name}</strong><br>
        <span style="font-size: 0.9em; color: #ccc;">${contact.number}</span>
      </div>
      <div class="contact-actions">
        <button onclick="MotoFindBack.callContact('${contact.number}')" title="Call">üìû</button>
        <button onclick="MotoFindBack.messageContact('${contact.number}')" title="Message">üí¨</button>
        <button onclick="MotoFindBack.removeContact(${contact.id})" title="Remove" style="background: #ff3333;">üóëÔ∏è</button>
      </div>
    </div>
  `).join('');
},

removeContact: function(contactId) {
  if (confirm('Remove this contact?')) {
    this.emergencyContacts = this.emergencyContacts.filter(contact => contact.id !== contactId);
    this.saveContactsToStorage();
    this.updateEmergencyContacts();
    this.log('Contact removed');
  }
},

// Updated sendEmergencyAlert to work with contact objects
sendEmergencyAlert: function(message = null) {
  if (this.emergencyContacts.length === 0) {
    alert('No emergency contacts added! Please add contacts first.');
    this.showContactModal();
    return;
  }

  const msg = message || `${document.getElementById('emergencyMessage').value} Lat: ${this.lastPosition?.lat.toFixed(6)}, Lon: ${this.lastPosition?.lon.toFixed(6)}`;
  
  this.emergencyContacts.forEach(contact => {
    const smsUrl = `sms:${contact.number}?body=${encodeURIComponent(msg)}`;
    window.open(smsUrl, '_blank');
    this.log(`Sending emergency alert to ${contact.name}: ${contact.number}`);
  });

  // Visual feedback
  document.getElementById('emergencyBtn').textContent = 'ALERT SENT!';
  document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, #00cc66, #00aa55)';
  setTimeout(() => {
    document.getElementById('emergencyBtn').textContent = 'EMERGENCY ALERT';
    document.getElementById('emergencyBtn').style.background = 'linear-gradient(to bottom, var(--error-color), #cc0000)';
  }, 3000);
},

// Updated contact functions to work with numbers
callContact: function(phoneNumber) {
  const telUrl = `tel:${phoneNumber}`;
  window.open(telUrl, '_blank');
  this.log(`Calling ${phoneNumber}`);
},

messageContact: function(phoneNumber) {
  const msg = document.getElementById('emergencyMessage').value + 
              ` Lat: ${this.lastPosition?.lat.toFixed(6) || 'unknown'}, Lon: ${this.lastPosition?.lon.toFixed(6) || 'unknown'}`;
  const smsUrl = `sms:${phoneNumber}?body=${encodeURIComponent(msg)}`;
  window.open(smsUrl, '_blank');
  this.log(`Messaging ${phoneNumber}`);
},

// Storage functions
saveContactsToStorage: function() {
  localStorage.setItem('emergencyContacts', JSON.stringify(this.emergencyContacts));
},

loadContactsFromStorage: function() {
  const saved = localStorage.getItem('emergencyContacts');
  if (saved) {
    this.emergencyContacts = JSON.parse(saved);
    this.updateEmergencyContacts();
  }
},



// Enhanced crash detection with actual alert sending
triggerCrashAlert: function() {
  document.getElementById('crashStatus').textContent = 'Crash detected! Sending alert...';
  document.getElementById('crashStatus').className = 'status error';
  this.log('Crash confirmed, triggering emergency alert');
  
  if (this.lastPosition) {
    const message = `üö® CRASH DETECTED! ${document.getElementById('emergencyMessage').value} 
Location: https://maps.google.com/?q=${this.lastPosition.lat},${this.lastPosition.lon}
Lat: ${this.lastPosition.lat.toFixed(6)}, Lon: ${this.lastPosition.lon.toFixed(6)}`;
    
    // Send actual emergency alerts
    this.sendEmergencyAlert(message);
    
    // Also try to make an emergency call if possible
    setTimeout(() => {
      if (confirm('Crash detected! Call emergency services?')) {
        window.open('tel:112', '_blank'); // Europe emergency
        // window.open('tel:911', '_blank'); // US emergency
      }
    }, 1000);
    
  } else {
    this.log('No recent position available for crash alert', true);
    document.getElementById('crashStatus').textContent = 'Crash detected, but no position available';
  }
},

callEmergency: function() {
  // Determine local emergency number based on region or let user choose
  const emergencyNumbers = ['112', '911', '999'];
  const number = emergencyNumbers[0]; // Use first one, or implement region detection
  
  if (confirm(`Call emergency services (${number})?`)) {
    window.open(`tel:${number}`, '_blank');
  }
},



  saveMaintenanceItem: function() {
    const name = document.getElementById("newMaintenanceName").value;
    const interval = parseInt(document.getElementById("newMaintenanceInterval").value);
    if (name && interval) {
      this.maintenanceItems.push({ name, interval, progress: 0 });
      this.updateMaintenanceList();
      document.getElementById("newMaintenanceName").value = "";
      document.getElementById("newMaintenanceInterval").value = "";
      this.log(`Maintenance item added: ${name}`);
    }
  },

  resetMaintenance: function() {
    this.maintenanceItems = [];
    this.updateMaintenanceList();
    this.log("Maintenance items reset");
  },

  updateMaintenanceList: function() {
    const list = document.getElementById("maintenanceList");
    list.innerHTML = this.maintenanceItems.map(item => `
      <div class="maintenance-item">
        <div>${item.name}</div>
        <div class="maintenance-progress">
          <div class="maintenance-progress-bar" style="width: ${(item.progress / item.interval) * 100}%"></div>
        </div>
        <div>${item.progress}/${item.interval} km</div>
      </div>
    `).join('') || `
      <div class="maintenance-item">
        <div>Oil Change</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 30%"></div></div>
        <div>2000/5000 km</div>
      </div>
      <div class="maintenance-item">
        <div>Tire Pressure</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 70%"></div></div>
        <div>Check weekly</div>
      </div>
      <div class="maintenance-item">
        <div>Chain Lubrication</div>
        <div class="maintenance-progress"><div class="maintenance-progress-bar" style="width: 50%"></div></div>
        <div>500/1000 km</div>
      </div>
    `;
  },

  updateRideHistory: function() {
    const history = document.getElementById("rideHistory");
    history.innerHTML = this.rideHistory.map(ride => `
      <div>Ride on ${new Date(ride.startTime).toLocaleString()}: ${ride.distance.toFixed(1)} km, Max Speed: ${ride.maxSpeed.toFixed(1)} km/h, Avg Speed: ${ride.avgSpeed.toFixed(1)} km/h, 0-${this.accelTarget} km/h: ${ride.acceleration.toFixed(2)} s, Corners: ${ride.corners}, Elevation Gain: ${ride.elevationGain.toFixed(0)} m</div>
    `).join('') || "No ride history yet.";
  },

  loadData: function() {
    this.log("Loading saved data (placeholder)");
  },

  log: function(message, isError = false) {
    const debug = document.getElementById("debug");
    debug.innerHTML += `<div style="color: ${isError ? '#ff3333' : '#aaa'}">${new Date().toLocaleTimeString()}: ${message}</div>`;
    debug.scrollTop = debug.scrollHeight;
  }
};
                                                                                                                                 
                                                                                                                                 

MotoFindBack.init();
</script>
  </body>
</html>
